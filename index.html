<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Neon Sopwith</title>
<style>
*,*::before,*::after{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#0a0a0f;font-family:'Courier New',monospace}
#wrap{position:relative;width:100%;height:100%;display:flex;flex-direction:column}
#radar{height:40px;background:#08080c;border-bottom:1px solid #1a1a2a;position:relative;overflow:hidden}
#game{flex:1;position:relative;image-rendering:auto}
#game canvas{width:100%;height:100%;display:block}
/* scanlines */
#game::after{content:'';position:absolute;inset:0;background:repeating-linear-gradient(0deg,transparent,transparent 2px,rgba(0,0,0,0.08) 2px,rgba(0,0,0,0.08) 4px);pointer-events:none;z-index:2}
/* CRT vignette */
#game::before{content:'';position:absolute;inset:0;background:radial-gradient(ellipse at center,transparent 60%,rgba(0,0,0,0.5) 100%);pointer-events:none;z-index:3}
#hud{height:36px;background:#08080c;border-top:1px solid #1a1a2a;display:flex;align-items:center;justify-content:center;gap:2rem;font-size:13px;color:#8af;padding:0 1rem;flex-shrink:0}
.hud-item{display:flex;align-items:center;gap:0.4rem;white-space:nowrap}
.hud-label{color:#557;font-size:11px;text-transform:uppercase;letter-spacing:1px}
.hud-val{color:#0ff;font-weight:bold;text-shadow:0 0 6px #0ff}
.hud-val.red{color:#f55;text-shadow:0 0 6px #f55}
.hud-val.green{color:#0fa;text-shadow:0 0 6px #0fa}
.fuel-bar{width:80px;height:8px;background:#112;border:1px solid #335;border-radius:2px;overflow:hidden;display:inline-block;vertical-align:middle;position:relative}
.fuel-fill{display:block;height:100%;background:linear-gradient(90deg,#0f0,#0ff);transition:width 0.2s}
.fuel-bar.warning .fuel-fill{animation:bar-flash 0.5s ease-in-out infinite;background:linear-gradient(90deg,#f22,#f55)}
.fuel-pct{font-size:9px;color:#8af;margin-left:4px;min-width:28px;display:inline-block;vertical-align:middle}
.ammo-bar{width:70px;height:8px;background:#112;border:1px solid #335;border-radius:2px;overflow:hidden;display:inline-block;vertical-align:middle;position:relative}
.ammo-fill{display:block;height:100%;background:linear-gradient(90deg,#ff0,#fa0);transition:width 0.2s}
.ammo-bar.warning .ammo-fill{animation:bar-flash 0.5s ease-in-out infinite;background:linear-gradient(90deg,#f22,#f55)}
.ammo-pct{font-size:9px;color:#8af;margin-left:4px;min-width:28px;display:inline-block;vertical-align:middle}
@keyframes bar-flash{0%,100%{box-shadow:0 0 6px #f00 inset}50%{box-shadow:0 0 12px #f55 inset}}
/* ── Touch controls ── */
#touch-zone{display:none;position:absolute;inset:0;z-index:5;touch-action:none}
#touch-actions{display:none;position:absolute;right:8px;bottom:50px;z-index:10;pointer-events:none;flex-direction:column;gap:8px}
.touch-btn{pointer-events:auto;width:52px;height:52px;border-radius:50%;border:2px solid rgba(0,255,255,0.35);background:rgba(0,20,40,0.45);color:#0ff;font:bold 12px 'Courier New',monospace;display:flex;align-items:center;justify-content:center;user-select:none;-webkit-user-select:none;touch-action:none;text-shadow:0 0 6px #0ff}
.touch-btn:active,.touch-btn.held{background:rgba(0,255,255,0.25);border-color:#0ff}
.touch-btn.fire{border-color:rgba(255,100,100,0.4);color:#f66;text-shadow:0 0 6px #f66;width:58px;height:58px}
.touch-btn.fire:active,.touch-btn.fire.held{background:rgba(255,50,50,0.25);border-color:#f66}
.touch-btn.bomb{border-color:rgba(255,160,0,0.4);color:#fa0;text-shadow:0 0 6px #fa0}
.touch-btn.bomb:active,.touch-btn.bomb.held{background:rgba(255,160,0,0.25);border-color:#fa0}
#touch-start{display:none;position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);z-index:20;pointer-events:auto;padding:18px 36px;border-radius:12px;border:2px solid #0ff;background:rgba(0,20,40,0.8);color:#0ff;font:bold 20px 'Courier New',monospace;text-shadow:0 0 10px #0ff;touch-action:none;user-select:none;-webkit-user-select:none}
#touch-pitch-indicator{display:none;position:absolute;left:12px;top:50%;transform:translateY(-50%);width:4px;height:80px;background:rgba(0,255,255,0.15);border-radius:2px;z-index:10;pointer-events:none}
#touch-pitch-dot{position:absolute;left:-4px;width:12px;height:12px;border-radius:50%;background:#0ff;box-shadow:0 0 8px #0ff;top:50%;transform:translateY(-50%);transition:top 0.05s}
@media (hover:none) and (pointer:coarse){
  #touch-zone{display:block !important}
  #touch-actions{display:flex !important}
  #touch-start.visible{display:block !important}
  #touch-start:not(.visible){display:none !important}
  #touch-pitch-indicator{display:block !important}
  #radar{height:60px}
}
</style>
</head>
<body>
<div id="wrap">
  <canvas id="radar"></canvas>
  <div id="game">
    <canvas id="c"></canvas>
    <!-- Touch: full-screen gesture zone (hold=throttle, drag=pitch) -->
    <div id="touch-zone"></div>
    <!-- Touch: start/retry button -->
    <div id="touch-start" class="visible">TAP TO START</div>
    <!-- Touch: pitch indicator -->
    <div id="touch-pitch-indicator"><div id="touch-pitch-dot"></div></div>
    <!-- Touch: action buttons (right side) -->
    <div id="touch-actions">
      <div class="touch-btn fire" data-key="Space">FIRE</div>
      <div class="touch-btn bomb" data-key="KeyB">BOMB</div>
      <div class="touch-btn" data-key="KeyH">HOME</div>
    </div>
  </div>
  <div id="hud">
    <div class="hud-item"><span class="hud-label">HP</span><span id="h-hp" class="hud-val green">■■■</span></div>
    <div class="hud-item"><span class="hud-label">Lives</span><span id="h-lives" class="hud-val">●●●●●</span></div>
    <div class="hud-item"><span class="hud-label">Fuel</span><span id="fuel-bar-wrap" class="fuel-bar"><span id="h-fuel" class="fuel-fill" style="width:100%"></span></span><span id="h-fuel-pct" class="fuel-pct">100%</span></div>
    <div class="hud-item"><span class="hud-label">Bombs</span><span id="h-bombs" class="hud-val">5</span></div>
    <div class="hud-item"><span class="hud-label">Ammo</span><span id="ammo-bar-wrap" class="ammo-bar"><span id="h-ammo" class="ammo-fill" style="width:100%"></span></span><span id="h-ammo-pct" class="ammo-pct">100%</span></div>
    <div class="hud-item"><span class="hud-label">Score</span><span id="h-score" class="hud-val green">0</span></div>
    <div class="hud-item"><span class="hud-label">Level</span><span id="h-level" class="hud-val">1</span></div>
  </div>
</div>

<script>
// ═══════════════════════════════════════════════════════════════
//  NEON SOPWITH — A Sopwith-inspired neon retro biplane game
// ═══════════════════════════════════════════════════════════════
(() => {
'use strict';
const GAME_VERSION = 'd2b3be8'; // git short hash — updated each commit

// ── Canvas setup ──
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const radarCanvas = document.getElementById('radar');
const rctx = radarCanvas.getContext('2d');

function resize() {
  const gd = document.getElementById('game');
  canvas.width = gd.clientWidth;
  canvas.height = gd.clientHeight;
  radarCanvas.width = radarCanvas.parentElement ? radarCanvas.clientWidth || window.innerWidth : window.innerWidth;
  radarCanvas.height = radarCanvas.clientHeight || 40;
}
resize();
window.addEventListener('resize', resize);

// ── Constants ──
const WORLD_W = 12000;
const BULLET_SPEED = 600;
const BOMB_VXFRAC = 0.8;
const MAX_FUEL = 2500;
const MAX_AMMO = 200;
const MAX_BOMBS = 5;
const FLAK_INTERVAL = 90;
const FLAK_SPEED = 300;
const ENEMY_SPEED = 200;
const ENEMY_FIRE_INTERVAL = 60;
const BASE_WIDTH = 120;

// ── Enemy type constants ──
const JET_SPEED = 340;
const JET_FIRE_INTERVAL = 35;
const BOMBER_SPEED = 140;
const BOMBER_BOMB_INTERVAL = 120;
const ZEPPELIN_SPEED = 60;
const ZEPPELIN_BOMB_INTERVAL = 80;

const ENEMY_SPECS = {
  biplane: { hp: 2, speed: 200, fireInterval: ENEMY_FIRE_INTERVAL, score: 300, color: '#f0a', hitW: 20, hitH: 12 },
  jet:     { hp: 2, speed: JET_SPEED, fireInterval: JET_FIRE_INTERVAL, score: 500, color: '#f55', hitW: 20, hitH: 12 },
  bomber:  { hp: 5, speed: BOMBER_SPEED, fireInterval: BOMBER_BOMB_INTERVAL, score: 700, color: '#fa0', hitW: 30, hitH: 15 },
  zeppelin:{ hp: 8, speed: ZEPPELIN_SPEED, fireInterval: ZEPPELIN_BOMB_INTERVAL, score: 1500, color: '#aaf', hitW: 50, hitH: 20 }
};

// ── Building score/spec lookup ──
const buildingScores = { flak: 200, factory: 300, hangar: 100, dam: 500, radar_station: 250, fuel_depot: 200, bunker: 150 };
const buildingColors = { flak: '#f80', factory: '#f44', hangar: '#fa0', dam: '#48f', radar_station: '#af0', fuel_depot: '#f80', bunker: '#888' };

// ── Enemy accuracy debuff (from radar station destruction) ──
let enemyAccuracyDebuff = 0;

// ── Level theme system ──
function getLevelTheme(lvl) {
  return (lvl % 2 === 0) ? 'sea' : 'land';
}

// ── Submarine data ──
let submarines = [];

// ── Sopwith-style flight model ──
// 16 discrete angles (like original), speed scalar, gravity table
const NUM_ANGLES = 16;
const ANGLE_STEP = (Math.PI * 2) / NUM_ANGLES;
// Gravity effect per angle index (tuned from original Sopwith)
// Nose up = negative (slows you), nose down = positive (speeds you up)
// Reduced climb penalties so plane can maintain speed in moderate climbs
const GRAVITY_TABLE = [0, 0, -1, -1, -2, -1, -1, 0, 0, 1, 1, 2, 3, 2, 1, 1];
// Sine table (scaled to 1.0 instead of 256 as original)
const SIN_TABLE = [0, 0.383, 0.707, 0.924, 1.0, 0.924, 0.707, 0.383, 0, -0.383, -0.707, -0.924, -1.0, -0.924, -0.707, -0.383];
const COS_TABLE = SIN_TABLE.map((_, i) => SIN_TABLE[(i + 4) % 16]);

const PLANE_MIN_SPEED = 4;    // Minimum speed (like original)
const PLANE_MAX_SPEED = 9;    // Maximum speed
const PLANE_MAX_ACCEL = 5;    // Maximum throttle acceleration
const PIXELS_PER_UNIT = 28;   // Scale factor: Sopwith speed units → pixel velocity
const STALL_SPEED = 2;        // Below this speed, plane stalls
const PLAYER_MAX_HP = 3;      // Hits before plane goes down
const TURN_RATE = 1;          // Angle steps per input (1 = one notch per press)
const PROJ_GRAVITY = 300;     // Gravity for projectiles (pixels/s²)

// ── Game State ──
const ST = { TITLE: 0, PLAYING: 1, DYING: 2, GAME_OVER: 3, LEVEL_COMPLETE: 4 };
let state = ST.TITLE;
let level = 1;
let score = 0;
let lives = 5;
let deathTimer = 0;
let levelTimer = 0;
let extraLifeMsg = 0;  // timer for "+1 LIFE" message
let lastChanceMsg = 0; // timer for "LAST CHANCE" message
let titlePlaneX = -200;

// ── Input ──
const keys = {};
window.addEventListener('keydown', e => { keys[e.code] = true; if(['Space','ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.code)) e.preventDefault(); });
window.addEventListener('keyup', e => { keys[e.code] = false; });

// ── Touch controls ──
// Hold anywhere = throttle (KeyX + ArrowUp), drag up/down = pitch
// Right-side buttons for fire, bomb, flip, home
const isTouchDevice = ('ontouchstart' in window) || navigator.maxTouchPoints > 0;
const touchStartBtn = document.getElementById('touch-start');
const touchZone = document.getElementById('touch-zone');
const pitchDot = document.getElementById('touch-pitch-dot');
let touchThrottleId = null;  // track the main gesture touch
let touchStartY = 0;         // Y where the touch began
let touchCurrentY = 0;
const PITCH_DEADZONE = 12;   // pixels before pitch kicks in
const PITCH_RANGE = 60;      // pixels for full up/down

// Start/retry button
if (touchStartBtn) {
  touchStartBtn.addEventListener('touchstart', (e) => {
    e.preventDefault();
    keys['Enter'] = true;
    setTimeout(() => { keys['Enter'] = false; }, 100);
    touchStartBtn.classList.remove('visible');
    initAudio();
  });
}

// Main touch zone — hold for throttle, drag for pitch
if (touchZone) {
  touchZone.addEventListener('touchstart', (e) => {
    e.preventDefault();
    initAudio();
    if (touchThrottleId !== null) return; // already tracking
    const t = e.changedTouches[0];
    touchThrottleId = t.identifier;
    touchStartY = t.clientY;
    touchCurrentY = t.clientY;
    // Throttle on (KeyX only — ArrowUp would also pitch up)
    keys['KeyX'] = true;
  });

  touchZone.addEventListener('touchmove', (e) => {
    e.preventDefault();
    for (const t of e.changedTouches) {
      if (t.identifier === touchThrottleId) {
        touchCurrentY = t.clientY;
        const dy = touchStartY - touchCurrentY; // positive = dragged up

        // Clear previous pitch keys
        keys['Comma'] = false;
        keys['Slash'] = false;

        if (dy > PITCH_DEADZONE) {
          // Dragged up → nose up
          keys['Comma'] = true;
        } else if (dy < -PITCH_DEADZONE) {
          // Dragged down → nose down
          keys['Slash'] = true;
        }

        // Update pitch indicator dot
        if (pitchDot) {
          const norm = Math.max(-1, Math.min(1, dy / PITCH_RANGE));
          pitchDot.style.top = (50 - norm * 40) + '%';
        }
      }
    }
  });

  const endTouch = (e) => {
    for (const t of e.changedTouches) {
      if (t.identifier === touchThrottleId) {
        touchThrottleId = null;
        keys['KeyX'] = false;
        keys['Comma'] = false;
        keys['Slash'] = false;
        if (pitchDot) pitchDot.style.top = '50%';
      }
    }
  };
  touchZone.addEventListener('touchend', endTouch);
  touchZone.addEventListener('touchcancel', endTouch);
}

// Action buttons (fire, bomb, flip, home)
document.querySelectorAll('.touch-btn').forEach(btn => {
  const keyCode = btn.dataset.key;
  if (!keyCode) return;
  btn.addEventListener('touchstart', (e) => {
    e.preventDefault();
    e.stopPropagation();
    keys[keyCode] = true;
    btn.classList.add('held');
    initAudio();
  });
  btn.addEventListener('touchend', (e) => {
    e.preventDefault();
    keys[keyCode] = false;
    btn.classList.remove('held');
  });
  btn.addEventListener('touchcancel', (e) => {
    keys[keyCode] = false;
    btn.classList.remove('held');
  });
});

// ── Audio (Web Audio synth) ──
let audioCtx = null;
let engineOsc = null;
let engineGain = null;
let audioStarted = false;

function initAudio() {
  if (audioStarted) return;
  audioStarted = true;
  try {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    engineOsc = audioCtx.createOscillator();
    engineGain = audioCtx.createGain();
    engineOsc.type = 'sawtooth';
    engineOsc.frequency.value = 80;
    engineGain.gain.value = 0;
    engineOsc.connect(engineGain);
    engineGain.connect(audioCtx.destination);
    engineOsc.start();
  } catch(e) {}
}

function playShoot() {
  if (!audioCtx) return;
  try {
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = 'square';
    o.frequency.value = 800;
    g.gain.value = 0.08;
    o.connect(g); g.connect(audioCtx.destination);
    o.start();
    o.frequency.exponentialRampToValueAtTime(200, audioCtx.currentTime + 0.05);
    g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.08);
    o.stop(audioCtx.currentTime + 0.08);
  } catch(e) {}
}

function playBoom(big) {
  if (!audioCtx) return;
  try {
    const dur = big ? 0.5 : 0.2;
    const buf = audioCtx.createBuffer(1, audioCtx.sampleRate * dur, audioCtx.sampleRate);
    const data = buf.getChannelData(0);
    for (let i = 0; i < data.length; i++) {
      data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / data.length, big ? 1.5 : 3);
    }
    const src = audioCtx.createBufferSource();
    const g = audioCtx.createGain();
    src.buffer = buf;
    g.gain.value = big ? 0.3 : 0.15;
    src.connect(g); g.connect(audioCtx.destination);
    src.start();
  } catch(e) {}
}

function playBombDrop() {
  if (!audioCtx) return;
  try {
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = 'sine';
    o.frequency.value = 400;
    g.gain.value = 0.07;
    o.connect(g); g.connect(audioCtx.destination);
    o.start();
    o.frequency.exponentialRampToValueAtTime(80, audioCtx.currentTime + 0.6);
    g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.6);
    o.stop(audioCtx.currentTime + 0.6);
  } catch(e) {}
}

function playFlood() {
  if (!audioCtx) return;
  try {
    const dur = 0.8;
    const buf = audioCtx.createBuffer(1, audioCtx.sampleRate * dur, audioCtx.sampleRate);
    const data = buf.getChannelData(0);
    for (let i = 0; i < data.length; i++) {
      const t = i / audioCtx.sampleRate;
      data[i] = (Math.random() * 2 - 1) * Math.pow(1 - t / dur, 0.8) * Math.sin(t * 30);
    }
    const src = audioCtx.createBufferSource();
    const g = audioCtx.createGain();
    src.buffer = buf;
    g.gain.value = 0.25;
    src.connect(g); g.connect(audioCtx.destination);
    src.start();
  } catch(e) {}
}

// ── Stars (background) ──
const stars = [];
for (let i = 0; i < 200; i++) {
  stars.push({ x: Math.random() * WORLD_W, y: Math.random() * 500, b: Math.random() * 0.5 + 0.2, s: Math.random() * 1.5 + 0.5 });
}

// ── Terrain generation ──
let terrain = [];
let baseX = 0;

// ── Sea level: water line Y and island peak positions ──
let waterLineY = 0;
let islandPeaks = [];

function generateTerrain() {
  terrain = new Float32Array(WORLD_W);
  const groundBase = canvas.height * 0.75;
  baseX = Math.floor(WORLD_W / 2 - BASE_WIDTH / 2);

  if (getLevelTheme(level) === 'sea') {
    generateSeaTerrain(groundBase);
  } else {
    generateLandTerrain(groundBase);
  }
}

function generateLandTerrain(groundBase) {
  // Multi-octave noise for hilly terrain
  for (let x = 0; x < WORLD_W; x++) {
    let h = 0;
    h += Math.sin(x * 0.002) * 60;
    h += Math.sin(x * 0.005 + 1.3) * 30;
    h += Math.sin(x * 0.01 + 2.7) * 15;
    h += Math.sin(x * 0.025 + 0.5) * 8;
    terrain[x] = groundBase + h;
  }
  const flatY = groundBase;
  // Flatten a wide area around base
  const flatStart = baseX - 150;
  const flatEnd = baseX + BASE_WIDTH + 400;
  for (let x = Math.max(0, flatStart - 80); x < Math.min(WORLD_W, flatEnd + 80); x++) {
    if (x >= flatStart && x <= flatEnd) {
      terrain[x] = flatY;
    } else if (x < flatStart) {
      const t = (flatStart - x) / 80;
      terrain[x] = flatY * (1 - t) + terrain[x] * t;
    } else {
      const t = (x - flatEnd) / 80;
      terrain[x] = flatY * (1 - t) + terrain[x] * t;
    }
  }
  waterLineY = 0;
  islandPeaks = [];

  // Barrier mountains at world edges
  addBarrierMountains(groundBase);
}

function generateSeaTerrain(groundBase) {
  // Ocean: base terrain is low and flat (water surface)
  waterLineY = groundBase + 30; // water surface is lower than land ground
  islandPeaks = [];

  // Start with flat ocean floor
  for (let x = 0; x < WORLD_W; x++) {
    terrain[x] = waterLineY;
  }

  // Generate 5-8 islands as terrain peaks rising above water
  const numIslands = 5 + Math.floor(Math.random() * 4);
  const islandSpacing = WORLD_W / (numIslands + 2);
  for (let i = 0; i < numIslands; i++) {
    // Spread islands across the world, avoiding center (carrier area)
    let islandCenter;
    do {
      islandCenter = Math.floor(islandSpacing * (i + 1) + (Math.random() - 0.5) * islandSpacing * 0.6);
    } while (Math.abs(islandCenter - baseX - BASE_WIDTH / 2) < 800);

    const islandWidth = 200 + Math.floor(Math.random() * 300);
    const islandHeight = 50 + Math.random() * 60; // how much above water

    islandPeaks.push({ cx: islandCenter, w: islandWidth, h: islandHeight });

    for (let dx = -islandWidth / 2; dx <= islandWidth / 2; dx++) {
      const ix = Math.floor(((islandCenter + dx) % WORLD_W + WORLD_W) % WORLD_W);
      // Bell-curve shape for island
      const factor = Math.cos((dx / (islandWidth / 2)) * Math.PI * 0.5);
      const noiseOffset = Math.sin(ix * 0.02) * 8 + Math.sin(ix * 0.05 + 1.7) * 4;
      terrain[ix] = waterLineY - islandHeight * factor * factor + noiseOffset;
    }
  }

  // Carrier flat area at world center
  const carrierFlatStart = baseX - 80;
  const carrierFlatEnd = baseX + BASE_WIDTH + 80;
  const carrierDeckY = waterLineY - 18; // deck sits above water
  for (let x = Math.max(0, carrierFlatStart - 40); x < Math.min(WORLD_W, carrierFlatEnd + 40); x++) {
    if (x >= carrierFlatStart && x <= carrierFlatEnd) {
      terrain[x] = carrierDeckY;
    } else if (x < carrierFlatStart) {
      const t = (carrierFlatStart - x) / 40;
      terrain[x] = carrierDeckY * (1 - t) + waterLineY * t;
    } else {
      const t = (x - carrierFlatEnd) / 40;
      terrain[x] = carrierDeckY * (1 - t) + waterLineY * t;
    }
  }

  // Barrier mountains at world edges
  addBarrierMountains(waterLineY - 60);
}

function addBarrierMountains(groundBase) {
  // Left barrier: tall mountain from x=0 to x=150
  const barrierHeight = 350; // very tall — reaches above screen
  const barrierWidth = 150;
  for (let x = 0; x < barrierWidth; x++) {
    const factor = Math.cos((x / barrierWidth) * Math.PI * 0.5);
    terrain[x] = Math.min(terrain[x], groundBase - barrierHeight * factor * factor);
  }
  // Right barrier: tall mountain from x=WORLD_W-150 to WORLD_W
  for (let x = WORLD_W - barrierWidth; x < WORLD_W; x++) {
    const dx = WORLD_W - x;
    const factor = Math.cos((dx / barrierWidth) * Math.PI * 0.5);
    terrain[x] = Math.min(terrain[x], groundBase - barrierHeight * factor * factor);
  }
}

function getTerrainY(x) {
  const ix = Math.floor(((x % WORLD_W) + WORLD_W) % WORLD_W);
  const ix2 = (ix + 1) % WORLD_W;
  const frac = x - Math.floor(x);
  return terrain[ix] * (1 - frac) + terrain[ix2] * frac;
}

// ── Base territory protection: no cratering within this zone ──
function isInBaseTerritory(x) {
  const margin = 80;
  if (x >= baseX - margin && x <= baseX + BASE_WIDTH + margin) return true;
  // Also protect enemy bases
  for (const eb of enemyBases) {
    if (x >= eb.x - margin && x <= eb.x + eb.width + margin) return true;
  }
  return false;
}

// ── Entities ──
let player, bullets, bombs, particles, enemies, buildings, flakShots, birds, oxen;
let fleeingPeople, dragons;

function initPlayer() {
  const ty = getTerrainY(baseX + BASE_WIDTH / 2);
  player = {
    x: baseX + BASE_WIDTH / 2,
    y: ty - 30,
    // Sopwith-style: single speed scalar + angle index
    speed: 0,             // current speed (in Sopwith units)
    accel: 0,             // throttle acceleration (0 to PLANE_MAX_ACCEL)
    angleIdx: 0,          // 0=right, 4=up, 8=left, 12=down (16 steps)
    orient: false,        // upside-down (true = inverted, like ob_orient in original Sopwith)
    stalled: false,       // in stall state
    // Derived velocity (for rendering/collision)
    vx: 0, vy: 0,
    fuel: MAX_FUEL,
    ammo: MAX_AMMO,
    bombCount: MAX_BOMBS,
    fireCooldown: 0,
    bombCooldown: 0,
    invincible: 0,
    landed: true,
    autopilot: false,
    hp: PLAYER_MAX_HP,
    burning: false,        // on fire or engine out, diving to crash
    engineOut: false,      // true = fuel empty (no fire), false = damage fire
    burnTimer: 0,          // time until explosion
    hitFlash: 0,           // visual flash on damage
    // Input edge detection
    _turnHeld: false,
    _turnTimer: 0,
    _autoHeld: false,
    // Frame counter for speed updates (every 4 frames like original)
    moveCount: 0
  };
}

function spawnBuildings() {
  buildings = [];
  const isSea = getLevelTheme(level) === 'sea';

  // Weighted type pool based on level and theme
  const pool = [];
  const addW = (t, w) => { for (let i = 0; i < w; i++) pool.push(t); };
  if (isSea) {
    // Sea levels: military outpost buildings only
    addW('bunker', 3); addW('flak', 3); addW('radar_station', 2); addW('fuel_depot', 2);
  } else {
    addW('hangar', 3); addW('factory', 3); addW('flak', 3);
    if (level >= 2) { addW('bunker', 2); addW('fuel_depot', 2); }
    if (level >= 3) { addW('radar_station', 1); addW('dam', 1); }
  }

  const sizeMap = {
    hangar: [50, 30], factory: [60, 40], flak: [30, 45],
    dam: [100, 25], radar_station: [40, 50], fuel_depot: [45, 30], bunker: [35, 20]
  };
  const hpMap = {
    hangar: 2, factory: 3, flak: 2, dam: 5, radar_station: 2, fuel_depot: 2, bunker: 4
  };

  const minGap = 300;
  const totalCount = 8 + level * 3;

  function placeBuilding(bx) {
    const ty = getTerrainY(bx);
    const type = pool[Math.floor(Math.random() * pool.length)];
    const [w, h] = sizeMap[type];
    buildings.push({
      x: bx, y: ty - h, w, h, type,
      hp: hpMap[type],
      alive: true,
      flakTimer: Math.random() * FLAK_INTERVAL | 0,
      isTarget: true
    });
    // Dam: dip terrain on left side (reservoir effect)
    if (type === 'dam') {
      for (let dx = -150; dx < 0; dx++) {
        const ix = Math.floor(((bx + dx) % WORLD_W + WORLD_W) % WORLD_W);
        if (ix >= 0 && ix < WORLD_W) {
          const factor = 1 - Math.abs(dx) / 150;
          terrain[ix] += 8 * factor;
        }
      }
    }
    return w;
  }

  if (isSea) {
    // Sea levels: place buildings only on islands
    let placed = 0;
    for (const island of islandPeaks) {
      if (placed >= totalCount) break;
      const islandLeft = island.cx - island.w / 2 + 40;
      const islandRight = island.cx + island.w / 2 - 40;
      const buildingsPerIsland = Math.ceil(totalCount / islandPeaks.length);
      let lastIX = islandLeft;
      for (let j = 0; j < buildingsPerIsland && placed < totalCount; j++) {
        const bx = lastIX + 60 + Math.random() * 80;
        if (bx >= islandRight) break;
        // Only place if terrain is above water (island surface)
        const ty = getTerrainY(bx);
        if (ty < waterLineY - 15) {
          const w = placeBuilding(bx);
          lastIX = bx + w;
          placed++;
        }
      }
    }
  } else {
    // Land levels: bidirectional placement
    const rightCount = Math.ceil(totalCount / 2);
    const leftCount = totalCount - rightCount;

    // Right set: starts right of base, goes rightward
    let lastX = baseX + BASE_WIDTH + 600;
    for (let i = 0; i < rightCount; i++) {
      const bx = lastX + minGap + Math.random() * 400;
      if (bx >= WORLD_W - 200) break;
      const w = placeBuilding(bx);
      lastX = bx + w;
    }

    // Left set: starts left of base, goes leftward
    lastX = baseX - 600;
    for (let i = 0; i < leftCount; i++) {
      const bx = lastX - minGap - Math.random() * 400;
      if (bx < 200) break;
      const w = placeBuilding(bx);
      lastX = bx - w;
    }
  }
}

// ── Enemy airfields ──
const ENEMY_MAX_FUEL = 600;
let enemyBases = []; // { x, width } — enemy landing fields

function spawnEnemyBases() {
  enemyBases = [];
  const isSea = getLevelTheme(level) === 'sea';

  // Always place enemy airfields at world edges — both land and sea levels
  const positions = [300, WORLD_W - 300 - BASE_WIDTH];
  for (const bx of positions) {
    // On sea levels, ensure there's solid ground (create an island) at edge positions
    if (isSea) {
      const centerX = bx + BASE_WIDTH / 2;
      const islandWidth = 300;
      for (let dx = -islandWidth / 2; dx <= islandWidth / 2; dx++) {
        const ix = Math.floor(((centerX + dx) % WORLD_W + WORLD_W) % WORLD_W);
        if (ix >= 0 && ix < WORLD_W) {
          const factor = Math.cos((dx / (islandWidth / 2)) * Math.PI * 0.5);
          terrain[ix] = waterLineY - 60 * factor * factor;
        }
      }
    }
    flattenTerrainForBase(bx);
    enemyBases.push({ x: bx, width: BASE_WIDTH });
  }
}

function flattenTerrainForBase(bx) {
  const flatY = getTerrainY(bx + BASE_WIDTH / 2);
  for (let x = bx - 80; x < bx + BASE_WIDTH + 80; x++) {
    if (x >= 0 && x < WORLD_W) {
      if (x >= bx && x <= bx + BASE_WIDTH) terrain[x] = flatY;
      else if (x < bx) {
        const t = (bx - x) / 80;
        terrain[x] = flatY * (1 - t) + terrain[x] * t;
      } else {
        const t = (x - bx - BASE_WIDTH) / 80;
        terrain[x] = flatY * (1 - t) + terrain[x] * t;
      }
    }
  }
}

function drawEnemyBases() {
  for (const eb of enemyBases) {
    const by = getTerrainY(eb.x + eb.width / 2);
    const facesRight = eb.x < WORLD_W / 2;
    neonGlow(ctx, '#f55', 4);
    ctx.strokeStyle = '#f55';
    ctx.lineWidth = 2;
    // Runway
    ctx.beginPath();
    ctx.moveTo(eb.x, by);
    ctx.lineTo(eb.x + eb.width, by);
    ctx.stroke();
    // Dashes
    ctx.strokeStyle = '#a22';
    ctx.lineWidth = 1;
    ctx.setLineDash([8, 8]);
    ctx.beginPath();
    ctx.moveTo(eb.x + 10, by - 3);
    ctx.lineTo(eb.x + eb.width - 10, by - 3);
    ctx.stroke();
    ctx.setLineDash([]);
    // Hangar — small building at the far end of the strip
    const hangarX = facesRight ? eb.x + eb.width + 8 : eb.x - 38;
    const hangarW = 30;
    const hangarH = 22;
    ctx.strokeStyle = '#a44';
    ctx.lineWidth = 1.5;
    // Hangar body
    ctx.strokeRect(hangarX, by - hangarH, hangarW, hangarH);
    // Arched roof
    ctx.beginPath();
    ctx.moveTo(hangarX, by - hangarH);
    ctx.quadraticCurveTo(hangarX + hangarW / 2, by - hangarH - 10, hangarX + hangarW, by - hangarH);
    ctx.stroke();
    // Door opening
    ctx.strokeStyle = '#822';
    ctx.lineWidth = 1;
    const doorX = facesRight ? hangarX : hangarX + hangarW - 14;
    ctx.strokeRect(doorX, by - 14, 14, 14);
    // Count planes in hangar for this base
    const hangarCount = enemies.filter(en => en.alive && en.homeBase === eb && en.state === 'hangar').length;
    if (hangarCount > 0) {
      ctx.fillStyle = '#f55';
      ctx.font = '7px "Courier New", monospace';
      ctx.textAlign = 'center';
      ctx.fillText(hangarCount + 'x', hangarX + hangarW / 2, by - hangarH - 12);
    }
    // Label
    ctx.fillStyle = '#f55';
    ctx.font = '8px "Courier New", monospace';
    ctx.textAlign = 'center';
    ctx.fillText('ENEMY', eb.x + eb.width / 2, by - 8);
    clearGlow(ctx);

    // ── Refueling progress bar for grounded enemies ──
    for (const en of enemies) {
      if (!en.alive || en.homeBase !== eb || en.state !== 'grounded') continue;
      if (!en.takeoffTimerMax || en.takeoffTimerMax <= 0) continue;
      const progress = 1 - (en.takeoffTimer / en.takeoffTimerMax);
      const barW = 40;
      const barH = 4;
      const barX = eb.x + eb.width / 2 - barW / 2;
      const barY = by - 20;
      // Background
      ctx.fillStyle = 'rgba(80, 0, 0, 0.6)';
      ctx.fillRect(barX, barY, barW, barH);
      // Fill — green when almost done, yellow mid, red starting
      const col = progress > 0.7 ? '#0f0' : progress > 0.35 ? '#ff0' : '#f44';
      ctx.fillStyle = col;
      ctx.fillRect(barX, barY, barW * Math.min(progress, 1), barH);
      // Border
      ctx.strokeStyle = '#f55';
      ctx.lineWidth = 0.5;
      ctx.strokeRect(barX, barY, barW, barH);
      // Label
      ctx.fillStyle = '#f88';
      ctx.font = '6px "Courier New", monospace';
      ctx.textAlign = 'center';
      ctx.fillText('REFUEL', eb.x + eb.width / 2, barY - 2);
    }
  }
}

function spawnEnemies() {
  enemies = [];
  spawnEnemyBases();
  const count = 3 + level + Math.floor(Math.random() * 2); // minimum 4 on level 1
  let zeppelinCount = 0;
  for (let i = 0; i < count; i++) {
    // Randomized type selection — all types can appear from level 1
    let type = 'biplane';
    const r = Math.random();
    if (r < 0.06 && zeppelinCount < 1) { type = 'zeppelin'; zeppelinCount++; }
    else if (r < 0.20) type = 'bomber';
    else if (r < 0.45) type = 'jet';

    const spec = ENEMY_SPECS[type];
    // Assign to an enemy base — alternate between bases
    const eb = enemyBases[i % enemyBases.length];
    const facesRight = eb.x < WORLD_W / 2;

    enemies.push({
      x: eb.x + BASE_WIDTH / 2, y: getTerrainY(eb.x + BASE_WIDTH / 2) - 8,
      vx: 0, vy: 0,
      angle: facesRight ? 0 : Math.PI,
      hp: spec.hp, alive: true,
      fireTimer: Math.random() * spec.fireInterval | 0,
      type,
      speed: spec.speed,
      stalled: false,
      stallTimer: 0,
      patrolDir: facesRight ? 1 : -1,
      parkSlot: i,
      // Airfield state
      fuel: ENEMY_MAX_FUEL,
      landed: true,
      homeBase: eb,
      takeoffTimer: 0,
      state: 'hangar' // hangar (hidden), grounded (on strip), flying, returning
    });
  }
  // Launch first wave — two planes per base
  launchNextFromBases();
}

// Keep 2 active planes per base — launch from hangar as needed
function launchNextFromBases() {
  const MAX_ACTIVE_PER_BASE = 2;
  for (const eb of enemyBases) {
    const activeCount = enemies.filter(en =>
      en.alive && en.homeBase === eb && (en.state === 'grounded' || en.state === 'flying' || en.state === 'returning')
    ).length;
    // Launch planes until we have 2 active (or run out of hangar planes)
    let toLaunch = MAX_ACTIVE_PER_BASE - activeCount;
    while (toLaunch > 0) {
      const next = enemies.find(en => en.alive && en.homeBase === eb && en.state === 'hangar');
      if (!next) break;
      next.state = 'grounded';
      // Bigger aircraft need longer refueling
      if (next.type === 'zeppelin') next.takeoffTimer = 6 + Math.random() * 3;
      else if (next.type === 'bomber') next.takeoffTimer = 4 + Math.random() * 2;
      else next.takeoffTimer = 1 + Math.random() * 2;
      next.takeoffTimerMax = next.takeoffTimer; // store for progress bar
      toLaunch--;
    }
  }
}

function spawnAnimals() {
  oxen = [];
  const count = 3 + level;
  for (let i = 0; i < count; i++) {
    const ax = 800 + Math.random() * (WORLD_W - 1000);
    const ty = getTerrainY(ax);
    // Pick animal type based on level
    let type = 'ox';
    const r = Math.random();
    if (level >= 3 && r < 0.15) type = 'camel';
    else if (level >= 2 && r < 0.35) type = 'horse';
    else if (r < 0.55) type = 'sheep';

    const sizeMap = { ox: [20, 10], sheep: [15, 7], horse: [22, 12], camel: [22, 11] };
    const speedMap = { ox: [15, 10], sheep: [25, 10], horse: [40, 10], camel: [12, 6] };
    const [w, h] = sizeMap[type];
    const [spd, spdR] = speedMap[type];

    if (type === 'sheep') {
      // Cluster sheep in groups of 3-4
      const groupSize = 3 + Math.floor(Math.random() * 2);
      for (let j = 0; j < groupSize; j++) {
        const sx = ax + j * 20 + Math.random() * 10;
        const sty = getTerrainY(sx);
        oxen.push({ x: sx, y: sty - h, w, h, alive: true, dir: Math.random() < 0.5 ? 1 : -1, speed: spd + Math.random() * spdR, type });
      }
    } else if (type === 'horse') {
      // Horses run in pairs
      for (let j = 0; j < 2; j++) {
        const hx = ax + j * 30;
        const hty = getTerrainY(hx);
        oxen.push({ x: hx, y: hty - h, w, h, alive: true, dir: Math.random() < 0.5 ? 1 : -1, speed: spd + Math.random() * spdR, type });
      }
    } else {
      oxen.push({ x: ax, y: ty - h, w, h, alive: true, dir: Math.random() < 0.5 ? 1 : -1, speed: spd + Math.random() * spdR, type: type || 'ox' });
    }
  }
}

function spawnBirds() {
  birds = [];
  const count = 2 + level;
  for (let i = 0; i < count; i++) {
    const bx = Math.random() * WORLD_W;
    // Type selection: 50% sparrows, 30% geese, 20% eagles
    const r = Math.random();
    let type = 'sparrow';
    if (r > 0.80) type = 'eagle';
    else if (r > 0.50) type = 'goose';

    const flock = [];
    if (type === 'eagle') {
      // Solitary, higher altitude, wider sinusoidal
      const by = 40 + Math.random() * 120;
      flock.push({ x: bx, y: by, alive: true });
      birds.push({ flock, vx: -25 - Math.random() * 15, vy: 0, type, sinAmp: 30 + Math.random() * 20, sinFreq: 0.002 });
    } else if (type === 'goose') {
      // V-formation
      const by = 80 + Math.random() * 150;
      for (let j = 0; j < 5; j++) {
        const offX = j * 14;
        const offY = Math.abs(j - 2) * 8; // V shape
        flock.push({ x: bx + offX, y: by + offY, alive: true });
      }
      birds.push({ flock, vx: -30 - Math.random() * 20, vy: Math.sin(bx) * 3, type, sinAmp: 5, sinFreq: 0.005 });
    } else {
      // Sparrows - small, fast
      const by = 60 + Math.random() * 200;
      for (let j = 0; j < 5; j++) {
        flock.push({ x: bx + j * 12 + Math.random() * 8, y: by + Math.sin(j) * 10, alive: true });
      }
      birds.push({ flock, vx: -40 - Math.random() * 30, vy: Math.sin(bx) * 5, type, sinAmp: 4, sinFreq: 0.01 });
    }
  }
}

function initLevel() {
  generateTerrain();
  initPlayer();
  bullets = [];
  bombs = [];
  particles = [];
  flakShots = [];
  fleeingPeople = [];
  dragons = [];
  submarines = [];
  parachutes = [];
  enemyAccuracyDebuff = 0;
  spawnBuildings();
  spawnEnemies();
  if (getLevelTheme(level) === 'land') {
    spawnAnimals();
  } else {
    oxen = []; // no ground animals on sea levels
    spawnSubmarines();
  }
  spawnBirds();
  spawnDragons();
}

// ── Particle system ──
function addParticle(x, y, vx, vy, life, color, size) {
  particles.push({ x, y, vx, vy, life, maxLife: life, color, size: size || 2 });
}

function addExplosion(x, y, count, big) {
  for (let i = 0; i < count; i++) {
    const a = Math.random() * Math.PI * 2;
    const sp = (big ? 150 : 80) * Math.random();
    const colors = ['#ff0','#fa0','#f60','#fff','#ff8'];
    addParticle(x, y, Math.cos(a) * sp, Math.sin(a) * sp - 20, 0.4 + Math.random() * 0.4, colors[Math.floor(Math.random() * colors.length)], 2 + Math.random() * (big ? 4 : 2));
  }
}

function addEngineTrail(x, y, vx, vy) {
  addParticle(x, y, vx * 0.1 + (Math.random() - 0.5) * 20, vy * 0.1 + (Math.random() - 0.5) * 20, 0.2 + Math.random() * 0.15, Math.random() < 0.5 ? '#0af' : '#08f', 1.5);
}

// ── Dragon spawning ──
function spawnDragons() {
  if (level >= 2 && Math.random() < 0.6) {
    const dx = 3000 + Math.random() * (WORLD_W - 4000);
    dragons.push({
      x: dx, y: 100 + Math.random() * 100,
      vx: 60, vy: 0,
      hp: 4, alive: true,
      phase: 'circling', // circling, diving, breathing
      breathTimer: 5 + Math.random() * 5,
      wingFrame: 0,
      diveTarget: null,
      breathParticles: []
    });
  }
}

// ── Fleeing people spawning ──
function spawnFleeingPeople(x, groundY) {
  const count = 2 + Math.floor(Math.random() * 3);
  const colors = ['#0ff', '#f0f', '#ff0', '#0f0', '#fa0', '#f55'];
  for (let i = 0; i < count; i++) {
    fleeingPeople.push({
      x: x + (Math.random() - 0.5) * 30,
      y: groundY,
      dir: Math.random() < 0.5 ? -1 : 1,
      speed: 40 + Math.random() * 20,
      life: 4 + Math.random(),
      maxLife: 5,
      frame: Math.random() * Math.PI * 2,
      color: colors[Math.floor(Math.random() * colors.length)]
    });
  }
}

// ── Building destruction special effects ──
function onBuildingDestroyed(bld) {
  // Spawn fleeing people (except bunker, and not on sea levels — military outposts)
  if (bld.type !== 'bunker' && getLevelTheme(level) !== 'sea') {
    spawnFleeingPeople(bld.x + bld.w / 2, bld.y + bld.h);
  }

  // Type-specific effects
  if (bld.type === 'dam') {
    // Flood effect: blue particles rushing rightward
    for (let i = 0; i < 40; i++) {
      addParticle(bld.x + bld.w / 2 + Math.random() * 40, bld.y + bld.h,
        80 + Math.random() * 120, -20 + Math.random() * 40,
        1.0 + Math.random() * 0.5, Math.random() < 0.5 ? '#48f' : '#0af', 3 + Math.random() * 2);
    }
    // Lower terrain downstream ~300px (skip in base territory)
    for (let dx = 0; dx < 300; dx++) {
      const worldX = bld.x + bld.w + dx;
      if (isInBaseTerritory(worldX)) continue;
      const ix = Math.floor(((worldX % WORLD_W) + WORLD_W) % WORLD_W);
      if (ix >= 0 && ix < WORLD_W) {
        const factor = 1 - dx / 300;
        terrain[ix] += (5 + Math.random() * 10) * factor;
      }
    }
    playFlood();
  } else if (bld.type === 'fuel_depot') {
    // Chain explosion: massive explosion + damage nearby buildings
    addExplosion(bld.x + bld.w / 2, bld.y + bld.h / 2, 60, true);
    for (const other of buildings) {
      if (!other.alive || other === bld) continue;
      const dist = Math.abs((other.x + other.w / 2) - (bld.x + bld.w / 2));
      if (dist < 150) {
        other.hp -= 2;
        if (other.hp <= 0) {
          other.alive = false;
          addExplosion(other.x + other.w / 2, other.y + other.h / 2, 20, true);
          score += buildingScores[other.type] || 100;
          if (other.type !== 'bunker') spawnFleeingPeople(other.x + other.w / 2, other.y + other.h);
        }
      }
    }
  } else if (bld.type === 'radar_station') {
    enemyAccuracyDebuff = 15; // 15 seconds of doubled enemy fire intervals
  }
}

// ── Drawing helpers ──
function neonGlow(ctx, color, blur) {
  ctx.shadowColor = color;
  ctx.shadowBlur = blur;
}
function clearGlow(ctx) {
  ctx.shadowColor = 'transparent';
  ctx.shadowBlur = 0;
}

function drawBiplane(ctx, x, y, angle, facingLeft, color, scale, upsideDown) {
  scale = scale || 1;
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(angle);
  if (facingLeft) ctx.scale(-1, 1);
  if (upsideDown) ctx.scale(1, -1);
  ctx.scale(scale, scale);

  neonGlow(ctx, color, 8);
  ctx.strokeStyle = color;
  ctx.lineWidth = 1.5;

  // ── Fuselage (centered on y=0, nose right) ──
  // Rounded body shape, wider at cockpit
  ctx.beginPath();
  ctx.moveTo(-20, 1);         // tail bottom
  ctx.lineTo(-8, 2);          // rear bottom
  ctx.lineTo(12, 2);          // belly
  ctx.lineTo(20, 0);          // nose tip
  ctx.lineTo(12, -3);         // nose top
  ctx.lineTo(-8, -3);         // cockpit top
  ctx.lineTo(-20, -1);        // tail top
  ctx.closePath();
  ctx.stroke();

  // ── Cockpit canopy ──
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(0, -3);
  ctx.quadraticCurveTo(2, -6, 6, -3);
  ctx.stroke();

  // ── Top wing (above fuselage) ──
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(-10, -7);
  ctx.lineTo(12, -7);
  ctx.lineTo(14, -6);
  ctx.lineTo(-10, -6);
  ctx.closePath();
  ctx.stroke();

  // ── Bottom wing (below fuselage) ──
  ctx.beginPath();
  ctx.moveTo(-8, 4);
  ctx.lineTo(12, 4);
  ctx.lineTo(14, 5);
  ctx.lineTo(-8, 5);
  ctx.closePath();
  ctx.stroke();

  // ── Wing struts ──
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(-2, -7);
  ctx.lineTo(-2, 5);
  ctx.moveTo(8, -7);
  ctx.lineTo(8, 5);
  ctx.stroke();

  // ── Tail fin (vertical stabilizer, points UP) ──
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(-20, -1);
  ctx.lineTo(-24, -7);
  ctx.lineTo(-18, -7);
  ctx.lineTo(-16, -3);
  ctx.stroke();

  // ── Tail plane (horizontal stabilizer) ──
  ctx.beginPath();
  ctx.moveTo(-22, 0);
  ctx.lineTo(-26, -1);
  ctx.lineTo(-26, 1);
  ctx.lineTo(-22, 1);
  ctx.stroke();

  // ── Landing gear (two small struts + wheels) ──
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(0, 5);
  ctx.lineTo(-1, 9);
  ctx.moveTo(8, 5);
  ctx.lineTo(7, 9);
  // Axle
  ctx.moveTo(-2, 9);
  ctx.lineTo(8, 9);
  ctx.stroke();
  // Wheels
  ctx.beginPath();
  ctx.arc(-1, 10, 1.5, 0, Math.PI * 2);
  ctx.stroke();
  ctx.beginPath();
  ctx.arc(7, 10, 1.5, 0, Math.PI * 2);
  ctx.stroke();

  // ── Propeller (spinning) ──
  ctx.lineWidth = 2;
  ctx.strokeStyle = color;
  const pt = Date.now() * 0.03;
  const pLen = 7;
  ctx.beginPath();
  ctx.moveTo(20, -pLen * Math.sin(pt));
  ctx.lineTo(20, pLen * Math.sin(pt));
  ctx.stroke();

  // ── Engine cowling (nose cap) ──
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(18, -3);
  ctx.lineTo(18, 2);
  ctx.stroke();

  clearGlow(ctx);
  ctx.restore();
}

function drawJet(ctx, x, y, angle, facingLeft, color, scale) {
  scale = scale || 1;
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(angle);
  if (facingLeft) ctx.scale(-1, 1);
  ctx.scale(scale, scale);

  neonGlow(ctx, color, 8);
  ctx.strokeStyle = color;
  ctx.lineWidth = 1.5;

  // Pointed triangular fuselage
  ctx.beginPath();
  ctx.moveTo(22, 0);          // nose tip
  ctx.lineTo(-14, -4);        // top rear
  ctx.lineTo(-18, -3);        // tail notch top
  ctx.lineTo(-18, 3);         // tail notch bottom
  ctx.lineTo(-14, 4);         // bottom rear
  ctx.closePath();
  ctx.stroke();

  // Swept-back delta wings
  ctx.beginPath();
  ctx.moveTo(-2, -4);
  ctx.lineTo(-14, -14);
  ctx.lineTo(-10, -4);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(-2, 4);
  ctx.lineTo(-14, 14);
  ctx.lineTo(-10, 4);
  ctx.stroke();

  // Bubble canopy
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(8, -3);
  ctx.quadraticCurveTo(12, -6, 16, -3);
  ctx.stroke();

  // Vertical tail fin
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(-16, -3);
  ctx.lineTo(-20, -10);
  ctx.lineTo(-14, -8);
  ctx.stroke();

  // Afterburner glow (pulsing)
  const abPulse = 0.5 + 0.5 * Math.sin(Date.now() * 0.02);
  ctx.fillStyle = `rgba(255, ${Math.floor(160 * abPulse)}, 0, ${0.5 + abPulse * 0.5})`;
  ctx.beginPath();
  ctx.arc(-20, 0, 3 + abPulse * 2, 0, Math.PI * 2);
  ctx.fill();

  clearGlow(ctx);
  ctx.restore();
}

function drawBomber(ctx, x, y, angle, facingLeft, color, scale) {
  scale = scale || 1;
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(angle);
  if (facingLeft) ctx.scale(-1, 1);
  ctx.scale(scale, scale);

  neonGlow(ctx, color, 8);
  ctx.strokeStyle = color;
  ctx.lineWidth = 1.5;

  // Wider fuselage
  ctx.beginPath();
  ctx.moveTo(-22, 2);
  ctx.lineTo(-10, 4);
  ctx.lineTo(18, 3);
  ctx.lineTo(24, 0);
  ctx.lineTo(18, -4);
  ctx.lineTo(-10, -4);
  ctx.lineTo(-22, -2);
  ctx.closePath();
  ctx.stroke();

  // Long straight wings
  ctx.beginPath();
  ctx.moveTo(-12, -4);
  ctx.lineTo(14, -4);
  ctx.lineTo(16, -5);
  ctx.lineTo(-12, -5);
  ctx.closePath();
  ctx.stroke();
  // Wing extension (wider span)
  ctx.beginPath();
  ctx.moveTo(-8, -5); ctx.lineTo(-8, -16);
  ctx.moveTo(8, -5); ctx.lineTo(8, -16);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(-8, 4); ctx.lineTo(-8, 16);
  ctx.moveTo(8, 4); ctx.lineTo(8, 16);
  ctx.stroke();

  // Engine nacelles (rectangles under wings)
  ctx.strokeRect(-4, -18, 6, 4);
  ctx.strokeRect(-4, 14, 6, 4);

  // Twin tail fins
  ctx.beginPath();
  ctx.moveTo(-20, -2);
  ctx.lineTo(-24, -8);
  ctx.lineTo(-18, -6);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(-20, 2);
  ctx.lineTo(-24, 8);
  ctx.lineTo(-18, 6);
  ctx.stroke();

  // Bomb bay doors (dashed line underneath)
  ctx.lineWidth = 1;
  ctx.setLineDash([3, 3]);
  ctx.beginPath();
  ctx.moveTo(-6, 4);
  ctx.lineTo(10, 4);
  ctx.stroke();
  ctx.setLineDash([]);

  // ── Defensive turret guns (top and bottom) ──
  ctx.lineWidth = 1.5;
  // Top turret (dorsal) — bubble + gun barrel
  ctx.strokeStyle = color;
  ctx.beginPath();
  ctx.arc(2, -6, 3, 0, Math.PI * 2);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(2, -6);
  ctx.lineTo(2 + 7, -6 - 4);
  ctx.stroke();
  // Bottom turret (ventral) — bubble + gun barrel
  ctx.beginPath();
  ctx.arc(2, 6, 3, 0, Math.PI * 2);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(2, 6);
  ctx.lineTo(2 + 7, 6 + 4);
  ctx.stroke();

  // Two spinning propellers
  ctx.lineWidth = 2;
  const pt = Date.now() * 0.03;
  const pLen = 5;
  ctx.beginPath();
  ctx.moveTo(-1, -18 - pLen * Math.sin(pt));
  ctx.lineTo(-1, -18 + pLen * Math.sin(pt));
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(-1, 18 - pLen * Math.sin(pt + 1));
  ctx.lineTo(-1, 18 + pLen * Math.sin(pt + 1));
  ctx.stroke();

  clearGlow(ctx);
  ctx.restore();
}

function drawZeppelin(ctx, x, y, angle, facingLeft, color, scale) {
  scale = scale || 1;
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(angle);
  if (facingLeft) ctx.scale(-1, 1);
  ctx.scale(scale, scale);

  neonGlow(ctx, color, 8);
  ctx.strokeStyle = color;
  ctx.lineWidth = 1.5;

  // Large elongated ellipse (envelope)
  ctx.beginPath();
  ctx.ellipse(0, 0, 40, 10, 0, 0, Math.PI * 2);
  ctx.stroke();

  // Internal frame lines
  for (let fx = -20; fx <= 20; fx += 13) {
    ctx.beginPath();
    ctx.moveTo(fx, -9);
    ctx.lineTo(fx, 9);
    ctx.stroke();
  }

  // Gondola rectangle hanging below
  ctx.strokeRect(-8, 12, 16, 6);
  // Connection lines
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(-6, 10); ctx.lineTo(-8, 12);
  ctx.moveTo(6, 10); ctx.lineTo(8, 12);
  ctx.stroke();

  // Cross-shaped rear stabilizer fins
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(-38, 0); ctx.lineTo(-46, -8);
  ctx.moveTo(-38, 0); ctx.lineTo(-46, 8);
  ctx.moveTo(-38, -5); ctx.lineTo(-46, 0);
  ctx.moveTo(-38, 5); ctx.lineTo(-46, 0);
  ctx.stroke();

  clearGlow(ctx);
  ctx.restore();
}

function drawDragon(ctx, dragon) {
  const d = dragon;
  ctx.save();
  ctx.translate(d.x, d.y);

  const wingFlap = Math.sin(d.wingFrame) * 0.5;
  const bodyUndulate = Math.sin(d.wingFrame * 0.6) * 3;
  const facingLeft = d.vx < 0;
  if (facingLeft) ctx.scale(-1, 1);

  neonGlow(ctx, '#f40', 12);

  // Serpentine body (thick, muscular)
  ctx.strokeStyle = '#f40';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(-30, 0);
  ctx.bezierCurveTo(-18, -6 + bodyUndulate, -4, 6 - bodyUndulate, 12, 0);
  ctx.bezierCurveTo(20, -2 + bodyUndulate * 0.5, 30, 1, 38, 3);
  ctx.stroke();

  // Belly underside (lighter)
  ctx.strokeStyle = '#fa6';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(-28, 2);
  ctx.bezierCurveTo(-16, 5, -2, 4, 14, 2);
  ctx.stroke();

  // Scales along back
  ctx.strokeStyle = '#d30';
  ctx.lineWidth = 1;
  for (let s = -20; s < 15; s += 6) {
    const sy = -4 + Math.sin((s + d.wingFrame * 3) * 0.15) * 2;
    ctx.beginPath();
    ctx.moveTo(s, sy);
    ctx.lineTo(s + 3, sy - 3);
    ctx.lineTo(s + 6, sy);
    ctx.stroke();
  }

  // Head — larger with horns, jaw, and crest
  ctx.strokeStyle = '#f40';
  ctx.lineWidth = 2.5;
  // Skull shape
  ctx.beginPath();
  ctx.moveTo(-30, 0);
  ctx.lineTo(-36, -4);
  ctx.lineTo(-40, -2);  // snout
  ctx.lineTo(-38, 1);
  ctx.lineTo(-34, 4);   // lower jaw
  ctx.lineTo(-30, 1);
  ctx.stroke();
  // Upper jaw teeth
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(-38, -1); ctx.lineTo(-37, 1);
  ctx.moveTo(-36, -2); ctx.lineTo(-35, 0);
  ctx.moveTo(-34, -2); ctx.lineTo(-33, 0);
  ctx.stroke();
  // Horns (two large curved)
  ctx.strokeStyle = '#fa0';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(-28, -3);
  ctx.quadraticCurveTo(-26, -12, -22, -14);
  ctx.moveTo(-24, -4);
  ctx.quadraticCurveTo(-22, -11, -18, -12);
  ctx.stroke();
  // Eye (glowing)
  ctx.fillStyle = '#ff0';
  neonGlow(ctx, '#ff0', 6);
  ctx.beginPath();
  ctx.arc(-33, -2, 2, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#f00';
  ctx.beginPath();
  ctx.arc(-33, -2, 0.8, 0, Math.PI * 2);
  ctx.fill();

  // Wings — large bat-like with membrane and claws
  neonGlow(ctx, '#f40', 10);
  ctx.strokeStyle = '#f40';
  ctx.lineWidth = 2;
  const wUp = wingFlap * 25;
  // Main wing frame
  ctx.beginPath();
  ctx.moveTo(-8, -3);
  ctx.lineTo(-20, -25 + wUp);
  ctx.lineTo(-5, -18 + wUp * 0.7);
  ctx.lineTo(8, -28 + wUp);
  ctx.lineTo(15, -12 + wUp * 0.5);
  ctx.lineTo(12, -3);
  ctx.stroke();
  // Wing membrane
  ctx.strokeStyle = '#d30';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(-14, -3);
  ctx.lineTo(-18, -22 + wUp);
  ctx.moveTo(-2, -3);
  ctx.lineTo(-8, -20 + wUp * 0.8);
  ctx.moveTo(5, -3);
  ctx.lineTo(4, -22 + wUp * 0.7);
  ctx.moveTo(10, -3);
  ctx.lineTo(12, -16 + wUp * 0.5);
  ctx.stroke();
  // Wing claws
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(-20, -25 + wUp); ctx.lineTo(-22, -27 + wUp);
  ctx.moveTo(8, -28 + wUp); ctx.lineTo(9, -30 + wUp);
  ctx.stroke();

  // Tail — long, spiked, sinuous
  ctx.strokeStyle = '#f40';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(38, 3);
  ctx.quadraticCurveTo(46, 8 + bodyUndulate, 52, 4 - bodyUndulate);
  ctx.quadraticCurveTo(58, 0 + bodyUndulate, 62, 3);
  ctx.stroke();
  // Tail spikes
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(48, 5); ctx.lineTo(50, -1);
  ctx.moveTo(54, 3); ctx.lineTo(56, -2);
  ctx.moveTo(60, 3); ctx.lineTo(63, -1);
  ctx.stroke();
  // Tail tip (arrow/spade)
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(62, 3);
  ctx.lineTo(68, 0);
  ctx.lineTo(65, 3);
  ctx.lineTo(68, 6);
  ctx.lineTo(62, 3);
  ctx.stroke();

  // Legs (small, tucked)
  ctx.strokeStyle = '#d30';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(-5, 3); ctx.lineTo(-8, 10); ctx.lineTo(-5, 10);
  ctx.moveTo(8, 3); ctx.lineTo(5, 10); ctx.lineTo(8, 10);
  ctx.stroke();

  // Fire breath when in breathing phase
  if (d.phase === 'breathing') {
    neonGlow(ctx, '#f80', 15);
    for (let i = 0; i < 8; i++) {
      const fx = -40 - i * 5 - Math.random() * 4;
      const fy = (Math.random() - 0.5) * (5 + i * 3);
      const r = 2 + Math.random() * 2;
      const colors = ['#ff0', '#f80', '#f40', '#f22'];
      ctx.fillStyle = colors[i % colors.length];
      ctx.globalAlpha = 0.8 - i * 0.08;
      ctx.beginPath();
      ctx.arc(fx, fy, r, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;
  }

  clearGlow(ctx);
  ctx.restore();
}

function drawPerson(person) {
  const p = person;
  const alpha = p.life < 1 ? p.life : 1;
  ctx.globalAlpha = alpha;
  neonGlow(ctx, p.color, 4);
  ctx.strokeStyle = p.color;
  ctx.lineWidth = 1;

  const legAnim = Math.sin(p.frame * 8) * 3;
  const armAnim = Math.sin(p.frame * 6) * 2;

  // Head
  ctx.beginPath();
  ctx.arc(p.x, p.y - 7, 1.5, 0, Math.PI * 2);
  ctx.stroke();
  // Body
  ctx.beginPath();
  ctx.moveTo(p.x, p.y - 5.5);
  ctx.lineTo(p.x, p.y - 2);
  ctx.stroke();
  // Arms (waving)
  ctx.beginPath();
  ctx.moveTo(p.x - 2 - armAnim, p.y - 5);
  ctx.lineTo(p.x, p.y - 4);
  ctx.lineTo(p.x + 2 + armAnim, p.y - 5);
  ctx.stroke();
  // Legs (running)
  ctx.beginPath();
  ctx.moveTo(p.x - 1.5 - legAnim, p.y);
  ctx.lineTo(p.x, p.y - 2);
  ctx.lineTo(p.x + 1.5 + legAnim, p.y);
  ctx.stroke();

  clearGlow(ctx);
  ctx.globalAlpha = 1;
}

function drawAnimal(animal) {
  const o = animal;
  const type = o.type || 'ox';
  if (type === 'ox') {
    drawOx(o);
    return;
  }

  if (type === 'sheep') {
    neonGlow(ctx, '#ddd', 6);
    ctx.strokeStyle = '#ddd';
    ctx.lineWidth = 1.5;
    // Fluffy body (rounded rect with wavy top)
    ctx.beginPath();
    ctx.moveTo(o.x + 2, o.y + 2);
    ctx.lineTo(o.x + 13, o.y + 2);
    ctx.lineTo(o.x + 13, o.y + 6);
    ctx.lineTo(o.x + 2, o.y + 6);
    ctx.closePath();
    ctx.stroke();
    // Wavy top (fluffy)
    ctx.beginPath();
    ctx.moveTo(o.x + 2, o.y + 2);
    for (let wx = 3; wx < 13; wx += 2) {
      ctx.lineTo(o.x + wx, o.y + 2 - Math.sin(wx) * 1.5);
    }
    ctx.stroke();
    // Legs
    ctx.beginPath();
    ctx.moveTo(o.x + 4, o.y + 6); ctx.lineTo(o.x + 4, o.y + 8);
    ctx.moveTo(o.x + 11, o.y + 6); ctx.lineTo(o.x + 11, o.y + 8);
    ctx.stroke();
    // Head
    const headX = o.dir > 0 ? o.x + 13 : o.x + 2;
    ctx.beginPath();
    ctx.arc(headX, o.y + 2, 2, 0, Math.PI * 2);
    ctx.stroke();
    clearGlow(ctx);
  } else if (type === 'horse') {
    neonGlow(ctx, '#a72', 6);
    ctx.strokeStyle = '#a72';
    ctx.lineWidth = 1.5;
    // Body
    ctx.strokeRect(o.x + 3, o.y + 2, 16, 6);
    // Taller legs
    ctx.beginPath();
    ctx.moveTo(o.x + 5, o.y + 8); ctx.lineTo(o.x + 5, o.y + 12);
    ctx.moveTo(o.x + 8, o.y + 8); ctx.lineTo(o.x + 8, o.y + 12);
    ctx.moveTo(o.x + 15, o.y + 8); ctx.lineTo(o.x + 15, o.y + 12);
    ctx.moveTo(o.x + 18, o.y + 8); ctx.lineTo(o.x + 18, o.y + 12);
    ctx.stroke();
    // Longer neck and head
    const headX = o.dir > 0 ? o.x + 19 : o.x + 3;
    const neckDir = o.dir > 0 ? 1 : -1;
    ctx.beginPath();
    ctx.moveTo(headX, o.y + 2);
    ctx.lineTo(headX + neckDir * 3, o.y - 3);
    ctx.lineTo(headX + neckDir * 7, o.y - 3);
    ctx.lineTo(headX + neckDir * 7, o.y);
    ctx.stroke();
    // Mane
    ctx.beginPath();
    ctx.moveTo(headX + neckDir * 1, o.y);
    ctx.lineTo(headX + neckDir * 4, o.y - 5);
    ctx.stroke();
    // Tail
    const tailX = o.dir > 0 ? o.x + 3 : o.x + 19;
    ctx.beginPath();
    ctx.moveTo(tailX, o.y + 2);
    ctx.quadraticCurveTo(tailX - neckDir * 5, o.y, tailX - neckDir * 4, o.y + 5);
    ctx.stroke();
    clearGlow(ctx);
  } else if (type === 'camel') {
    neonGlow(ctx, '#da8', 6);
    ctx.strokeStyle = '#da8';
    ctx.lineWidth = 1.5;
    // Body
    ctx.strokeRect(o.x + 3, o.y + 2, 16, 5);
    // Humps (1-2 arcs on back)
    ctx.beginPath();
    ctx.arc(o.x + 8, o.y + 2, 3, Math.PI, 0);
    ctx.arc(o.x + 15, o.y + 2, 2.5, Math.PI, 0);
    ctx.stroke();
    // Longer legs
    ctx.beginPath();
    ctx.moveTo(o.x + 5, o.y + 7); ctx.lineTo(o.x + 5, o.y + 12);
    ctx.moveTo(o.x + 8, o.y + 7); ctx.lineTo(o.x + 8, o.y + 12);
    ctx.moveTo(o.x + 15, o.y + 7); ctx.lineTo(o.x + 15, o.y + 12);
    ctx.moveTo(o.x + 18, o.y + 7); ctx.lineTo(o.x + 18, o.y + 12);
    ctx.stroke();
    // Long neck
    const headX = o.dir > 0 ? o.x + 19 : o.x + 3;
    const neckDir = o.dir > 0 ? 1 : -1;
    ctx.beginPath();
    ctx.moveTo(headX, o.y + 2);
    ctx.lineTo(headX + neckDir * 2, o.y - 5);
    ctx.lineTo(headX + neckDir * 5, o.y - 5);
    ctx.stroke();
    // Head
    ctx.beginPath();
    ctx.arc(headX + neckDir * 5, o.y - 5, 2, 0, Math.PI * 2);
    ctx.stroke();
    clearGlow(ctx);
  }
}

// ── Camera ──
let camX = 0, camY = 0;

function updateCamera() {
  const targetX = player.x - canvas.width * 0.35;
  const targetY = player.y - canvas.height * 0.45;
  camX += (targetX - camX) * 0.08;
  camY += (targetY - camY) * 0.06;
  // Clamp vertical
  camY = Math.max(-100, Math.min(camY, 400));
}

// ── Update logic ──
let lastTime = 0;
let frameCount = 0;

function update(dt) {
  frameCount++;
  if (state === ST.PLAYING) {
    if (enemyAccuracyDebuff > 0) enemyAccuracyDebuff -= dt;
    updatePlayer(dt);
    updateBullets(dt);
    updateBombs(dt);
    updateEnemies(dt);
    updateFlak(dt);
    updateBirds(dt);
    updateOxen(dt);
    updateFleeingPeople(dt);
    updateDragons(dt);
    updateSubmarines(dt);
    // Player crashes into buildings — both destroyed
    if (!player.landed && !player.burning && player.invincible <= 0) {
      for (const bld of buildings) {
        if (!bld.alive) continue;
        if (player.x > bld.x - 10 && player.x < bld.x + bld.w + 10 &&
            player.y > bld.y - 5 && player.y < bld.y + bld.h + 5) {
          bld.alive = false;
          addExplosion(bld.x + bld.w / 2, bld.y + bld.h / 2, 35, true);
          playBoom(true);
          score += buildingScores[bld.type] || 100;
          onBuildingDestroyed(bld);
          damagePlayer(3); // devastating crash
          break;
        }
      }
    }
    updateParachutes(dt);
    updateParticles(dt);
    updateCamera();
    checkLevelComplete();
    updateHUD();
  } else if (state === ST.DYING) {
    updateParachutes(dt);
    updateParticles(dt);
    deathTimer -= dt;
    if (deathTimer <= 0) {
      if (lives <= 0) {
        state = ST.GAME_OVER;
      } else {
        initPlayer();
        player.invincible = 3; // 3 seconds of invincibility after respawn
        // Clear hostile projectiles near spawn
        bullets = bullets.filter(b => b.friendly);
        bombs = bombs.filter(b => b.friendly !== false);
        flakShots = [];
        if (lives === 1) lastChanceMsg = 3; // show warning for 3 seconds
        state = ST.PLAYING;
      }
    }
  } else if (state === ST.LEVEL_COMPLETE) {
    updateParticles(dt);
    levelTimer -= dt;
    if (levelTimer <= 0) {
      level++;
      initLevel();
      state = ST.PLAYING;
    }
  }
}

// ── Angle helpers ──
// Angle indices: 0=right, 4=up, 8=left, 12=down (counterclockwise)
// "Nose up" = increment toward 4, "Nose down" = decrement toward 12 (via 0→15→14→13...)

function getEffectiveAngle(p) {
  // angleIdx directly determines direction via COS/SIN tables — no mirroring needed
  return p.angleIdx;
}

// Radian angle for canvas rendering (canvas: 0=right, positive=clockwise=down)
function getPlaneRadians(p) {
  const effAngle = getEffectiveAngle(p);
  // effAngle goes counterclockwise, canvas goes clockwise, so negate
  return -effAngle * ANGLE_STEP;
}

function updatePlayer(dt) {
  const p = player;
  p.moveCount++;

  // ── Autopilot: tractor beam guided landing ──
  if (p.autopilot) {
    const homeX = baseX + BASE_WIDTH / 2;
    const homeY = getTerrainY(homeX) - 8;
    const dx = homeX - p.x;
    const dy = homeY - p.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const CAPTURE_RADIUS = 400; // matches searchlight range

    // Too far — cancel autopilot so player retains control
    if (dist > CAPTURE_RADIUS) {
      p.autopilot = false;
    }
    // Within capture range: tractor beam pulls plane in
    else {
      p.orient = false;
      p.stalled = false;
      // Smoothly interpolate position toward the runway
      const lerpRate = 0.02 * (60 * dt);  // ~2% per frame at 60fps
      p.x += (homeX - p.x) * lerpRate;
      p.y += (homeY - p.y) * lerpRate;

      // Smoothly level the plane
      const targetAngle = dx > 0 ? 0 : 8;
      if (p.angleIdx !== targetAngle && p.moveCount % 3 === 0) {
        const diff = ((targetAngle - p.angleIdx) + NUM_ANGLES) % NUM_ANGLES;
        if (diff <= 8) p.angleIdx = (p.angleIdx + 1) % NUM_ANGLES;
        else p.angleIdx = ((p.angleIdx - 1) + NUM_ANGLES) % NUM_ANGLES;
      }

      // Reduce speed and zero velocity (beam controls position)
      p.speed = Math.max(0, p.speed - 0.5);
      p.accel = 0;
      p.vx = 0;
      p.vy = 0;

      // Timers still tick
      p.fireCooldown -= dt;
      p.bombCooldown -= dt;
      if (p.invincible > 0) p.invincible -= dt;
      p.fuel -= dt * 5; // minimal fuel use during beam approach
      if (p.fuel <= 0) p.fuel = 0;

      // Landing: close enough to runway
      const landDist = Math.sqrt((p.x - homeX) ** 2 + (p.y - homeY) ** 2);
      if (landDist < 15) {
        p.landed = true;
        p.autopilot = false;
        p.speed = 0; p.accel = 0; p.angleIdx = 0;
        p.vx = 0; p.vy = 0;
        p.x = homeX; p.y = homeY;
        p.fuel = MAX_FUEL; p.ammo = MAX_AMMO; p.bombCount = MAX_BOMBS;
      }
      return; // Skip normal physics — beam handles everything
    }
  }

  // ── Burning plane — uncontrollable dive to crash ──
  if (p.burning) {
    p.burnTimer -= dt;
    p.hitFlash -= dt;
    // Nose drops slowly toward ground
    if (p.moveCount % 8 === 0) {
      const diff = ((12 - p.angleIdx) + NUM_ANGLES) % NUM_ANGLES;
      if (diff > 0 && diff <= 8) p.angleIdx = (p.angleIdx + 1) % NUM_ANGLES;
      else if (diff > 8) p.angleIdx = ((p.angleIdx - 1) + NUM_ANGLES) % NUM_ANGLES;
    }
    p.accel = 0;
    if (p.engineOut) {
      // Engine out: light smoke only, no fire
      if (Math.random() < 0.15) {
        const rad = getPlaneRadians(p);
        addParticle(p.x - Math.cos(rad) * 15, p.y - Math.sin(rad) * 15,
          (Math.random() - 0.5) * 10, -10 - Math.random() * 10, 0.5, '#555', 2);
      }
    } else {
      // Fire/smoke particles trailing from engine
      const rad = getPlaneRadians(p);
      addParticle(p.x - Math.cos(rad) * 15, p.y - Math.sin(rad) * 15,
        (Math.random() - 0.5) * 30, -20 - Math.random() * 20, 0.4,
        Math.random() < 0.5 ? '#f80' : '#f44', 2 + Math.random());
      if (Math.random() < 0.3) {
        addParticle(p.x + (Math.random() - 0.5) * 10, p.y + (Math.random() - 0.5) * 10,
          (Math.random() - 0.5) * 15, -10 - Math.random() * 15, 0.6, '#333', 3);
      }
    }
    // Timer expired: final explosion
    if (p.burnTimer <= 0) {
      killPlayer();
      return;
    }
    // Don't process manual controls — plane is doomed
    // Fall through to physics below
  }

  // ── Autopilot toggle (H) — always available, not gated by autopilot state ──
  if (!p.burning) {
    if (keys['KeyH']) {
      if (!p._autoHeld) { p.autopilot = !p.autopilot; p._autoHeld = true; }
    } else { p._autoHeld = false; }

    // Cancel autopilot on any manual input (pitch, throttle, fire, bomb)
    if (p.autopilot && (keys['Comma'] || keys['Slash'] || keys['ArrowUp'] || keys['ArrowDown']
        || keys['KeyX'] || keys['Backslash'] || keys['Backquote'] || keys['Space'] || keys['KeyB'])) {
      p.autopilot = false;
    }
  }

  // ── Manual controls ──
  if (!p.autopilot && !p.burning) {
    // Accelerate (X or ArrowUp)
    if (keys['KeyX'] || keys['ArrowUp']) {
      if (p.accel < PLANE_MAX_ACCEL) p.accel++;
    }
    // Decelerate (Backslash)
    if (keys['Backslash'] || keys['Backquote']) {
      if (p.accel > 0) p.accel--;
    }

    // Pitch: when orient=false, nose-up increments angleIdx; when orient=true, it decrements (inverted)
    // This matches original Sopwith: if (ob->ob_orient) nangle -= update; else nangle += update;
    const pitchUp = p.orient ? -1 : 1;
    const pitchDown = p.orient ? 1 : -1;

    // Nose up (Comma or ArrowUp)
    if (keys['Comma'] || keys['ArrowUp']) {
      if (!p._turnHeld) {
        p.angleIdx = ((p.angleIdx + pitchUp) + NUM_ANGLES) % NUM_ANGLES;
        p._turnHeld = true;
        p._turnTimer = 0;
      } else {
        p._turnTimer++;
        if (p._turnTimer >= 10) {
          p.angleIdx = ((p.angleIdx + pitchUp) + NUM_ANGLES) % NUM_ANGLES;
          p._turnTimer = 0;
        }
      }
    }
    // Nose down (Slash or ArrowDown)
    else if (keys['Slash'] || keys['ArrowDown']) {
      if (!p._turnHeld) {
        p.angleIdx = ((p.angleIdx + pitchDown) + NUM_ANGLES) % NUM_ANGLES;
        p._turnHeld = true;
        p._turnTimer = 0;
      } else {
        p._turnTimer++;
        if (p._turnTimer >= 10) {
          p.angleIdx = ((p.angleIdx + pitchDown) + NUM_ANGLES) % NUM_ANGLES;
          p._turnTimer = 0;
        }
      }
    } else {
      p._turnHeld = false;
      p._turnTimer = 0;
    }

    // Fire
    if (keys['Space'] && p.fireCooldown <= 0 && p.ammo > 0) {
      const rad = getPlaneRadians(p);
      const bx = p.x + Math.cos(rad) * 25;
      const by = p.y + Math.sin(rad) * 25;
      const bvx = Math.cos(rad) * BULLET_SPEED + p.vx * 0.3;
      const bvy = Math.sin(rad) * BULLET_SPEED + p.vy * 0.3;
      bullets.push({ x: bx, y: by, vx: bvx, vy: bvy, life: 1.2, friendly: true });
      p.ammo--;
      p.fireCooldown = 0.08;
      playShoot();
    }

    // Bomb
    if (keys['KeyB'] && p.bombCooldown <= 0 && p.bombCount > 0) {
      bombs.push({ x: p.x, y: p.y + 5, vx: p.vx * BOMB_VXFRAC, vy: p.vy + 20, life: 5, friendly: true });
      p.bombCount--;
      p.bombCooldown = 0.4;
      playBombDrop();
    }
  }

  p.fireCooldown -= dt;
  p.bombCooldown -= dt;
  if (p.invincible > 0) p.invincible -= dt;
  if (p.hitFlash > 0) p.hitFlash -= dt;

  // ── Sopwith-style physics ──
  if (!p.landed) {
    const effAngle = getEffectiveAngle(p);

    // Speed update every 4 frames (gradual, prevents sudden speed loss)
    if (p.moveCount % 4 === 0) {
      const grav = GRAVITY_TABLE[effAngle];
      const targetSpeed = PLANE_MIN_SPEED + p.accel + grav;
      if (p.speed < targetSpeed) p.speed++;
      else if (p.speed > targetSpeed) p.speed--;
      if (p.speed > PLANE_MAX_SPEED) p.speed = PLANE_MAX_SPEED;
    }

    // With throttle applied, never drop below minimum flight speed (checked every frame)
    if (p.accel > 0 && p.speed < PLANE_MIN_SPEED) p.speed = PLANE_MIN_SPEED;

    // Stall: speed too low (only in normal flight, not when burning, not with throttle)
    if (p.speed <= STALL_SPEED && !p.stalled && !p.burning && p.accel === 0) {
      p.stalled = true;
    }

    if (p.stalled) {
      // Nose drops toward "down" (angleIdx 12 = straight down)
      if (p.moveCount % 8 === 0) {
        if (p.angleIdx !== 12) {
          const diff = ((12 - p.angleIdx) + NUM_ANGLES) % NUM_ANGLES;
          if (diff <= 8) p.angleIdx = (p.angleIdx + 1) % NUM_ANGLES;
          else p.angleIdx = ((p.angleIdx - 1) + NUM_ANGLES) % NUM_ANGLES;
        }
      }
      // Speed naturally increases during dive — minimum floor of 1
      if (p.speed < 1) p.speed = 1;
      // Recover when speed adequate (relaxed angle requirement)
      if (p.speed >= PLANE_MIN_SPEED) {
        p.stalled = false;
      }
    }

    // Velocity from speed + angle
    // COS_TABLE/SIN_TABLE: index 0=right, 4=up in math coords
    // Canvas: Y-down, so negate SIN for vy
    p.vx = COS_TABLE[effAngle] * p.speed * PIXELS_PER_UNIT;
    p.vy = -SIN_TABLE[effAngle] * p.speed * PIXELS_PER_UNIT;

    // Stall gravity (only when actually stalling, not just slow with throttle)
    if (p.stalled || (p.speed < PLANE_MIN_SPEED && p.accel === 0)) {
      p.vy += 150 * dt;
    }

    // Move
    p.x += p.vx * dt;
    p.y += p.vy * dt;

    // Fuel
    p.fuel -= dt * (8 + p.accel * 5);
    if (p.fuel <= 0) {
      p.fuel = 0;
      p.accel = 0;
      // Out of fuel — engine dead, plane glides down and crashes
      if (!p.burning && !p.stalled) {
        p.burning = true;
        p.engineOut = true;
        p.burnTimer = 5; // longer glide before crash
      }
    }

    // Engine trail
    if (p.accel > 0) {
      const rad = getPlaneRadians(p);
      const tx = p.x - Math.cos(rad) * 20;
      const ty = p.y - Math.sin(rad) * 20;
      addEngineTrail(tx, ty, -p.vx * 0.3, -p.vy * 0.3);
    }

    // Low fuel warning — sputtering smoke from engine
    if (!p.landed && !p.burning && p.fuel > 0) {
      const fuelRatio = p.fuel / MAX_FUEL;
      if (fuelRatio < 0.25) {
        const rad = getPlaneRadians(p);
        const ex = p.x - Math.cos(rad) * 18;
        const ey = p.y - Math.sin(rad) * 18;
        // Sputtering dark smoke — more frequent as fuel drops
        const smokeChance = fuelRatio < 0.10 ? 0.5 : 0.25;
        if (Math.random() < smokeChance) {
          addParticle(ex + (Math.random() - 0.5) * 6, ey + (Math.random() - 0.5) * 6,
            (Math.random() - 0.5) * 15, -15 - Math.random() * 10, 0.5,
            '#444', 2 + Math.random());
        }
        // Occasional orange sputter below 10%
        if (fuelRatio < 0.10 && Math.random() < 0.15) {
          addParticle(ex, ey, (Math.random() - 0.5) * 20, -10, 0.25, '#f80', 1.5);
        }
      }
    }

    // Auto-turn at world edges — instant horizontal mirror
    // angleIdx: 0=right, 4=up, 8=left, 12=down
    // Horizontal mirror formula: (8 - idx + 16) % 16
    //   0(right)→8(left), 1→7, 4(up)→4(up), 8(left)→0(right), 12(down)→12(down)
    if (p.x < 10) {
      p.x = 10;
      p.angleIdx = (8 - p.angleIdx + NUM_ANGLES) % NUM_ANGLES;
      p.vx = Math.abs(p.vx) || 1;
    }
    if (p.x >= WORLD_W - 10) {
      p.x = WORLD_W - 10;
      p.angleIdx = (8 - p.angleIdx + NUM_ANGLES) % NUM_ANGLES;
      p.vx = -(Math.abs(p.vx) || 1);
    }

    // Ceiling — bounce off, lose speed but don't kill it entirely
    if (p.y < -50) {
      p.y = -50;
      p.vy = Math.abs(p.vy) * 0.3; // push back down gently
      // Bleed speed but keep enough to recover
      p.speed = Math.max(PLANE_MIN_SPEED, Math.floor(p.speed * 0.5));
      // Nudge nose downward to help recovery
      if (p.angleIdx >= 2 && p.angleIdx <= 6) {
        // Pointing upward — push toward level
        p.angleIdx = (p.angleIdx + 1) % NUM_ANGLES;
      }
    }

    // Ground collision
    const groundY = getTerrainY(p.x);
    if (p.y >= groundY - 8) {
      const nearBase = p.x > baseX - 30 && p.x < baseX + BASE_WIDTH + 30;
      // Level = angleIdx near 0 (rightward: 0,1,15) or near 8 (leftward: 7,8,9)
      const levelEnough = (p.angleIdx <= 1 || p.angleIdx >= 15 || (p.angleIdx >= 7 && p.angleIdx <= 9));
      const slowEnough = p.speed <= PLANE_MIN_SPEED + 2;

      if (nearBase && levelEnough && slowEnough && !p.stalled && !p.orient && !p.burning) {
        p.y = groundY - 8;
        p.vy = 0; p.vx = 0; p.speed = 0; p.accel = 0; p.angleIdx = 0;
        p.orient = false;
        p.landed = true; p.stalled = false;
        p.fuel = MAX_FUEL; p.ammo = MAX_AMMO; p.bombCount = MAX_BOMBS;
        p.hp = PLAYER_MAX_HP; // Repair on landing
      } else {
        killPlayer();
        return;
      }
    }
  } else {
    // ── On ground at base ──
    if (keys['KeyX'] || keys['ArrowUp']) {
      p.landed = false;
      p.stalled = false;
      p.orient = false;
      p.accel = PLANE_MAX_ACCEL;
      p.speed = PLANE_MAX_SPEED - 1;
      p.angleIdx = 2; // Slight nose-up: index 2 = climbing right at ~45°
    }
    p.y = getTerrainY(p.x) - 8;
  }
}

// ── Parachute tracking ──
let parachutes = [];

function damagePlayer(amount) {
  if (player.invincible > 0 || player.burning || state !== ST.PLAYING) return;
  amount = amount || 1;
  player.hp -= amount;
  player.hitFlash = 0.3;
  player.invincible = 0.5; // brief i-frames after hit
  addExplosion(player.x, player.y, 8, false);
  if (player.hp <= 0) {
    // Plane is destroyed — start burning dive
    player.burning = true;
    player.burnTimer = 2.5; // seconds until final explosion
    player.autopilot = false;
    // Eject pilot parachute
    parachutes.push({
      x: player.x, y: player.y - 10,
      vx: (Math.random() - 0.5) * 30,
      vy: -40,
      deployed: false,
      deployTimer: 0.3,
      landed: false
    });
  }
}

function killPlayer() {
  addExplosion(player.x, player.y, 40, true);
  playBoom(true);
  // Crater in terrain (skip if inside home base territory or water)
  const crashIsWater = waterLineY > 0 && getTerrainY(player.x) >= waterLineY - 5;
  if (!isInBaseTerritory(player.x) && !crashIsWater) {
    for (let dx = -30; dx <= 30; dx++) {
      const ix = Math.floor(((player.x + dx) % WORLD_W + WORLD_W) % WORLD_W);
      if (ix >= 0 && ix < WORLD_W) {
        terrain[ix] += (30 - Math.abs(dx)) * 0.5;
      }
    }
  }
  player.burning = false;
  player.engineOut = false;
  lives--;
  state = ST.DYING;
  deathTimer = 2.5;
}

function updateParachutes(dt) {
  for (let i = parachutes.length - 1; i >= 0; i--) {
    const p = parachutes[i];
    if (p.landed) {
      p.landTimer -= dt;
      if (p.landTimer <= 0) { parachutes.splice(i, 1); }
      continue;
    }
    p.deployTimer -= dt;
    if (p.deployTimer <= 0) p.deployed = true;
    if (p.deployed) {
      // Gentle drift down
      p.vy = 40; // slow descent
      p.vx *= 0.98; // slow horizontal drift
    } else {
      // Free-fall before chute opens
      p.vy += 200 * dt;
    }
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    // Ground landing
    const groundY = getTerrainY(p.x);
    if (p.y >= groundY - 5) {
      p.y = groundY - 5;
      p.landed = true;
      p.landTimer = 2; // stay visible on ground briefly
    }
  }
}

function updateBullets(dt) {
  for (let i = bullets.length - 1; i >= 0; i--) {
    const b = bullets[i];
    b.x += b.vx * dt;
    b.y += b.vy * dt;
    b.vy += PROJ_GRAVITY * 0.3 * dt;
    b.life -= dt;

    // Despawn at world edges
    if (b.x < 0 || b.x >= WORLD_W) { bullets.splice(i, 1); continue; }

    // Ground hit
    if (b.y >= getTerrainY(b.x)) {
      addParticle(b.x, b.y, 0, -30, 0.2, '#ff0', 2);
      bullets.splice(i, 1);
      continue;
    }

    if (b.life <= 0 || b.y < -200) {
      bullets.splice(i, 1);
      continue;
    }

    // Hit buildings (friendly bullets only)
    if (b.friendly) {
      for (const bld of buildings) {
        if (!bld.alive) continue;
        if (b.x > bld.x && b.x < bld.x + bld.w && b.y > bld.y && b.y < bld.y + bld.h) {
          bld.hp--;
          if (bld.hp <= 0) {
            bld.alive = false;
            addExplosion(bld.x + bld.w / 2, bld.y + bld.h / 2, 25, true);
            playBoom(true);
            score += buildingScores[bld.type] || 100;
            // Terrain crater (skip in base territory and water)
            const bldIsWater = waterLineY > 0 && getTerrainY(bld.x + bld.w / 2) >= waterLineY - 5;
            if (!isInBaseTerritory(bld.x + bld.w / 2) && !bldIsWater) {
              for (let dx = -20; dx <= 20; dx++) {
                const ix = Math.floor(((bld.x + bld.w / 2 + dx) % WORLD_W + WORLD_W) % WORLD_W);
                if (ix >= 0 && ix < WORLD_W) terrain[ix] += (20 - Math.abs(dx)) * 0.3;
              }
            }
            onBuildingDestroyed(bld);
          } else {
            addExplosion(b.x, b.y, 5, false);
            // Dam hit: extra blue splash
            if (bld.type === 'dam') {
              for (let k = 0; k < 6; k++) {
                addParticle(b.x, b.y, (Math.random()-0.5)*60, -30-Math.random()*40, 0.4, '#48f', 2);
              }
            }
          }
          bullets.splice(i, 1);
          break;
        }
      }
    }

    // Friendly bullets hit enemies (type-aware hitbox)
    if (b.friendly) {
      for (const en of enemies) {
        if (!en.alive || en.state === 'hangar') continue;
        const spec = ENEMY_SPECS[en.type] || ENEMY_SPECS.biplane;
        if (Math.abs(b.x - en.x) < spec.hitW && Math.abs(b.y - en.y) < spec.hitH) {
          en.hp--;
          if (en.hp <= 0) {
            en.alive = false;
            addExplosion(en.x, en.y, 20, true);
            playBoom(false);
            score += spec.score;
            launchNextFromBases();
          }
          bullets.splice(i, 1);
          break;
        }
      }
    }

    // Friendly bullets hit dragons
    if (b.friendly) {
      for (const d of dragons) {
        if (!d.alive) continue;
        if (Math.abs(b.x - d.x) < 25 && Math.abs(b.y - d.y) < 15) {
          d.hp--;
          if (d.hp <= 0) {
            d.alive = false;
            addExplosion(d.x, d.y, 40, true);
            playBoom(true);
            score += 1000;
          } else {
            addExplosion(b.x, b.y, 5, false);
          }
          bullets.splice(i, 1);
          break;
        }
      }
    }

    // Friendly bullets hit submarines (when not fully submerged)
    if (b.friendly) {
      for (const sub of submarines) {
        if (!sub.alive || sub.phase === 'submerged') continue;
        if (Math.abs(b.x - sub.x) < 55 && Math.abs(b.y - sub.y) < 18) {
          sub.hp--;
          if (sub.hp <= 0) {
            sub.alive = false;
            addExplosion(sub.x, sub.y, 30, true);
            playBoom(true);
            score += 400;
          } else {
            addExplosion(b.x, b.y, 5, false);
          }
          bullets.splice(i, 1);
          break;
        }
      }
    }

    // Enemy bullets hit player
    if (!b.friendly && player.invincible <= 0 && !player.burning) {
      if (Math.abs(b.x - player.x) < 18 && Math.abs(b.y - player.y) < 10) {
        damagePlayer(1);
        bullets.splice(i, 1);
        break;
      }
    }
  }
}

function updateBombs(dt) {
  for (let i = bombs.length - 1; i >= 0; i--) {
    const b = bombs[i];
    b.x += b.vx * dt;
    b.y += b.vy * dt;
    // Torpedoes travel horizontally at water surface — no gravity
    if (!b.isTorpedo) {
      b.vy += PROJ_GRAVITY * dt;
    }
    b.life -= dt;

    // Despawn at world edges
    if (b.x < 0 || b.x >= WORLD_W) { bombs.splice(i, 1); continue; }

    let hit = false;

    // Building hit FIRST (only player/friendly bombs damage buildings)
    // Must check before ground hit since buildings sit on terrain
    if (b.friendly !== false) {
      for (const bld of buildings) {
        if (!bld.alive) continue;
        if (b.x > bld.x - 5 && b.x < bld.x + bld.w + 5 && b.y > bld.y - 5 && b.y < bld.y + bld.h + 5) {
          bld.hp -= 2;
          if (bld.hp <= 0) {
            bld.alive = false;
            score += buildingScores[bld.type] || 100;
            onBuildingDestroyed(bld);
          }
          hit = true;
          break;
        }
      }
    }

    // Player bombs hit submarines (hittable when not fully submerged)
    if (b.friendly !== false) {
      for (const sub of submarines) {
        if (!sub.alive || sub.phase === 'submerged') continue;
        if (Math.abs(b.x - sub.x) < 55 && Math.abs(b.y - sub.y) < 18) {
          sub.hp--;
          addExplosion(b.x, b.y, 15, false);
          if (sub.hp <= 0) {
            sub.alive = false;
            addExplosion(sub.x, sub.y, 40, true);
            playBoom(true);
            score += 800;
          }
          hit = true;
          break;
        }
      }
    }

    // Ground hit (checked after buildings so bombs can hit structures on terrain)
    if (!hit && b.y >= getTerrainY(b.x)) {
      hit = true;
    }

    // Enemy bombs hit player
    if (b.friendly === false && player.invincible <= 0 && !player.burning && state === ST.PLAYING) {
      if (Math.abs(b.x - player.x) < 20 && Math.abs(b.y - player.y) < 15) {
        damagePlayer(2);
        bombs.splice(i, 1);
        continue;
      }
    }

    if (hit || b.life <= 0) {
      const isWater = waterLineY > 0 && getTerrainY(b.x) >= waterLineY - 5;
      if (isWater) {
        // Water splash — no crater, water particles instead
        for (let s = 0; s < 8; s++) {
          addParticle(b.x + (Math.random() - 0.5) * 10, b.y,
            (Math.random() - 0.5) * 60, -40 - Math.random() * 60, 0.5,
            '#4af', 2 + Math.random());
        }
        addExplosion(b.x, b.y, 10, false);
      } else {
        addExplosion(b.x, b.y, 30, true);
        // Crater (skip in base territory)
        if (!isInBaseTerritory(b.x)) {
          for (let dx = -40; dx <= 40; dx++) {
            const ix = Math.floor(((b.x + dx) % WORLD_W + WORLD_W) % WORLD_W);
            if (ix >= 0 && ix < WORLD_W) {
              terrain[ix] += (40 - Math.abs(dx)) * 0.4;
            }
          }
        }
      }
      playBoom(true);
      bombs.splice(i, 1);
    }
  }
}

function updateChaserEnemy(en, dt, playerSafe, turnRate, bulletSpeedMult) {
  let dx, dy, dist, desiredAngle;
  if (playerSafe) {
    // Stable patrol point based on parking slot, not current position
    const patrolX = 2000 + ((en.parkSlot || 0) * 1700) % (WORLD_W - 4000);
    const patrolY = 100 + ((en.parkSlot || 0) * 50) % 150;
    dx = patrolX - en.x;
    dy = patrolY - en.y;
    dist = Math.sqrt(dx * dx + dy * dy);
    desiredAngle = Math.atan2(dy, dx);
  } else {
    dx = player.x - en.x;
    dy = player.y - en.y;
    dist = Math.sqrt(dx * dx + dy * dy);
    desiredAngle = Math.atan2(dy, dx);
  }

  // Handle bird-strike stall for jets
  if (en.stalled && en.stallTimer > 0) {
    en.stallTimer -= dt;
    en.speed = 40; // drastically reduced
    en.angle += 0.3 * dt; // nose drops
    if (en.stallTimer <= 0) { en.stalled = false; en.speed = ENEMY_SPECS[en.type].speed; }
  }

  let angleDiff = desiredAngle - en.angle;
  while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
  while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
  en.angle += Math.sign(angleDiff) * Math.min(Math.abs(angleDiff), turnRate * dt);

  const spd = en.stalled ? 40 : en.speed;
  en.vx = Math.cos(en.angle) * spd;
  en.vy = Math.sin(en.angle) * spd;
  en.x += en.vx * dt;
  en.y += en.vy * dt;

  const groundY = getTerrainY(en.x);
  if (en.y > groundY - 12) {
    // Crash into terrain — enemy dies
    en.alive = false;
    addExplosion(en.x, en.y, 25, false);
    score += ENEMY_SPECS[en.type].score;
    launchNextFromBases();
    return 9999;
  }
  if (en.y < 30) en.y = 30;

  // Fire at player — with accuracy spread
  const fireIntervalMult = enemyAccuracyDebuff > 0 ? 2 : 1;
  en.fireTimer--;
  if (en.fireTimer <= 0 && dist < 600 && !playerSafe) {
    const spread = (Math.random() - 0.5) * 0.25; // ±~7 degrees
    const fireAngle = en.angle + spread;
    const bvx = Math.cos(fireAngle) * BULLET_SPEED * bulletSpeedMult;
    const bvy = Math.sin(fireAngle) * BULLET_SPEED * bulletSpeedMult;
    bullets.push({ x: en.x + Math.cos(en.angle) * 20, y: en.y + Math.sin(en.angle) * 20, vx: bvx, vy: bvy, life: 1.0, friendly: false });
    en.fireTimer = (ENEMY_SPECS[en.type].fireInterval + Math.random() * 50 | 0) * fireIntervalMult;
  }

  return dist;
}

function updateBomberEnemy(en, dt, playerSafe) {
  // Flies toward player's base area at high altitude, drops bombs
  const targetX = playerSafe ? 6000 : baseX + BASE_WIDTH / 2;
  const targetY = 80 + Math.sin(Date.now() * 0.001 + en.x * 0.01) * 40;

  let dx = targetX - en.x;
  let dy = targetY - en.y;
  const dist = Math.sqrt(dx * dx + dy * dy);
  const desiredAngle = Math.atan2(dy, dx);

  let angleDiff = desiredAngle - en.angle;
  while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
  while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
  en.angle += Math.sign(angleDiff) * Math.min(Math.abs(angleDiff), 1.0 * dt); // Slower turn

  en.vx = Math.cos(en.angle) * en.speed;
  en.vy = Math.sin(en.angle) * en.speed;
  en.x += en.vx * dt;
  en.y += en.vy * dt;

  const groundY = getTerrainY(en.x);
  if (en.y > groundY - 12) {
    en.alive = false;
    addExplosion(en.x, en.y, 25, false);
    score += ENEMY_SPECS[en.type].score;
    launchNextFromBases();
    return 9999;
  }
  if (en.y < 50) en.y = 50;

  // Drop bombs when above base area or near player
  const fireIntervalMult = enemyAccuracyDebuff > 0 ? 2 : 1;
  en.fireTimer--;
  if (en.fireTimer <= 0 && !playerSafe) {
    const nearBase = Math.abs(en.x - baseX - BASE_WIDTH / 2) < 300;
    const nearPlayer = Math.abs(en.x - player.x) < 200;
    if (nearBase || nearPlayer) {
      bombs.push({ x: en.x, y: en.y + 10, vx: en.vx * 0.3, vy: 20, life: 5, friendly: false });
      en.fireTimer = (BOMBER_BOMB_INTERVAL + Math.random() * 40 | 0) * fireIntervalMult;
    }
  }

  // ── Defensive turret guns (both sides) — limited firing arc ──
  if (!en.turretTimer) en.turretTimer = 0;
  en.turretTimer -= dt;
  if (en.turretTimer <= 0 && !playerSafe) {
    const tdx = player.x - en.x;
    const tdy = player.y - en.y;
    const tdist = Math.sqrt(tdx * tdx + tdy * tdy);
    if (tdist < 500) {
      const aimAngle = Math.atan2(tdy, tdx);
      // Relative angle from bomber's heading — turrets can't fire forward or backward
      let relAngle = aimAngle - en.angle;
      while (relAngle > Math.PI) relAngle -= Math.PI * 2;
      while (relAngle < -Math.PI) relAngle += Math.PI * 2;
      const absRel = Math.abs(relAngle);
      // Turrets cover broadside arcs: ~30° to ~150° off the nose (no forward/rear fire)
      if (absRel > 0.5 && absRel < 2.6) {
        // Top turret fires when player is above or level
        if (relAngle < 0 || Math.abs(relAngle) > Math.PI * 0.5) {
          const spread1 = (Math.random() - 0.5) * 0.35;
          bullets.push({
            x: en.x + Math.sin(en.angle) * 12, y: en.y - Math.cos(en.angle) * 12,
            vx: Math.cos(aimAngle + spread1) * BULLET_SPEED * 0.6,
            vy: Math.sin(aimAngle + spread1) * BULLET_SPEED * 0.6,
            life: 0.7, friendly: false
          });
        }
        // Bottom turret fires when player is below or level
        if (relAngle > 0 || Math.abs(relAngle) > Math.PI * 0.5) {
          const spread2 = (Math.random() - 0.5) * 0.35;
          bullets.push({
            x: en.x - Math.sin(en.angle) * 12, y: en.y + Math.cos(en.angle) * 12,
            vx: Math.cos(aimAngle + spread2) * BULLET_SPEED * 0.6,
            vy: Math.sin(aimAngle + spread2) * BULLET_SPEED * 0.6,
            life: 0.7, friendly: false
          });
        }
        en.turretTimer = (0.45 + Math.random() * 0.3) * fireIntervalMult;
      }
    }
  }
  // Store turret aim angle for drawing
  if (!playerSafe && dist < 500) {
    en.turretAngle = Math.atan2(player.y - en.y, player.x - en.x);
  }

  return dist;
}

function updateZeppelinEnemy(en, dt) {
  // Patrols left-right slowly, drops bombs periodically
  en.x += en.patrolDir * en.speed * dt;
  // Cruise altitude — rise gradually if below it (e.g. after takeoff)
  const cruiseY = 50 + Math.sin(Date.now() * 0.0005 + en.x * 0.001) * 30;
  if (en.y > cruiseY + 5) {
    en.y -= 30 * dt; // gentle ascent
  } else {
    en.y = cruiseY;
  }

  // Reverse at world edges
  if (en.x > WORLD_W - 500) en.patrolDir = -1;
  if (en.x < 500) en.patrolDir = 1;

  en.vx = en.patrolDir * en.speed;
  en.vy = 0;
  en.angle = en.patrolDir > 0 ? 0 : Math.PI;

  const groundY = getTerrainY(en.x);
  if (en.y > groundY - 80) en.y = groundY - 80;

  // Drop 3 bombs in a spread periodically
  const fireIntervalMult = enemyAccuracyDebuff > 0 ? 2 : 1;
  en.fireTimer--;
  if (en.fireTimer <= 0) {
    for (let k = -1; k <= 1; k++) {
      bombs.push({ x: en.x + k * 15, y: en.y + 20, vx: en.vx * 0.2 + k * 10, vy: 15, life: 6, friendly: false });
    }
    en.fireTimer = (ZEPPELIN_BOMB_INTERVAL + Math.random() * 30 | 0) * fireIntervalMult;
  }

  return Math.sqrt((player.x - en.x) ** 2 + (player.y - en.y) ** 2);
}

function updateEnemies(dt) {
  for (const en of enemies) {
    if (!en.alive) continue;

    // ── Hangar state: hidden, waiting for launch ──
    if (en.state === 'hangar') continue;

    // ── Grounded state: on the strip, about to take off ──
    if (en.state === 'grounded') {
      en.takeoffTimer -= dt;
      // Stay at airfield center — enforce position and facing angle
      if (en.homeBase) {
        const stripX = en.homeBase.x + BASE_WIDTH / 2;
        const groundY = getTerrainY(stripX);
        en.y = groundY - 8;
        en.x = stripX;
        en.vx = 0; en.vy = 0;
        const facesRight = en.homeBase.x < WORLD_W / 2;
        en.angle = facesRight ? 0 : Math.PI;
      }
      if (en.takeoffTimer <= 0) {
        en.state = 'flying';
        en.landed = false;
        en.fuel = ENEMY_MAX_FUEL;
        // Launch upward and toward player base — must clear terrain crash zone
        const towardPlayer = en.x < baseX ? -0.3 : (Math.PI + 0.3);
        en.angle = towardPlayer;
        en.y -= 40; // launch well above ground to clear crash threshold
        en.vx = Math.cos(en.angle) * en.speed;
        en.vy = -60; // strong upward launch
      }
      // Grounded enemies can still be hit — fall through to collision checks
    }

    // ── Flying or returning ──
    if (en.state === 'flying' || en.state === 'returning') {
      const playerSafe = player.invincible > 0 || player.landed;
      let dist;

      // Consume fuel
      en.fuel -= dt * 20;

      // Switch to returning when fuel low
      if (en.fuel < 150 && en.state === 'flying') {
        en.state = 'returning';
      }

      // Returning enemies re-engage if player gets close
      if (en.state === 'returning' && en.fuel > 30) {
        const reEngageDist = Math.sqrt((player.x - en.x) ** 2 + (player.y - en.y) ** 2);
        if (reEngageDist < 400 && !player.landed && !player.invincible) {
          en.state = 'flying';
        }
      }

      if (en.state === 'returning' && en.homeBase) {
        // Fly back to home base
        const homeX = en.homeBase.x + en.homeBase.width / 2;
        const homeGroundY = getTerrainY(homeX);
        const horizDist = Math.abs(en.x - homeX);

        if (horizDist > 120) {
          // ── Phase 1: Cruise toward base at safe altitude ──
          const cruiseY = homeGroundY - 60;
          const dx = homeX - en.x;
          const dy = cruiseY - en.y;
          dist = Math.sqrt(dx * dx + dy * dy);
          const desiredAngle = Math.atan2(dy, dx);
          let angleDiff = desiredAngle - en.angle;
          while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
          while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
          en.angle += Math.sign(angleDiff) * Math.min(Math.abs(angleDiff), 2.5 * dt);
          en.vx = Math.cos(en.angle) * en.speed * 0.7;
          en.vy = Math.sin(en.angle) * en.speed * 0.7;
          en.x += en.vx * dt;
          en.y += en.vy * dt;
        } else {
          // ── Phase 2: Final approach — descend directly onto runway ──
          const landingY = homeGroundY - 8;
          en.x += (homeX - en.x) * 2.0 * dt; // drift toward center
          en.y += (landingY - en.y) * 1.5 * dt; // descend to landing altitude
          en.vx = 0;
          en.vy = 0;
          const facesRight = en.homeBase.x < WORLD_W / 2;
          en.angle = facesRight ? 0 : Math.PI;
          dist = Math.abs(en.y - landingY);
        }

        // Terrain clamping — away from base, crash on terrain contact
        const retGroundY = getTerrainY(en.x);
        if (horizDist > 120) {
          if (en.y > retGroundY - 12) {
            en.alive = false;
            addExplosion(en.x, en.y, 25, false);
            score += ENEMY_SPECS[en.type].score;
            launchNextFromBases();
            continue;
          }
        } else {
          if (en.y > retGroundY - 6) en.y = retGroundY - 6;
        }

        // Landing check — close to runway and low enough
        const nearBase = horizDist < 30;
        if (nearBase && en.y >= homeGroundY - 12) {
          // Landed — return to hangar and launch next plane
          en.state = 'hangar';
          en.landed = true;
          en.vx = 0; en.vy = 0;
          en.fuel = ENEMY_MAX_FUEL;
          en.hp = ENEMY_SPECS[en.type].hp; // repair in hangar
          launchNextFromBases();
          continue;
        }
      } else {
        // Normal combat behavior
        if (en.type === 'zeppelin') {
          dist = updateZeppelinEnemy(en, dt);
        } else if (en.type === 'bomber') {
          dist = updateBomberEnemy(en, dt, playerSafe);
        } else if (en.type === 'jet') {
          dist = updateChaserEnemy(en, dt, playerSafe, 1.6, 0.85);
        } else {
          dist = updateChaserEnemy(en, dt, playerSafe, 1.0, 0.7);
        }
      }

      // Clamp at world edges
      if (en.x < 50) { en.x = 50; en.vx = Math.abs(en.vx); en.angle = 0; }
      if (en.x >= WORLD_W - 50) { en.x = WORLD_W - 50; en.vx = -Math.abs(en.vx); en.angle = Math.PI; }

      // Engine trail (color per type)
      const trailColor = ENEMY_SPECS[en.type].color;
      addParticle(en.x - Math.cos(en.angle) * 18, en.y - Math.sin(en.angle) * 18, -en.vx * 0.05, -en.vy * 0.05, 0.15, trailColor, 1.5);

      // Bird strike check for jet enemies
      if (en.type === 'jet' && !en.stalled) {
        for (const bg of birds) {
          for (const bird of bg.flock) {
            if (!bird.alive) continue;
            if (Math.abs(bird.x - en.x) < 15 && Math.abs(bird.y - en.y) < 10) {
              bird.alive = false;
              addExplosion(bird.x, bird.y, 6, false);
              en.stalled = true;
              en.stallTimer = 3;
              en.speed = 40;
            }
          }
        }
      }
    }

    // Collision with player (both grounded and flying enemies)
    if (player.invincible <= 0 && !player.burning && state === ST.PLAYING && !en.landed) {
      const spec = ENEMY_SPECS[en.type];
      if (Math.abs(en.x - player.x) < spec.hitW + 5 && Math.abs(en.y - player.y) < spec.hitH + 3) {
        en.alive = false;
        addExplosion(en.x, en.y, 20, true);
        damagePlayer(3); // Collision is devastating
        launchNextFromBases();
      }
    }
  }
}

function updateFlak(dt) {
  // Buildings shoot flak
  for (const bld of buildings) {
    if (!bld.alive || bld.type !== 'flak') continue;
    bld.flakTimer--;
    if (bld.flakTimer <= 0) {
      const dx = player.x - (bld.x + bld.w / 2);
      const dy = player.y - (bld.y);
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < 500) {
        // Large spread — flak is inaccurate area suppression
        const spread = (Math.random() - 0.5) * 0.5; // ±~14 degrees
        const a = Math.atan2(dy, dx) + spread;
        flakShots.push({
          x: bld.x + bld.w / 2, y: bld.y,
          vx: Math.cos(a) * FLAK_SPEED, vy: Math.sin(a) * FLAK_SPEED,
          life: 1.5
        });
      }
      bld.flakTimer = FLAK_INTERVAL + Math.random() * 40 | 0; // More random timing
    }
  }

  // Update flak shots
  for (let i = flakShots.length - 1; i >= 0; i--) {
    const f = flakShots[i];
    f.x += f.vx * dt;
    f.y += f.vy * dt;
    f.life -= dt;

    // Trail
    addParticle(f.x, f.y, 0, 0, 0.1, '#f80', 1);

    if (f.life <= 0) {
      // Burst
      addExplosion(f.x, f.y, 8, false);
      flakShots.splice(i, 1);
      continue;
    }

    // Hit player
    if (player.invincible <= 0 && !player.burning && state === ST.PLAYING) {
      if (Math.abs(f.x - player.x) < 20 && Math.abs(f.y - player.y) < 15) {
        damagePlayer(1);
        flakShots.splice(i, 1);
      }
    }
  }
}

function updateBirds(dt) {
  for (const bg of birds) {
    for (const b of bg.flock) {
      if (!b.alive) continue;
      b.x += bg.vx * dt;
      const sinAmp = bg.sinAmp || 4;
      const sinFreq = bg.sinFreq || 0.005;
      b.y += bg.vy * dt + Math.sin(Date.now() * sinFreq + b.x * 0.1) * (sinAmp * 0.1);

      // Keep birds above terrain
      const groundY = getTerrainY(b.x);
      if (b.y > groundY - 30) {
        b.y = groundY - 30;
        bg.vy = -8 - Math.random() * 5; // fixed gentle upward bounce
      }
      // Keep above top of screen
      if (b.y < 20) { b.y = 20; bg.vy = 3 + Math.random() * 3; }

      // Reverse direction at world edges
      if (b.x < 50) { b.x = 50; bg.vx = Math.abs(bg.vx); }
      if (b.x >= WORLD_W - 50) { b.x = WORLD_W - 50; bg.vx = -Math.abs(bg.vx); }

      // Collision with player
      if (player.invincible <= 0 && !player.burning && state === ST.PLAYING) {
        const hitRange = bg.type === 'eagle' ? 18 : bg.type === 'goose' ? 16 : 12;
        if (Math.abs(b.x - player.x) < hitRange && Math.abs(b.y - player.y) < 10) {
          b.alive = false;
          if (bg.type === 'sparrow') {
            // Sparrows: harmless — big comedic feather explosion!
            const featherColors = ['#fff', '#eee', '#ddd', '#ccc', '#aaf', '#bbf', '#ffd', '#fec'];
            for (let k = 0; k < 35; k++) {
              const angle = Math.random() * Math.PI * 2;
              const speed = 20 + Math.random() * 80;
              const vx = Math.cos(angle) * speed + (player.vx || 0) * 0.3;
              const vy = Math.sin(angle) * speed - 15; // bias upward for poof effect
              const col = featherColors[Math.floor(Math.random() * featherColors.length)];
              addParticle(b.x + (Math.random()-0.5)*8, b.y + (Math.random()-0.5)*6, vx, vy, 0.8 + Math.random() * 0.6, col, 1.5 + Math.random() * 2);
            }
            // A few bigger slow-floating feathers
            for (let k = 0; k < 6; k++) {
              const col = Math.random() < 0.5 ? '#fff' : '#aaf';
              addParticle(b.x + (Math.random()-0.5)*12, b.y, (Math.random()-0.5)*30, -10 + Math.random()*20, 1.5 + Math.random(), col, 3 + Math.random() * 2);
            }
          } else {
            // Geese and eagles: damage, not instant kill
            addExplosion(b.x, b.y, 8, false);
            damagePlayer(1);
          }
        }
      }
    }
  }
}

function updateOxen(dt) {
  for (const o of oxen) {
    if (!o.alive) continue;
    o.x += o.dir * o.speed * dt;
    const ty = getTerrainY(o.x);
    o.y = ty - o.h;

    // Reverse at edges or randomly
    if (Math.random() < 0.005) o.dir *= -1;

    // Collision with player
    if (player.invincible <= 0 && !player.burning && state === ST.PLAYING) {
      if (player.x > o.x - 5 && player.x < o.x + o.w + 5 && player.y > o.y - 10 && player.y < o.y + o.h + 5) {
        o.alive = false;
        addExplosion(o.x + o.w / 2, o.y, 10, false);
        damagePlayer(2);
      }
    }
  }
}

function updateParticles(dt) {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.vy += 40 * dt;
    p.life -= dt;
    if (p.life <= 0) particles.splice(i, 1);
  }
}

function updateFleeingPeople(dt) {
  for (let i = fleeingPeople.length - 1; i >= 0; i--) {
    const p = fleeingPeople[i];
    p.x += p.dir * p.speed * dt;
    p.y = getTerrainY(p.x);
    p.frame += dt;
    p.life -= dt;
    if (p.life <= 0) fleeingPeople.splice(i, 1);
  }
}

function updateDragons(dt) {
  for (const d of dragons) {
    if (!d.alive) continue;
    d.wingFrame += dt * 5;

    if (d.phase === 'circling') {
      // Circle in the sky at mid-altitude
      d.x += d.vx * dt;
      d.y = 120 + Math.sin(Date.now() * 0.001 + d.x * 0.002) * 60;
      d.vx = 60 * Math.sign(d.vx);

      // Reverse at world edges
      if (d.x > WORLD_W - 400) d.vx = -60;
      if (d.x < 400) d.vx = 60;

      d.breathTimer -= dt;
      if (d.breathTimer <= 0) {
        d.phase = 'diving';
        d.diveTarget = { x: player.x, y: player.y };
      }
    } else if (d.phase === 'diving') {
      // Dive toward ground
      const dx = d.diveTarget.x - d.x;
      const dy = (getTerrainY(d.diveTarget.x) - 50) - d.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      d.vx = (dx / (dist || 1)) * 120;
      d.vy = (dy / (dist || 1)) * 120;
      d.x += d.vx * dt;
      d.y += d.vy * dt;

      if (dist < 80 || d.y > getTerrainY(d.x) - 40) {
        d.phase = 'breathing';
        d.breathTimer = 1.5;
      }
    } else if (d.phase === 'breathing') {
      // Fire breath: spawn fire particles
      d.vx *= 0.95;
      d.vy *= 0.95;
      d.x += d.vx * dt;
      d.y += d.vy * dt;

      // Spawn fire particles in a cone
      if (Math.random() < 0.4) {
        const facingLeft = d.vx < 0;
        const dir = facingLeft ? -1 : 1;
        const fx = d.x + dir * 30;
        const fy = d.y;
        addParticle(fx, fy, dir * (80 + Math.random() * 60), (Math.random() - 0.5) * 40, 0.5, Math.random() < 0.5 ? '#f80' : '#ff0', 3);
        // Check fire particle collision with player
        if (player.invincible <= 0 && !player.burning && state === ST.PLAYING) {
          if (Math.abs(fx - player.x) < 25 && Math.abs(fy - player.y) < 20) {
            damagePlayer(1);
          }
        }
      }

      d.breathTimer -= dt;
      if (d.breathTimer <= 0) {
        d.phase = 'circling';
        d.breathTimer = 5 + Math.random() * 5;
        d.vx = (Math.random() < 0.5 ? 1 : -1) * 60;
        d.vy = 0;
      }
    }

    // Keep above ground
    const groundY = getTerrainY(d.x);
    if (d.y > groundY - 30) d.y = groundY - 30;

    // Clamp at world edges
    if (d.x < 100) { d.x = 100; d.vx = Math.abs(d.vx); }
    if (d.x >= WORLD_W - 100) { d.x = WORLD_W - 100; d.vx = -Math.abs(d.vx); }

    // Collision with player (body)
    if (player.invincible <= 0 && !player.burning && state === ST.PLAYING) {
      if (Math.abs(d.x - player.x) < 25 && Math.abs(d.y - player.y) < 15) {
        damagePlayer(2);
      }
    }
  }
}

function checkLevelComplete() {
  const targets = buildings.filter(b => b.isTarget && b.alive);
  if (targets.length === 0) {
    state = ST.LEVEL_COMPLETE;
    levelTimer = 3;
    score += 1000 * level;
    // Bonus life (max 9)
    if (lives < 9) {
      lives++;
      extraLifeMsg = 2.5; // show message timer
    }
  }
}

// ── HUD update ──
function getBarColor(pct) {
  if (pct > 50) return '#0f0';
  if (pct > 25) return '#ff0';
  return '#f22';
}
function updateHUD() {
  const p = player;

  // HP display
  const hpEl = document.getElementById('h-hp');
  let hpStr = '';
  for (let i = 0; i < PLAYER_MAX_HP; i++) hpStr += i < p.hp ? '\u25A0' : '\u25A1';
  hpEl.textContent = hpStr;
  hpEl.className = 'hud-val ' + (p.hp <= 1 ? 'red' : 'green');

  let livesStr = '';
  const maxDots = Math.max(5, lives);
  for (let i = 0; i < maxDots; i++) livesStr += i < lives ? '●' : '○';
  document.getElementById('h-lives').textContent = livesStr;

  // Fuel bar with color transitions and warning
  const fuelPct = Math.round(p.fuel / MAX_FUEL * 100);
  const fuelFill = document.getElementById('h-fuel');
  fuelFill.style.width = fuelPct + '%';
  fuelFill.style.background = `linear-gradient(90deg, ${getBarColor(fuelPct)}, ${fuelPct > 50 ? '#0ff' : getBarColor(fuelPct)})`;
  document.getElementById('h-fuel-pct').textContent = fuelPct + '%';
  const fuelBar = document.getElementById('fuel-bar-wrap');
  if (fuelPct < 20) fuelBar.classList.add('warning');
  else fuelBar.classList.remove('warning');

  // Ammo bar with color transitions and warning
  const ammoPct = Math.round(p.ammo / MAX_AMMO * 100);
  const ammoFill = document.getElementById('h-ammo');
  ammoFill.style.width = ammoPct + '%';
  ammoFill.style.background = `linear-gradient(90deg, ${getBarColor(ammoPct)}, ${ammoPct > 50 ? '#fa0' : getBarColor(ammoPct)})`;
  document.getElementById('h-ammo-pct').textContent = ammoPct + '%';
  const ammoBar = document.getElementById('ammo-bar-wrap');
  if (ammoPct < 15) ammoBar.classList.add('warning');
  else ammoBar.classList.remove('warning');

  // Bomb count with EMPTY indicator
  const bombEl = document.getElementById('h-bombs');
  if (p.bombCount <= 0) {
    bombEl.textContent = 'EMPTY';
    bombEl.classList.add('red');
    bombEl.classList.remove('green');
  } else {
    bombEl.textContent = p.bombCount;
    bombEl.classList.remove('red');
  }

  document.getElementById('h-score').textContent = String(score).padStart(6, '0');
  document.getElementById('h-level').textContent = level;
}

// ── Draw ──
function draw() {
  const W = canvas.width;
  const H = canvas.height;

  // Clear
  ctx.fillStyle = '#0a0a0f';
  ctx.fillRect(0, 0, W, H);

  if (state === ST.TITLE) {
    drawTitle(W, H);
    drawRadarEmpty();
    return;
  }

  // Stars
  ctx.fillStyle = '#fff';
  for (const s of stars) {
    const sx = ((s.x - camX * 0.3) % W + W) % W;
    const sy = s.y - camY * 0.1;
    if (sy < 0 || sy > H) continue;
    const flicker = s.b + Math.sin(Date.now() * 0.003 + s.x) * 0.1;
    ctx.globalAlpha = flicker;
    ctx.fillRect(sx, sy, s.s, s.s);
  }
  ctx.globalAlpha = 1;

  // ── World drawing (offset by camera) ──
  ctx.save();
  ctx.translate(-camX, -camY);

  // Terrain
  drawTerrain(W, H);

  // Home base
  drawBase();
  drawSearchlights();

  // Enemy airfields
  drawEnemyBases();

  // Buildings
  for (const bld of buildings) {
    if (!bld.alive) continue;
    const screenX = bld.x - camX;
    if (screenX < -100 || screenX > W + 100) continue;
    drawBuilding(bld);
  }

  // Animals (oxen, sheep, horses, camels)
  for (const o of oxen) {
    if (!o.alive) continue;
    const screenX = o.x - camX;
    if (screenX < -50 || screenX > W + 50) continue;
    drawAnimal(o);
  }

  // Fleeing people
  for (const p of fleeingPeople) {
    const screenX = p.x - camX;
    if (screenX < -50 || screenX > W + 50) continue;
    drawPerson(p);
  }

  // Birds (per-type rendering)
  for (const bg of birds) {
    for (const b of bg.flock) {
      if (!b.alive) continue;
      const screenX = b.x - camX;
      if (screenX < -50 || screenX > W + 50) continue;

      if (bg.type === 'eagle') {
        // Majestic eagle with visible body, tail feathers, hooked beak
        const col = '#c84';
        const t = Date.now() * 0.003 + b.x;
        const wing = Math.sin(t) * 6;
        const soar = Math.cos(t * 0.7) * 2; // gentle body bob
        // Danger aura — pulsing red glow
        const dangerPulse = 0.25 + Math.sin(Date.now() * 0.006) * 0.15;
        ctx.fillStyle = `rgba(255, 40, 40, ${dangerPulse})`;
        ctx.beginPath();
        ctx.arc(b.x, b.y + soar, 14, 0, Math.PI * 2);
        ctx.fill();
        neonGlow(ctx, col, 6);
        ctx.strokeStyle = col;
        ctx.lineWidth = 2;
        // Wings with feathered tips
        ctx.beginPath();
        ctx.moveTo(b.x - 18, b.y + wing);
        ctx.lineTo(b.x - 12, b.y + wing * 0.6);
        ctx.lineTo(b.x - 5, b.y + wing * 0.2);
        ctx.lineTo(b.x, b.y + soar);
        ctx.lineTo(b.x + 5, b.y + wing * 0.2);
        ctx.lineTo(b.x + 12, b.y + wing * 0.6);
        ctx.lineTo(b.x + 18, b.y + wing);
        ctx.stroke();
        // Wingtip feathers
        ctx.lineWidth = 1;
        for (let f = -1; f <= 1; f += 2) {
          ctx.beginPath();
          ctx.moveTo(b.x + f * 16, b.y + wing * 0.8);
          ctx.lineTo(b.x + f * 19, b.y + wing + 2);
          ctx.moveTo(b.x + f * 17, b.y + wing * 0.9);
          ctx.lineTo(b.x + f * 20, b.y + wing + 1);
          ctx.stroke();
        }
        // Body
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.ellipse(b.x, b.y + soar, 5, 2.5, 0, 0, Math.PI * 2);
        ctx.stroke();
        // Head with hooked beak
        ctx.fillStyle = '#fa8';
        ctx.beginPath();
        ctx.arc(b.x - 7, b.y + soar - 1, 2.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#ff0';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(b.x - 9, b.y + soar - 1);
        ctx.lineTo(b.x - 12, b.y + soar);
        ctx.lineTo(b.x - 11, b.y + soar + 1);
        ctx.stroke();
        // Eye
        ctx.fillStyle = '#ff0';
        ctx.beginPath();
        ctx.arc(b.x - 7, b.y + soar - 1.5, 0.8, 0, Math.PI * 2);
        ctx.fill();
        // Tail feathers
        ctx.strokeStyle = col;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(b.x + 5, b.y + soar);
        ctx.lineTo(b.x + 10, b.y + soar + 2);
        ctx.moveTo(b.x + 5, b.y + soar + 1);
        ctx.lineTo(b.x + 11, b.y + soar + 3);
        ctx.moveTo(b.x + 5, b.y + soar - 1);
        ctx.lineTo(b.x + 10, b.y + soar);
        ctx.stroke();
        clearGlow(ctx);
      } else if (bg.type === 'goose') {
        // Goose with stretched neck and rounded body
        const col = '#dda';
        const t = Date.now() * 0.007 + b.x * 0.5;
        const wing = Math.sin(t) * 6;
        // Danger aura — pulsing red glow
        const dangerPulse = 0.2 + Math.sin(Date.now() * 0.006 + 1) * 0.12;
        ctx.fillStyle = `rgba(255, 40, 40, ${dangerPulse})`;
        ctx.beginPath();
        ctx.arc(b.x, b.y, 10, 0, Math.PI * 2);
        ctx.fill();
        neonGlow(ctx, col, 4);
        ctx.strokeStyle = col;
        ctx.lineWidth = 1.5;
        // Wings
        ctx.beginPath();
        ctx.moveTo(b.x - 10, b.y + wing);
        ctx.quadraticCurveTo(b.x - 5, b.y + wing * 0.3, b.x, b.y);
        ctx.quadraticCurveTo(b.x + 5, b.y + wing * 0.3, b.x + 10, b.y + wing);
        ctx.stroke();
        // Body (oval)
        ctx.beginPath();
        ctx.ellipse(b.x, b.y + 1, 4, 2, 0, 0, Math.PI * 2);
        ctx.stroke();
        // Long neck stretching forward
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(b.x - 3, b.y);
        ctx.quadraticCurveTo(b.x - 6, b.y - 3, b.x - 9, b.y - 2);
        ctx.stroke();
        // Head
        ctx.fillStyle = '#333';
        ctx.beginPath();
        ctx.arc(b.x - 9, b.y - 2, 1.5, 0, Math.PI * 2);
        ctx.fill();
        // Beak
        ctx.strokeStyle = '#fa0';
        ctx.beginPath();
        ctx.moveTo(b.x - 10.5, b.y - 2);
        ctx.lineTo(b.x - 13, b.y - 1.5);
        ctx.stroke();
        clearGlow(ctx);
      } else {
        // Sparrows: small, chirpy with visible body and quick wingbeats
        const col = '#aaf';
        const t = Date.now() * 0.015 + b.x;
        const wing = Math.sin(t) * 4;
        neonGlow(ctx, col, 3);
        ctx.strokeStyle = col;
        ctx.lineWidth = 1;
        // Quick fluttering wings
        ctx.beginPath();
        ctx.moveTo(b.x - 6, b.y + wing);
        ctx.lineTo(b.x - 2, b.y);
        ctx.lineTo(b.x + 2, b.y);
        ctx.lineTo(b.x + 6, b.y + wing);
        ctx.stroke();
        // Round little body
        ctx.fillStyle = col;
        ctx.globalAlpha = 0.5;
        ctx.beginPath();
        ctx.arc(b.x, b.y + 0.5, 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
        // Tail
        ctx.beginPath();
        ctx.moveTo(b.x + 2, b.y + 1);
        ctx.lineTo(b.x + 5, b.y + 2);
        ctx.stroke();
        clearGlow(ctx);
      }
    }
  }

  // Dragons
  for (const d of dragons) {
    if (!d.alive) continue;
    const screenX = d.x - camX;
    if (screenX < -100 || screenX > W + 100) continue;
    drawDragon(ctx, d);
  }

  // Submarines
  for (const sub of submarines) {
    if (!sub.alive) continue;
    const screenX = sub.x - camX;
    if (screenX < -80 || screenX > W + 80) continue;
    drawSubmarine(sub);
  }

  // Bombs & Torpedoes
  for (const b of bombs) {
    const screenX = b.x - camX;
    if (screenX < -50 || screenX > W + 50) continue;
    if (b.isTorpedo) {
      // Torpedo: elongated shape traveling horizontally at water surface
      neonGlow(ctx, '#f55', 6);
      ctx.strokeStyle = '#f55';
      ctx.lineWidth = 1.5;
      const dir = b.vx > 0 ? 1 : -1;
      ctx.beginPath();
      ctx.moveTo(b.x - dir * 8, b.y);
      ctx.lineTo(b.x + dir * 8, b.y);
      ctx.lineTo(b.x + dir * 10, b.y - 1);
      ctx.stroke();
      // Wake trail
      addParticle(b.x - dir * 10, b.y, -dir * 15, (Math.random() - 0.5) * 5, 0.2, '#fff', 1);
      clearGlow(ctx);
    } else {
      const bombCol = b.friendly === false ? '#f55' : '#fa0';
      neonGlow(ctx, bombCol, 6);
      ctx.fillStyle = bombCol;
      ctx.beginPath();
      ctx.arc(b.x, b.y, 4, 0, Math.PI * 2);
      ctx.fill();
      clearGlow(ctx);
      addParticle(b.x, b.y - 2, 0, -10, 0.15, b.friendly === false ? '#f55' : '#f80', 1);
    }
  }

  // Flak shots
  for (const f of flakShots) {
    neonGlow(ctx, '#f80', 6);
    ctx.fillStyle = '#ff0';
    ctx.beginPath();
    ctx.arc(f.x, f.y, 3, 0, Math.PI * 2);
    ctx.fill();
    clearGlow(ctx);
  }

  // Bullets
  for (const b of bullets) {
    const screenX = b.x - camX;
    if (screenX < -50 || screenX > W + 50) continue;
    const col = b.friendly ? '#0ff' : '#f55';
    neonGlow(ctx, col, 4);
    ctx.fillStyle = col;
    ctx.beginPath();
    ctx.arc(b.x, b.y, 2, 0, Math.PI * 2);
    ctx.fill();
    clearGlow(ctx);
  }

  // Enemies (dispatch by type)
  // Enemies — compute facingLeft from angle to prevent upside-down rendering
  for (const en of enemies) {
    if (!en.alive || en.state === 'hangar') continue;
    const screenX = en.x - camX;
    const margin = en.type === 'zeppelin' ? 150 : 100;
    if (screenX < -margin || screenX > W + margin) continue;
    const spec = ENEMY_SPECS[en.type];
    // Normalize angle to [-PI, PI]
    let a = en.angle;
    while (a > Math.PI) a -= Math.PI * 2;
    while (a < -Math.PI) a += Math.PI * 2;
    // If flying left (angle > 90° or < -90°), flip horizontally and mirror the rotation
    const flyingLeft = Math.abs(a) > Math.PI / 2;
    const drawAngle = flyingLeft ? (a > 0 ? a - Math.PI : a + Math.PI) : a;
    if (en.type === 'jet') {
      drawJet(ctx, en.x, en.y, drawAngle, flyingLeft, spec.color);
    } else if (en.type === 'bomber') {
      drawBomber(ctx, en.x, en.y, drawAngle, flyingLeft, spec.color);
    } else if (en.type === 'zeppelin') {
      drawZeppelin(ctx, en.x, en.y, drawAngle, flyingLeft, spec.color);
    } else {
      drawBiplane(ctx, en.x, en.y, drawAngle, flyingLeft, spec.color, undefined, false);
    }
  }

  // Player
  if (state === ST.PLAYING) {
    if (player.invincible <= 0 || Math.sin(Date.now() * 0.02) > 0) {
      // Same approach as enemies: extract facingLeft from radian angle, mirror rotation
      let pRad = getPlaneRadians(player);
      while (pRad > Math.PI) pRad -= Math.PI * 2;
      while (pRad < -Math.PI) pRad += Math.PI * 2;
      const pFacingLeft = Math.abs(pRad) > Math.PI / 2;
      const pDrawAngle = pFacingLeft ? (pRad > 0 ? pRad - Math.PI : pRad + Math.PI) : pRad;
      // Color changes with damage: cyan → yellow → red → burning
      let pColor = '#0ff';
      if (player.burning && player.engineOut) pColor = '#888';
      else if (player.burning) pColor = '#f44';
      else if (player.hp === 2) pColor = '#ff0';
      else if (player.hp <= 1) pColor = '#f80';
      // Low fuel flashing — red pulse when below 15%
      const fuelRatio = player.fuel / MAX_FUEL;
      if (!player.burning && fuelRatio < 0.15 && fuelRatio > 0) {
        if (Math.sin(Date.now() * 0.01) > 0) pColor = '#f22';
      }
      // Hit flash override
      if (player.hitFlash > 0) pColor = '#fff';
      drawBiplane(ctx, player.x, player.y, pDrawAngle, pFacingLeft, pColor, undefined, player.orient);
    }
  }

  // Parachutes
  for (const chute of parachutes) {
    const screenX = chute.x - camX;
    if (screenX < -50 || screenX > W + 50) continue;
    if (chute.deployed && !chute.landed) {
      // Draw parachute canopy
      neonGlow(ctx, '#fff', 6);
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(chute.x, chute.y - 12, 8, Math.PI, 0);
      ctx.stroke();
      // Suspension lines
      ctx.beginPath();
      ctx.moveTo(chute.x - 7, chute.y - 10);
      ctx.lineTo(chute.x, chute.y);
      ctx.moveTo(chute.x + 7, chute.y - 10);
      ctx.lineTo(chute.x, chute.y);
      ctx.stroke();
      clearGlow(ctx);
    }
    // Pilot figure (tiny stick person)
    neonGlow(ctx, '#0ff', 4);
    ctx.strokeStyle = '#0ff';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(chute.x, chute.y - 3, 2, 0, Math.PI * 2); // head
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(chute.x, chute.y - 1);
    ctx.lineTo(chute.x, chute.y + 4); // body
    ctx.moveTo(chute.x - 3, chute.y + 1);
    ctx.lineTo(chute.x + 3, chute.y + 1); // arms
    if (chute.landed) {
      ctx.moveTo(chute.x, chute.y + 4);
      ctx.lineTo(chute.x - 2, chute.y + 7); // legs standing
      ctx.moveTo(chute.x, chute.y + 4);
      ctx.lineTo(chute.x + 2, chute.y + 7);
    } else {
      ctx.moveTo(chute.x, chute.y + 4);
      ctx.lineTo(chute.x - 3, chute.y + 7); // legs dangling
      ctx.moveTo(chute.x, chute.y + 4);
      ctx.lineTo(chute.x + 3, chute.y + 7);
    }
    ctx.stroke();
    clearGlow(ctx);
  }

  // Particles
  for (const p of particles) {
    const alpha = p.life / p.maxLife;
    ctx.globalAlpha = alpha;
    ctx.fillStyle = p.color;
    neonGlow(ctx, p.color, 4);
    ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
    clearGlow(ctx);
  }
  ctx.globalAlpha = 1;

  ctx.restore();

  // ── Overlays ──
  if (state === ST.DYING) {
    ctx.fillStyle = `rgba(255, 50, 0, ${0.3 * (deathTimer / 2)})`;
    ctx.fillRect(0, 0, W, H);
    ctx.fillStyle = '#fff';
    ctx.font = '24px "Courier New", monospace';
    ctx.textAlign = 'center';
    ctx.fillText(lives > 0 ? 'PLANE DESTROYED' : 'GAME OVER', W / 2, H / 2);
  }

  if (state === ST.GAME_OVER) {
    ctx.fillStyle = 'rgba(0,0,0,0.7)';
    ctx.fillRect(0, 0, W, H);
    neonGlow(ctx, '#f55', 12);
    ctx.fillStyle = '#f55';
    ctx.font = 'bold 36px "Courier New", monospace';
    ctx.textAlign = 'center';
    ctx.fillText('GAME OVER', W / 2, H / 2 - 30);
    clearGlow(ctx);
    ctx.fillStyle = '#888';
    ctx.font = '16px "Courier New", monospace';
    ctx.fillText(`FINAL SCORE: ${score}`, W / 2, H / 2 + 10);
    ctx.fillText('Press ENTER to restart', W / 2, H / 2 + 40);
  }

  if (state === ST.LEVEL_COMPLETE) {
    neonGlow(ctx, '#0f0', 12);
    ctx.fillStyle = '#0f0';
    ctx.font = 'bold 30px "Courier New", monospace';
    ctx.textAlign = 'center';
    ctx.fillText(`LEVEL ${level} COMPLETE!`, W / 2, H / 2 - 10);
    clearGlow(ctx);
    ctx.fillStyle = '#0ff';
    ctx.font = '16px "Courier New", monospace';
    ctx.fillText(`+${1000 * level} bonus points`, W / 2, H / 2 + 20);
  }

  // ── Extra life / last chance messages ──
  if (extraLifeMsg > 0) {
    extraLifeMsg -= 0.016;
    const alpha = Math.min(1, extraLifeMsg / 0.5);
    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    neonGlow(ctx, '#0f0', 10);
    ctx.fillStyle = `rgba(0, 255, 0, ${alpha})`;
    ctx.font = 'bold 22px "Courier New", monospace';
    ctx.textAlign = 'center';
    ctx.fillText('+1 LIFE!', W / 2, H / 2 + 50);
    clearGlow(ctx);
    ctx.restore();
  }
  if (lastChanceMsg > 0) {
    lastChanceMsg -= 0.016;
    const alpha = Math.min(1, lastChanceMsg / 0.5);
    const flash = Math.sin(Date.now() * 0.01) > 0 ? 1 : 0.4;
    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    neonGlow(ctx, '#f22', 14);
    ctx.fillStyle = `rgba(255, 40, 40, ${alpha * flash})`;
    ctx.font = 'bold 28px "Courier New", monospace';
    ctx.textAlign = 'center';
    ctx.fillText('LAST CHANCE', W / 2, H / 2);
    clearGlow(ctx);
    ctx.restore();
  }

  // Top strip radar
  drawRadar();

  // Circular radar scope (HUD overlay)
  if (state === ST.PLAYING || state === ST.LEVEL_COMPLETE) {
    drawRadarScope(W, H);
    drawCockpitGauges(W, H);
  }

  // Version tag — bottom left
  ctx.save();
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.fillStyle = 'rgba(0, 255, 255, 0.5)';
  ctx.font = '12px "Courier New", monospace';
  ctx.textAlign = 'left';
  ctx.fillText('v' + GAME_VERSION, 8, canvas.height - 8);
  ctx.restore();
}

function drawTerrain(W, H) {
  const startX = Math.max(0, Math.floor(camX) - 2);
  const endX = Math.min(WORLD_W - 1, Math.floor(camX + W) + 2);
  const terrainBottom = camY + H + 50;
  const isSea = getLevelTheme(level) === 'sea';

  // Filled terrain
  ctx.fillStyle = isSea ? '#0a1a2a' : '#0d1a0d';
  ctx.beginPath();
  ctx.moveTo(startX, terrainBottom);
  for (let x = startX; x <= endX; x += 2) {
    let ty = terrain[x];
    // Animated wave effect for sea levels on water areas
    if (isSea && ty >= waterLineY - 5) {
      ty += Math.sin(Date.now() * 0.003 + x * 0.02) * 2 + Math.sin(Date.now() * 0.005 + x * 0.04) * 1;
    }
    ctx.lineTo(x, ty);
  }
  ctx.lineTo(endX, terrainBottom);
  ctx.closePath();
  ctx.fill();

  // Terrain line (color depends on theme)
  if (isSea) {
    // Draw different colors for water vs island terrain
    // First pass: water areas (blue)
    neonGlow(ctx, '#0af', 8);
    ctx.strokeStyle = '#0af';
    ctx.lineWidth = 2;
    ctx.beginPath();
    let inWater = true;
    for (let x = startX; x <= endX; x += 2) {
      let ty = terrain[x];
      const isWaterHere = ty >= waterLineY - 10;
      if (isWaterHere) {
        ty += Math.sin(Date.now() * 0.003 + x * 0.02) * 2 + Math.sin(Date.now() * 0.005 + x * 0.04) * 1;
      }
      if (x === startX || (isWaterHere !== inWater)) {
        ctx.moveTo(x, ty);
        inWater = isWaterHere;
      } else if (isWaterHere) {
        ctx.lineTo(x, ty);
      }
    }
    ctx.stroke();
    clearGlow(ctx);

    // Second pass: island terrain (green)
    neonGlow(ctx, '#0f8', 8);
    ctx.strokeStyle = '#0fa';
    ctx.lineWidth = 2;
    ctx.beginPath();
    let onIsland = false;
    for (let x = startX; x <= endX; x += 2) {
      const ty = terrain[x];
      const isIslandHere = ty < waterLineY - 10;
      if (x === startX || (isIslandHere !== onIsland)) {
        ctx.moveTo(x, ty);
        onIsland = isIslandHere;
      } else if (isIslandHere) {
        ctx.lineTo(x, ty);
      }
    }
    ctx.stroke();
    clearGlow(ctx);

    // Thin highlight line on water surface
    ctx.strokeStyle = 'rgba(100, 200, 255, 0.3)';
    ctx.lineWidth = 0.5;
    ctx.beginPath();
    for (let x = startX; x <= endX; x += 4) {
      if (terrain[x] >= waterLineY - 5) {
        const wy = terrain[x] + Math.sin(Date.now() * 0.003 + x * 0.02) * 2;
        if (x === startX) ctx.moveTo(x, wy);
        else ctx.lineTo(x, wy);
      }
    }
    ctx.stroke();
  } else {
    // Land theme: standard green terrain
    neonGlow(ctx, '#0f8', 8);
    ctx.strokeStyle = '#0fa';
    ctx.lineWidth = 2;
    ctx.beginPath();
    for (let x = startX; x <= endX; x += 2) {
      if (x === startX) ctx.moveTo(x, terrain[x]);
      else ctx.lineTo(x, terrain[x]);
    }
    ctx.stroke();

    // Second glow line (brighter, thinner)
    ctx.strokeStyle = '#5ff';
    ctx.lineWidth = 0.5;
    ctx.beginPath();
    for (let x = startX; x <= endX; x += 2) {
      if (x === startX) ctx.moveTo(x, terrain[x]);
      else ctx.lineTo(x, terrain[x]);
    }
    ctx.stroke();
    clearGlow(ctx);
  }
}

// ── Ground crew state ──
let groundCrewTimer = 0;
let refuelStage = 0; // 0=refueling, 1=ready

function drawBase() {
  const levelTheme = getLevelTheme(level);
  if (levelTheme === 'sea') {
    drawCarrier();
    return;
  }
  drawLandBase();
}

function drawLandBase() {
  const by = getTerrainY(baseX + BASE_WIDTH / 2);

  // ── Runway ──
  neonGlow(ctx, '#0af', 6);
  ctx.strokeStyle = '#0af';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(baseX, by);
  ctx.lineTo(baseX + BASE_WIDTH, by);
  ctx.stroke();

  // Dashes
  ctx.strokeStyle = '#05a';
  ctx.lineWidth = 1;
  ctx.setLineDash([8, 8]);
  ctx.beginPath();
  ctx.moveTo(baseX + 10, by - 3);
  ctx.lineTo(baseX + BASE_WIDTH - 10, by - 3);
  ctx.stroke();
  ctx.setLineDash([]);

  const dimCyan = 'rgba(0, 170, 255, 0.35)';
  const dimCyanStroke = 'rgba(0, 170, 255, 0.5)';

  // ── Hangar (left of runway) ──
  const hangarX = baseX - 55;
  neonGlow(ctx, '#0af', 3);
  ctx.strokeStyle = dimCyanStroke;
  ctx.lineWidth = 1;
  // Rectangle base
  ctx.strokeRect(hangarX, by - 22, 40, 22);
  // Peaked roof
  ctx.beginPath();
  ctx.moveTo(hangarX, by - 22);
  ctx.lineTo(hangarX + 20, by - 32);
  ctx.lineTo(hangarX + 40, by - 22);
  ctx.stroke();
  // Door opening
  ctx.beginPath();
  ctx.arc(hangarX + 20, by, 12, Math.PI, 0);
  ctx.stroke();

  // ── Fuel storage (near runway, right-ish) ──
  const fuelX = baseX + BASE_WIDTH + 15;
  ctx.strokeStyle = dimCyanStroke;
  // Cylindrical tank
  ctx.beginPath();
  ctx.arc(fuelX + 10, by, 10, Math.PI, 0);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(fuelX, by);
  ctx.lineTo(fuelX + 20, by);
  ctx.stroke();
  // Small pipe toward runway
  ctx.beginPath();
  ctx.moveTo(fuelX, by - 2);
  ctx.lineTo(baseX + BASE_WIDTH, by - 2);
  ctx.stroke();

  // ── Control tower (right side) ──
  const towerX = baseX + BASE_WIDTH + 45;
  ctx.strokeStyle = dimCyanStroke;
  // Tower body
  ctx.strokeRect(towerX, by - 40, 12, 40);
  // Observation room (wider top)
  ctx.strokeRect(towerX - 4, by - 48, 20, 8);
  // Antenna
  ctx.beginPath();
  ctx.moveTo(towerX + 6, by - 48);
  ctx.lineTo(towerX + 6, by - 56);
  ctx.stroke();
  // Antenna cross-piece
  ctx.beginPath();
  ctx.moveTo(towerX + 2, by - 54);
  ctx.lineTo(towerX + 10, by - 54);
  ctx.stroke();

  // ── Barracks (far right) ──
  const barracksX = baseX + BASE_WIDTH + 70;
  ctx.strokeStyle = dimCyanStroke;
  ctx.strokeRect(barracksX, by - 14, 25, 14);
  ctx.strokeRect(barracksX + 30, by - 12, 20, 12);
  // Windows (small dots)
  ctx.fillStyle = dimCyan;
  for (let wx = barracksX + 5; wx < barracksX + 25; wx += 7) {
    ctx.fillRect(wx, by - 10, 3, 3);
  }

  // ── Windsock (animated, on a pole) ──
  const sockX = baseX - 15;
  ctx.strokeStyle = dimCyanStroke;
  ctx.beginPath();
  ctx.moveTo(sockX, by);
  ctx.lineTo(sockX, by - 20);
  ctx.stroke();
  // Sock flag (sin-based flutter)
  const sockFlutter = Math.sin(Date.now() * 0.005) * 3;
  const sockFlutter2 = Math.sin(Date.now() * 0.007 + 1) * 2;
  ctx.strokeStyle = 'rgba(255, 150, 0, 0.5)';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(sockX, by - 20);
  ctx.quadraticCurveTo(sockX + 8 + sockFlutter, by - 19 + sockFlutter2, sockX + 14 + sockFlutter, by - 18);
  ctx.stroke();

  clearGlow(ctx);

  // ── Label ──
  neonGlow(ctx, '#0af', 6);
  ctx.fillStyle = '#0af';
  ctx.font = '10px "Courier New", monospace';
  ctx.textAlign = 'center';
  ctx.fillText('HOME BASE', baseX + BASE_WIDTH / 2, by - 10);
  clearGlow(ctx);

  // ── Ground crew when landed ──
  if (player.landed && state === ST.PLAYING) {
    groundCrewTimer += 0.016; // approximate dt
    drawGroundCrew(by);
  } else {
    groundCrewTimer = 0;
    refuelStage = 0;
  }
}

// ── Searchlights from home base ──
function drawSearchlights() {
  const homeX = baseX + BASE_WIDTH / 2;
  const homeY = getTerrainY(homeX);
  const t = Date.now() * 0.001;
  const p = player;

  const playerDist = Math.sqrt((p.x - homeX) ** 2 + (p.y - homeY) ** 2);
  if (p.autopilot && state === ST.PLAYING && playerDist <= 400) {
    // Tractor beam mode: two beams lock onto the player (only within capture range)
    const dx = p.x - homeX;
    const dy = p.y - homeY;
    const angle = Math.atan2(dy, dx);

    // Draw two converging beams from base to player
    for (let beam = -1; beam <= 1; beam += 2) {
      const beamOriginX = homeX + beam * 30;
      const beamOriginY = homeY - 5;
      const dist = Math.sqrt((p.x - beamOriginX) ** 2 + (p.y - beamOriginY) ** 2);

      ctx.save();
      // Beam cone with gradient
      const grad = ctx.createLinearGradient(beamOriginX, beamOriginY, p.x, p.y);
      grad.addColorStop(0, 'rgba(0, 255, 255, 0.25)');
      grad.addColorStop(0.6, 'rgba(0, 200, 255, 0.08)');
      grad.addColorStop(1, 'rgba(0, 255, 255, 0.02)');

      const coneAngle = Math.atan2(p.y - beamOriginY, p.x - beamOriginX);
      const spread = 0.06; // narrow beam

      ctx.beginPath();
      ctx.moveTo(beamOriginX, beamOriginY);
      ctx.lineTo(p.x + Math.cos(coneAngle + spread) * 20, p.y + Math.sin(coneAngle + spread) * 20);
      ctx.lineTo(p.x + Math.cos(coneAngle - spread) * 20, p.y + Math.sin(coneAngle - spread) * 20);
      ctx.closePath();
      ctx.fillStyle = grad;
      ctx.fill();

      // Bright center line
      ctx.strokeStyle = 'rgba(0, 255, 255, 0.15)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(beamOriginX, beamOriginY);
      ctx.lineTo(p.x, p.y);
      ctx.stroke();
      ctx.restore();
    }

    // Glow circle around player when captured
    const captureRadius = Math.sqrt((p.x - homeX) ** 2 + (p.y - homeY) ** 2);
    if (captureRadius < 400) {
      const glowAlpha = 0.15 * (1 - captureRadius / 400);
      ctx.beginPath();
      ctx.arc(p.x, p.y, 20 + Math.sin(t * 5) * 3, 0, Math.PI * 2);
      ctx.strokeStyle = `rgba(0, 255, 255, ${glowAlpha + 0.1})`;
      ctx.lineWidth = 2;
      neonGlow(ctx, '#0ff', 8);
      ctx.stroke();
      clearGlow(ctx);
    }
  } else if (state === ST.PLAYING && !p.landed) {
    // Idle sweep mode: two searchlights slowly sweep the sky
    for (let beam = -1; beam <= 1; beam += 2) {
      const beamOriginX = homeX + beam * 25;
      const beamOriginY = homeY - 5;
      // Sweep angle: oscillates back and forth
      const sweepAngle = -Math.PI / 2 + Math.sin(t * 0.4 + beam * 1.5) * 0.8;
      const beamLen = 400;
      const endX = beamOriginX + Math.cos(sweepAngle) * beamLen;
      const endY = beamOriginY + Math.sin(sweepAngle) * beamLen;
      const spread = 0.08;

      ctx.save();
      const grad = ctx.createLinearGradient(beamOriginX, beamOriginY, endX, endY);
      grad.addColorStop(0, 'rgba(0, 200, 255, 0.12)');
      grad.addColorStop(0.5, 'rgba(0, 200, 255, 0.04)');
      grad.addColorStop(1, 'rgba(0, 200, 255, 0)');

      ctx.beginPath();
      ctx.moveTo(beamOriginX, beamOriginY);
      ctx.lineTo(endX + Math.cos(sweepAngle + spread) * 40, endY + Math.sin(sweepAngle + spread) * 40);
      ctx.lineTo(endX + Math.cos(sweepAngle - spread) * 40, endY + Math.sin(sweepAngle - spread) * 40);
      ctx.closePath();
      ctx.fillStyle = grad;
      ctx.fill();
      ctx.restore();
    }
  }
}

function drawGroundCrew(groundY) {
  const crewColor = '#0af';
  const px = player.x;
  const py = player.y;

  // Crew member 1: near nose (fueling)
  const c1x = px + 22;
  const c1y = groundY;
  const armAnim1 = Math.sin(groundCrewTimer * 6) * 2;
  drawCrewPerson(c1x, c1y, crewColor, armAnim1, Math.sin(groundCrewTimer * 4) * 1.5);

  // Crew member 2: near wing (loading bombs)
  const c2x = px - 15;
  const c2y = groundY;
  const armAnim2 = Math.sin(groundCrewTimer * 5 + 1) * 2;
  drawCrewPerson(c2x, c2y, crewColor, armAnim2, Math.sin(groundCrewTimer * 3 + 2) * 1.5);
  // Small bomb box being carried
  ctx.fillStyle = 'rgba(255, 170, 0, 0.4)';
  ctx.fillRect(c2x - 3 + armAnim2, c2y - 5 + Math.abs(armAnim2) * 0.3, 3, 3);

  // Crew member 3: at tail (inspection)
  const c3x = px - 28;
  const c3y = groundY;
  const armAnim3 = Math.sin(groundCrewTimer * 3 + 3) * 1.5;
  drawCrewPerson(c3x, c3y, crewColor, armAnim3, Math.sin(groundCrewTimer * 2 + 1));

  // Fuel pump animation (pulsing line from fuel tank to plane)
  const fuelX = baseX + BASE_WIDTH + 15;
  if (groundCrewTimer < 1.5) {
    const pulseAlpha = 0.3 + 0.3 * Math.sin(groundCrewTimer * 8);
    ctx.strokeStyle = `rgba(0, 170, 255, ${pulseAlpha})`;
    ctx.lineWidth = 1;
    ctx.setLineDash([4, 4]);
    ctx.beginPath();
    ctx.moveTo(fuelX, groundY - 3);
    ctx.lineTo(px + 10, py + 5);
    ctx.stroke();
    ctx.setLineDash([]);
  }

  // Status text
  neonGlow(ctx, '#0af', 4);
  ctx.font = '9px "Courier New", monospace';
  ctx.textAlign = 'center';
  if (groundCrewTimer < 1.2) {
    const alpha = 0.5 + 0.3 * Math.sin(groundCrewTimer * 6);
    ctx.globalAlpha = alpha;
    ctx.fillStyle = '#0af';
    ctx.fillText('REFUELING...', baseX + BASE_WIDTH / 2, groundY - 22);
    ctx.globalAlpha = 1;
  } else {
    ctx.fillStyle = '#0f0';
    ctx.fillText('READY', baseX + BASE_WIDTH / 2, groundY - 22);
  }
  clearGlow(ctx);
}

function drawCrewPerson(x, y, color, armAnim, legAnim) {
  neonGlow(ctx, color, 3);
  ctx.strokeStyle = color;
  ctx.lineWidth = 1;
  // Head
  ctx.beginPath();
  ctx.arc(x, y - 7, 1.5, 0, Math.PI * 2);
  ctx.stroke();
  // Body
  ctx.beginPath();
  ctx.moveTo(x, y - 5.5);
  ctx.lineTo(x, y - 2);
  ctx.stroke();
  // Arms
  ctx.beginPath();
  ctx.moveTo(x - 2 - armAnim, y - 5);
  ctx.lineTo(x, y - 4);
  ctx.lineTo(x + 2 + armAnim, y - 5);
  ctx.stroke();
  // Legs
  ctx.beginPath();
  ctx.moveTo(x - 1.5 - legAnim, y);
  ctx.lineTo(x, y - 2);
  ctx.lineTo(x + 1.5 + legAnim, y);
  ctx.stroke();
  clearGlow(ctx);
}

function drawCarrier() {
  const deckY = getTerrainY(baseX + BASE_WIDTH / 2);
  const carrierLeft = baseX - 60;
  const carrierRight = baseX + BASE_WIDTH + 60;
  const carrierW = carrierRight - carrierLeft;

  neonGlow(ctx, '#0af', 6);
  ctx.strokeStyle = '#0af';
  ctx.lineWidth = 2;

  // ── Hull shape: angled bow, flat deck, stern ──
  ctx.beginPath();
  // Bow (left side, pointed)
  ctx.moveTo(carrierLeft - 20, deckY + 8);
  ctx.lineTo(carrierLeft, deckY);
  // Flat deck
  ctx.lineTo(carrierRight, deckY);
  // Stern (right side, squared)
  ctx.lineTo(carrierRight + 5, deckY + 4);
  ctx.lineTo(carrierRight + 5, deckY + 12);
  // Hull bottom
  ctx.lineTo(carrierLeft - 15, deckY + 12);
  ctx.closePath();
  ctx.stroke();

  // Hull waterline
  ctx.strokeStyle = 'rgba(0, 170, 255, 0.3)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(carrierLeft - 15, deckY + 8);
  ctx.lineTo(carrierRight + 5, deckY + 8);
  ctx.stroke();

  // ── Deck markings: landing stripes ──
  ctx.strokeStyle = '#05a';
  ctx.lineWidth = 1;
  ctx.setLineDash([10, 10]);
  ctx.beginPath();
  ctx.moveTo(baseX + 10, deckY - 2);
  ctx.lineTo(baseX + BASE_WIDTH - 10, deckY - 2);
  ctx.stroke();
  ctx.setLineDash([]);

  // Runway center line
  ctx.strokeStyle = '#0af';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(baseX, deckY);
  ctx.lineTo(baseX + BASE_WIDTH, deckY);
  ctx.stroke();

  // Deck edge markings (short perpendicular lines)
  ctx.strokeStyle = 'rgba(0, 170, 255, 0.4)';
  ctx.lineWidth = 1;
  for (let mx = carrierLeft + 15; mx < carrierRight - 10; mx += 25) {
    ctx.beginPath();
    ctx.moveTo(mx, deckY);
    ctx.lineTo(mx, deckY - 3);
    ctx.stroke();
  }

  // ── Control tower / island superstructure (right side) ──
  const islandX = carrierRight - 30;
  ctx.strokeStyle = 'rgba(0, 170, 255, 0.5)';
  ctx.lineWidth = 1;
  // Main tower body
  ctx.strokeRect(islandX, deckY - 35, 20, 35);
  // Bridge windows (top row)
  ctx.fillStyle = 'rgba(0, 255, 255, 0.4)';
  ctx.fillRect(islandX + 3, deckY - 32, 4, 3);
  ctx.fillRect(islandX + 9, deckY - 32, 4, 3);
  // Lower windows
  ctx.fillStyle = 'rgba(0, 255, 255, 0.2)';
  ctx.fillRect(islandX + 3, deckY - 22, 4, 3);
  ctx.fillRect(islandX + 9, deckY - 22, 4, 3);
  // Mast/antenna
  ctx.strokeStyle = 'rgba(0, 170, 255, 0.6)';
  ctx.beginPath();
  ctx.moveTo(islandX + 10, deckY - 35);
  ctx.lineTo(islandX + 10, deckY - 52);
  ctx.stroke();
  // Radar dish (rotating)
  const dishAng = (Date.now() * 0.003) % (Math.PI * 2);
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.arc(islandX + 10, deckY - 52, 6, dishAng, dishAng + Math.PI * 0.5);
  ctx.stroke();
  // Blinking light on top
  const blink = Math.sin(Date.now() * 0.005) > 0;
  if (blink) {
    ctx.fillStyle = '#f00';
    ctx.beginPath();
    ctx.arc(islandX + 10, deckY - 53, 1.5, 0, Math.PI * 2);
    ctx.fill();
  }

  // ── Machine gun turrets (fore and aft) ──
  ctx.strokeStyle = 'rgba(0, 170, 255, 0.6)';
  ctx.lineWidth = 1;
  // Forward gun (left/bow)
  const gunY = deckY - 5;
  const fGunX = carrierLeft + 10;
  // Gun base (small circle)
  ctx.beginPath();
  ctx.arc(fGunX, gunY, 3, 0, Math.PI * 2);
  ctx.stroke();
  // Gun barrel (sweeps slowly)
  const fGunAng = -Math.PI / 2 + Math.sin(Date.now() * 0.001) * 0.6;
  ctx.beginPath();
  ctx.moveTo(fGunX, gunY);
  ctx.lineTo(fGunX + Math.cos(fGunAng) * 8, gunY + Math.sin(fGunAng) * 8);
  ctx.stroke();
  // Aft gun (right/stern)
  const aGunX = carrierRight - 40;
  ctx.beginPath();
  ctx.arc(aGunX, gunY, 3, 0, Math.PI * 2);
  ctx.stroke();
  const aGunAng = -Math.PI / 2 + Math.sin(Date.now() * 0.0012 + 2) * 0.6;
  ctx.beginPath();
  ctx.moveTo(aGunX, gunY);
  ctx.lineTo(aGunX + Math.cos(aGunAng) * 8, gunY + Math.sin(aGunAng) * 8);
  ctx.stroke();

  // ── Windsock on control tower ──
  const wsX = islandX + 18;
  const wsY = deckY - 38;
  ctx.strokeStyle = 'rgba(255, 100, 0, 0.5)';
  ctx.lineWidth = 1;
  // Pole
  ctx.beginPath();
  ctx.moveTo(wsX, deckY);
  ctx.lineTo(wsX, wsY);
  ctx.stroke();
  // Sock (flutters in wind)
  const wsFlutter = Math.sin(Date.now() * 0.008) * 2;
  ctx.strokeStyle = 'rgba(255, 120, 0, 0.6)';
  ctx.beginPath();
  ctx.moveTo(wsX, wsY);
  ctx.quadraticCurveTo(wsX + 6, wsY + wsFlutter, wsX + 12, wsY + 1 + wsFlutter);
  ctx.stroke();

  // ── Fuel lines on deck ──
  ctx.strokeStyle = 'rgba(0, 200, 100, 0.2)';
  ctx.lineWidth = 1;
  ctx.setLineDash([3, 5]);
  ctx.beginPath();
  ctx.moveTo(islandX, deckY - 2);
  ctx.lineTo(baseX + BASE_WIDTH / 2, deckY - 2);
  ctx.stroke();
  ctx.setLineDash([]);

  // ── Wake: animated white particles trailing behind carrier ──
  if (Math.random() < 0.3) {
    const wakeX = carrierRight + 5 + Math.random() * 30;
    const wakeY = deckY + 10 + Math.random() * 4;
    addParticle(wakeX, wakeY, 15 + Math.random() * 10, (Math.random() - 0.5) * 5, 0.4 + Math.random() * 0.3, '#fff', 1.5);
  }

  clearGlow(ctx);

  // ── Label ──
  neonGlow(ctx, '#0af', 6);
  ctx.fillStyle = '#0af';
  ctx.font = '10px "Courier New", monospace';
  ctx.textAlign = 'center';
  ctx.fillText('CARRIER', baseX + BASE_WIDTH / 2, deckY - 10);
  clearGlow(ctx);

  // ── Ground crew when landed (reuse same crew on carrier deck) ──
  if (player.landed && state === ST.PLAYING) {
    groundCrewTimer += 0.016;
    drawGroundCrew(deckY);
  } else {
    groundCrewTimer = 0;
    refuelStage = 0;
  }
}

// ── Submarine spawning & logic ──
function spawnSubmarines() {
  submarines = [];
  if (getLevelTheme(level) !== 'sea') return;
  const count = 1 + Math.floor(level / 2);
  for (let i = 0; i < count; i++) {
    // Spawn in water areas (away from islands and carrier)
    let sx;
    let attempts = 0;
    do {
      sx = 500 + Math.random() * (WORLD_W - 1000);
      attempts++;
    } while (attempts < 20 && (
      Math.abs(sx - baseX - BASE_WIDTH / 2) < 600 ||
      islandPeaks.some(ip => Math.abs(sx - ip.cx) < ip.w / 2 + 100)
    ));

    submarines.push({
      x: sx,
      y: waterLineY - 4,
      vx: (Math.random() < 0.5 ? 1 : -1) * (15 + Math.random() * 10),
      alive: true,
      hp: 6,
      surfaced: true,
      surfaceTimer: 5 + Math.random() * 5,
      gunTimer: 0,
      submergeDepth: 0, // 0 = surfaced, 1 = fully submerged
      phase: 'surfaced' // surfaced, submerging, submerged, surfacing
    });
  }
}

function updateSubmarines(dt) {
  for (const sub of submarines) {
    if (!sub.alive) continue;

    // Movement
    sub.x += sub.vx * dt;
    if (sub.x < 200) { sub.x = 200; sub.vx = Math.abs(sub.vx); }
    if (sub.x >= WORLD_W - 200) { sub.x = WORLD_W - 200; sub.vx = -Math.abs(sub.vx); }

    // Surface/submerge cycle with smooth animation
    sub.surfaceTimer -= dt;
    if (sub.surfaceTimer <= 0) {
      if (sub.phase === 'surfaced') {
        sub.phase = 'submerging';
        sub.surfaceTimer = 2; // time to submerge
      } else if (sub.phase === 'submerging') {
        sub.phase = 'submerged';
        sub.surfaced = false;
        sub.surfaceTimer = 4 + Math.random() * 5; // time underwater
      } else if (sub.phase === 'submerged') {
        sub.phase = 'surfacing';
        sub.surfaceTimer = 2; // time to surface
      } else if (sub.phase === 'surfacing') {
        sub.phase = 'surfaced';
        sub.surfaced = true;
        sub.surfaceTimer = 5 + Math.random() * 5; // time on surface
      }
    }

    // Smooth submerge depth
    if (sub.phase === 'submerging') {
      sub.submergeDepth = Math.min(1, sub.submergeDepth + dt * 0.5);
    } else if (sub.phase === 'surfacing') {
      sub.submergeDepth = Math.max(0, sub.submergeDepth - dt * 0.5);
    } else if (sub.phase === 'submerged') {
      sub.submergeDepth = 1;
    } else {
      sub.submergeDepth = 0;
    }

    // Position: sink below water when submerging
    sub.y = waterLineY - 4 + sub.submergeDepth * 30;

    // Machine gun tower — fire bullets when surfaced or surfacing
    if (sub.surfaced || sub.phase === 'surfacing') {
      sub.gunTimer -= dt;
      if (sub.gunTimer <= 0) {
        const dx = player.x - sub.x;
        const dy = player.y - sub.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < 700 && player.y < sub.y) {
          // Fire toward player with spread
          const aimAngle = Math.atan2(dy, dx) + (Math.random() - 0.5) * 0.3;
          bullets.push({
            x: sub.x, y: sub.y - 18 - (1 - sub.submergeDepth) * 10,
            vx: Math.cos(aimAngle) * 300,
            vy: Math.sin(aimAngle) * 300,
            life: 2, friendly: false
          });
          sub.gunTimer = 0.4 + Math.random() * 0.3;
        } else {
          sub.gunTimer = 0.5;
        }
      }
    }
  }
}

function drawSubmarine(sub) {
  const depth = sub.submergeDepth || 0;
  const alpha = 1.0 - depth * 0.7;
  ctx.globalAlpha = alpha;

  neonGlow(ctx, '#48f', 6);
  ctx.strokeStyle = '#48f';
  ctx.lineWidth = 1.5;

  const sx = sub.x;
  const sy = sub.y;
  const dir = sub.vx >= 0 ? 1 : -1;

  // Hull (large elongated oval)
  ctx.beginPath();
  ctx.ellipse(sx, sy + 5, 50, 12, 0, 0, Math.PI * 2);
  ctx.stroke();

  // Deck line
  ctx.beginPath();
  ctx.moveTo(sx - 45, sy);
  ctx.lineTo(sx + 45, sy);
  ctx.stroke();

  // Bow and stern detail
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(sx + dir * 48, sy);
  ctx.lineTo(sx + dir * 55, sy + 3);
  ctx.stroke();

  // Conning tower (larger)
  ctx.lineWidth = 1.5;
  ctx.strokeRect(sx - 8, sy - 16, 16, 16);

  // Periscope
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(sx + 4, sy - 16);
  ctx.lineTo(sx + 4, sy - 24);
  ctx.lineTo(sx + 8, sy - 24);
  ctx.stroke();

  // Machine gun turret on conning tower
  if (depth < 0.5) {
    ctx.lineWidth = 1.5;
    // Turret base (circle)
    ctx.beginPath();
    ctx.arc(sx - 2, sy - 16, 4, 0, Math.PI * 2);
    ctx.stroke();
    // Gun barrel pointing toward player
    const dx = player.x - sx;
    const dy = player.y - (sy - 16);
    const gunAngle = Math.atan2(dy, dx);
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(sx - 2, sy - 16);
    ctx.lineTo(sx - 2 + Math.cos(gunAngle) * 12, sy - 16 + Math.sin(gunAngle) * 12);
    ctx.stroke();
  }

  // Propeller wake
  if (depth < 0.8) {
    ctx.strokeStyle = 'rgba(100, 200, 255, 0.3)';
    ctx.lineWidth = 1;
    const wakeX = sx - dir * 50;
    for (let w = 0; w < 3; w++) {
      ctx.beginPath();
      ctx.arc(wakeX - dir * w * 8, sy + 5, 3 + w * 2, 0, Math.PI);
      ctx.stroke();
    }
  }

  // HP indicator (pips below hull)
  ctx.fillStyle = '#48f';
  for (let h = 0; h < sub.hp; h++) {
    ctx.fillRect(sx - 15 + h * 6, sy + 20, 4, 2);
  }

  clearGlow(ctx);
  ctx.globalAlpha = 1;
}

function drawBuilding(bld) {
  const col = buildingColors[bld.type] || '#fa0';
  neonGlow(ctx, col, 8);
  ctx.strokeStyle = col;
  ctx.lineWidth = 1.5;
  ctx.strokeRect(bld.x, bld.y, bld.w, bld.h);

  // Inner detail per type
  if (bld.type === 'factory') {
    ctx.strokeRect(bld.x + bld.w - 10, bld.y - 15, 8, 15);
    if (Math.random() < 0.05) {
      addParticle(bld.x + bld.w - 6, bld.y - 15, (Math.random() - 0.5) * 10, -20, 0.5, '#555', 2);
    }
  } else if (bld.type === 'flak') {
    ctx.beginPath();
    ctx.moveTo(bld.x + bld.w / 2, bld.y);
    ctx.lineTo(bld.x + bld.w / 2, bld.y - 12);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(bld.x + bld.w / 2 - 6, bld.y - 10);
    ctx.lineTo(bld.x + bld.w / 2 + 6, bld.y - 10);
    ctx.stroke();
  } else if (bld.type === 'hangar') {
    ctx.beginPath();
    ctx.arc(bld.x + bld.w / 2, bld.y + bld.h, bld.w * 0.35, Math.PI, 0);
    ctx.stroke();
  } else if (bld.type === 'dam') {
    // Vertical buttress lines
    for (let bx = bld.x + 15; bx < bld.x + bld.w - 10; bx += 20) {
      ctx.beginPath();
      ctx.moveTo(bx, bld.y);
      ctx.lineTo(bx, bld.y + bld.h);
      ctx.stroke();
    }
    // Wavy water line on upstream (left) side
    ctx.strokeStyle = '#0af';
    ctx.lineWidth = 1;
    ctx.beginPath();
    for (let wx = bld.x - 40; wx < bld.x; wx += 3) {
      const wy = bld.y + bld.h - 5 + Math.sin(Date.now() * 0.004 + wx * 0.2) * 3;
      if (wx === bld.x - 40) ctx.moveTo(wx, wy);
      else ctx.lineTo(wx, wy);
    }
    ctx.stroke();
    // Label
    ctx.strokeStyle = col;
    ctx.fillStyle = col;
    ctx.font = '7px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('DAM', bld.x + bld.w / 2, bld.y + bld.h / 2 + 3);
  } else if (bld.type === 'radar_station') {
    // Base rectangle already drawn
    // Antenna mast
    const cx = bld.x + bld.w / 2;
    ctx.beginPath();
    ctx.moveTo(cx, bld.y);
    ctx.lineTo(cx, bld.y - 20);
    ctx.stroke();
    // Rotating dish (animated arc)
    const dishAngle = (Date.now() * 0.003) % (Math.PI * 2);
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(cx, bld.y - 20, 8, dishAngle, dishAngle + Math.PI * 0.6);
    ctx.stroke();
    ctx.lineWidth = 1.5;
  } else if (bld.type === 'fuel_depot') {
    // Cylindrical tank shapes (arcs) inside
    for (let t = 0; t < 3; t++) {
      const tx = bld.x + 8 + t * 13;
      ctx.beginPath();
      ctx.arc(tx, bld.y + bld.h, 8, Math.PI, 0);
      ctx.stroke();
    }
    // Diagonal hazard stripes
    ctx.lineWidth = 1;
    ctx.setLineDash([4, 4]);
    ctx.beginPath();
    ctx.moveTo(bld.x, bld.y + bld.h);
    ctx.lineTo(bld.x + bld.w, bld.y);
    ctx.stroke();
    ctx.setLineDash([]);
    // Occasional orange smoke
    if (Math.random() < 0.03) {
      addParticle(bld.x + bld.w / 2, bld.y, (Math.random()-0.5)*8, -15, 0.4, '#f80', 2);
    }
  } else if (bld.type === 'bunker') {
    // Rounded top (arc)
    ctx.beginPath();
    ctx.arc(bld.x + bld.w / 2, bld.y, bld.w / 2, Math.PI, 0);
    ctx.stroke();
    // Gun slit
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(bld.x + 5, bld.y + 5);
    ctx.lineTo(bld.x + bld.w - 5, bld.y + 5);
    ctx.stroke();
  }

  // HP indicator
  if (bld.hp > 1) {
    ctx.fillStyle = col;
    ctx.font = '8px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('●'.repeat(Math.min(bld.hp, 8)), bld.x + bld.w / 2, bld.y - 4);
  }
  clearGlow(ctx);
}

function drawOx(o) {
  neonGlow(ctx, '#0f0', 6);
  ctx.strokeStyle = '#0f0';
  ctx.lineWidth = 1.5;

  // Body
  ctx.strokeRect(o.x + 3, o.y + 1, 14, 6);
  // Legs
  ctx.beginPath();
  ctx.moveTo(o.x + 5, o.y + 7); ctx.lineTo(o.x + 5, o.y + 10);
  ctx.moveTo(o.x + 8, o.y + 7); ctx.lineTo(o.x + 8, o.y + 10);
  ctx.moveTo(o.x + 13, o.y + 7); ctx.lineTo(o.x + 13, o.y + 10);
  ctx.moveTo(o.x + 16, o.y + 7); ctx.lineTo(o.x + 16, o.y + 10);
  ctx.stroke();
  // Head
  const headX = o.dir > 0 ? o.x + 17 : o.x + 3;
  ctx.strokeRect(headX - 2, o.y - 1, 4, 4);
  // Horns
  ctx.beginPath();
  ctx.moveTo(headX - 2, o.y - 1); ctx.lineTo(headX - 4, o.y - 3);
  ctx.moveTo(headX + 2, o.y - 1); ctx.lineTo(headX + 4, o.y - 3);
  ctx.stroke();
  clearGlow(ctx);
}

function drawTitle(W, H) {
  // Animated background stars
  ctx.fillStyle = '#fff';
  for (const s of stars) {
    const sx = (s.x * 0.1 + Date.now() * 0.005) % W;
    const sy = s.y;
    if (sy > H) continue;
    ctx.globalAlpha = s.b + Math.sin(Date.now() * 0.003 + s.x) * 0.1;
    ctx.fillRect(sx, sy, s.s, s.s);
  }
  ctx.globalAlpha = 1;

  // Title
  neonGlow(ctx, '#0ff', 20);
  ctx.fillStyle = '#0ff';
  ctx.font = `bold ${Math.min(60, W * 0.08)}px "Courier New", monospace`;
  ctx.textAlign = 'center';
  ctx.fillText('NEON SOPWITH', W / 2, H * 0.25);
  clearGlow(ctx);

  neonGlow(ctx, '#0af', 10);
  ctx.fillStyle = '#0af';
  ctx.font = `${Math.min(18, W * 0.025)}px "Courier New", monospace`;
  ctx.fillText('A Retro Biplane Shooter', W / 2, H * 0.25 + 35);
  clearGlow(ctx);

  // Animated biplane
  titlePlaneX += 2;
  if (titlePlaneX > W + 200) titlePlaneX = -200;
  const titlePlaneY = H * 0.4 + Math.sin(Date.now() * 0.002) * 15;
  drawBiplane(ctx, titlePlaneX, titlePlaneY, Math.sin(Date.now() * 0.001) * 0.1, false, '#0ff', 2);
  // Engine trail
  for (let i = 0; i < 3; i++) {
    addParticle(titlePlaneX - 40 - i * 10, titlePlaneY + (Math.random() - 0.5) * 5, -30, (Math.random() - 0.5) * 10, 0.3, '#08f', 2);
  }
  // Update & draw title particles
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx * 0.016;
    p.y += p.vy * 0.016;
    p.life -= 0.016;
    if (p.life <= 0) { particles.splice(i, 1); continue; }
    ctx.globalAlpha = p.life / p.maxLife;
    ctx.fillStyle = p.color;
    ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
  }
  ctx.globalAlpha = 1;

  // Blinking "Press ENTER"
  if (Math.sin(Date.now() * 0.004) > 0) {
    neonGlow(ctx, '#fff', 8);
    ctx.fillStyle = '#fff';
    ctx.font = `${Math.min(20, W * 0.03)}px "Courier New", monospace`;
    ctx.fillText('PRESS ENTER TO START', W / 2, H * 0.55);
    clearGlow(ctx);
  }

  // Controls
  const ctrls = [
    [', or Arrow Up', 'Nose Up + Accelerate'],
    ['/ or Arrow Down', 'Nose Down'],
    ['X', 'Accelerate'],
    ['Space', 'Machine Gun'],
    ['B', 'Drop Bomb'],
    ['H', 'Autopilot Home'],
  ];
  ctx.fillStyle = '#557';
  ctx.font = `${Math.min(12, W * 0.018)}px "Courier New", monospace`;
  const startY = H * 0.65;
  ctx.textAlign = 'center';
  ctx.fillText('─── CONTROLS ───', W / 2, startY - 15);
  ctx.textAlign = 'left';
  for (let i = 0; i < ctrls.length; i++) {
    const cx = W / 2 - 160;
    const cy = startY + i * 22;
    ctx.fillStyle = '#0af';
    ctx.fillText(ctrls[i][0].padEnd(16), cx, cy);
    ctx.fillStyle = '#667';
    ctx.fillText(ctrls[i][1], cx + 170, cy);
  }

  // Footer
  ctx.textAlign = 'center';
  ctx.fillStyle = '#334';
  ctx.font = `${Math.min(11, W * 0.015)}px "Courier New", monospace`;
  ctx.fillText('Inspired by Sopwith (1984) by BMB Compuscience', W / 2, H * 0.95);
}

function drawRadar() {
  const rW = radarCanvas.width;
  const rH = radarCanvas.height;
  rctx.fillStyle = '#08080c';
  rctx.fillRect(0, 0, rW, rH);

  const scale = rW / WORLD_W;

  // Terrain silhouette
  const isSea = getLevelTheme(level) === 'sea';
  rctx.strokeStyle = isSea ? '#05a' : '#0a3';
  rctx.lineWidth = 1;
  rctx.beginPath();
  for (let x = 0; x < WORLD_W; x += 20) {
    const rx = x * scale;
    const ry = rH - (rH * 0.6 - terrain[x] * scale * 0.5);
    if (x === 0) rctx.moveTo(rx, Math.min(rH, ry));
    else rctx.lineTo(rx, Math.min(rH, ry));
  }
  rctx.stroke();

  // Base
  rctx.fillStyle = '#0af';
  rctx.fillRect(baseX * scale - 1, 2, Math.max(3, BASE_WIDTH * scale), 4);

  // Buildings (color-coded by type)
  for (const bld of buildings) {
    if (!bld.alive) continue;
    rctx.fillStyle = buildingColors[bld.type] || '#f44';
    rctx.fillRect(bld.x * scale, rH * 0.4, Math.max(2, bld.w * scale), 3);
  }

  // Enemies (color-coded by type)
  for (const en of enemies) {
    if (!en.alive || en.state === 'hangar') continue;
    const spec = ENEMY_SPECS[en.type];
    rctx.fillStyle = spec.color;
    const sz = en.type === 'zeppelin' ? 5 : 3;
    rctx.fillRect(en.x * scale - 1, en.y * scale * 0.05 + 5, sz, sz);
  }

  // Dragons
  for (const d of dragons) {
    if (!d.alive) continue;
    rctx.fillStyle = '#f40';
    rctx.fillRect(d.x * scale - 2, d.y * scale * 0.05 + 5, 4, 4);
  }

  // Submarines
  for (const sub of submarines) {
    if (!sub.alive) continue;
    rctx.fillStyle = sub.surfaced ? '#48f' : 'rgba(68, 136, 255, 0.3)';
    rctx.fillRect(sub.x * scale - 2, rH * 0.6, 4, 3);
  }

  // Player
  if (state === ST.PLAYING || state === ST.LEVEL_COMPLETE) {
    rctx.fillStyle = '#0ff';
    rctx.fillRect(player.x * scale - 2, player.y * scale * 0.05 + 5, 5, 4);
  }

  // Viewport indicator
  rctx.strokeStyle = '#225';
  rctx.lineWidth = 1;
  const viewL = camX * scale;
  const viewW = canvas.width * scale;
  rctx.strokeRect(viewL, 0, viewW, rH);
}

function drawRadarEmpty() {
  const rW = radarCanvas.width;
  const rH = radarCanvas.height;
  rctx.fillStyle = '#08080c';
  rctx.fillRect(0, 0, rW, rH);
  rctx.fillStyle = '#1a1a2a';
  rctx.font = '10px "Courier New", monospace';
  rctx.textAlign = 'center';
  rctx.fillText('RADAR', rW / 2, rH / 2 + 3);
}

// ── Cockpit instrument gauges (next to radar scope, compact) ──
function drawCockpitGauges(W, H) {
  const p = player;
  // Match radar scope positioning
  const radarR = Math.min(W, H) * 0.12;
  const radarCx = 20 + radarR + 8;
  const radarCy = H - 20 - radarR - 8;

  // Tiny gauges arranged in a 2x2 grid to the right of the radar
  const gr = radarR * 0.32; // gauge radius — much smaller than radar
  const baseX = radarCx + radarR + gr + 12; // right of radar circle
  const baseY = radarCy - radarR + gr + 2;  // top-aligned with radar
  const gapX = gr * 2.3;
  const gapY = gr * 2.3;

  const gauges = [
    { label: 'SPD', value: p.speed / PLANE_MAX_SPEED, raw: Math.round(p.speed * PIXELS_PER_UNIT), unit: '', color: '#0ff', warnBelow: 0.3 },
    { label: 'ALT', value: Math.max(0, 1 - p.y / (canvas.height * 0.8)), raw: Math.max(0, Math.round((canvas.height * 0.75 - p.y) / 3)), unit: '', color: '#0fa', warnBelow: 0.15 },
    { label: 'FUEL', value: p.fuel / MAX_FUEL, raw: Math.round(p.fuel / MAX_FUEL * 100), unit: '%', color: '#0f0', warnBelow: 0.2 },
    { label: 'HP', value: p.hp / PLAYER_MAX_HP, raw: p.hp, unit: '/' + PLAYER_MAX_HP, color: '#0ff', warnBelow: 0.34 }
  ];

  for (let i = 0; i < gauges.length; i++) {
    const g = gauges[i];
    const col2 = Math.floor(i / 2);  // 0 or 1
    const row = i % 2;
    const cx = baseX + col2 * gapX;
    const cy = baseY + row * gapY;
    const val = Math.max(0, Math.min(1, g.value));
    const isWarning = val <= g.warnBelow;
    const col = isWarning ? '#f44' : g.color;

    // Background
    ctx.beginPath();
    ctx.arc(cx, cy, gr, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(0, 10, 20, 0.6)';
    ctx.fill();
    ctx.strokeStyle = 'rgba(0, 180, 100, 0.15)';
    ctx.lineWidth = 0.5;
    ctx.stroke();

    // Arc (270° sweep from 135° to 405°)
    const arcStart = Math.PI * 0.75;
    const arcEnd = Math.PI * 2.25;
    const valAngle = arcStart + (arcEnd - arcStart) * val;

    // Dim track
    ctx.beginPath();
    ctx.arc(cx, cy, gr * 0.7, arcStart, arcEnd);
    ctx.strokeStyle = 'rgba(0, 180, 100, 0.1)';
    ctx.lineWidth = 1.5;
    ctx.stroke();

    // Value arc
    neonGlow(ctx, col, 3);
    ctx.beginPath();
    ctx.arc(cx, cy, gr * 0.7, arcStart, valAngle);
    ctx.strokeStyle = col;
    ctx.lineWidth = 1.5;
    ctx.stroke();

    // Needle
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.lineTo(cx + Math.cos(valAngle) * gr * 0.55, cy + Math.sin(valAngle) * gr * 0.55);
    ctx.strokeStyle = col;
    ctx.lineWidth = 1;
    ctx.stroke();
    clearGlow(ctx);

    // Center dot
    ctx.beginPath();
    ctx.arc(cx, cy, 1, 0, Math.PI * 2);
    ctx.fillStyle = col;
    ctx.fill();

    // Label (tiny, below center)
    ctx.fillStyle = 'rgba(0, 180, 100, 0.4)';
    ctx.font = Math.max(6, Math.round(gr * 0.4)) + 'px "Courier New", monospace';
    ctx.textAlign = 'center';
    ctx.fillText(g.label, cx, cy + gr * 0.4);

    // Numeric value (above center)
    ctx.fillStyle = col;
    ctx.font = 'bold ' + Math.max(7, Math.round(gr * 0.45)) + 'px "Courier New", monospace';
    ctx.fillText(g.raw + g.unit, cx, cy - gr * 0.1);
  }
}

// ── Circular radar scope (in-game HUD) ──
let radarSweepAngle = 0;

function drawRadarScope(W, H) {
  const R = Math.min(W, H) * 0.12;         // radius scales with screen
  const cx = 20 + R + 8;                     // center X (bottom-left)
  const cy = H - 20 - R - 8;                // center Y
  const RANGE = 1200;                        // world-unit detection range
  const scale = R / RANGE;

  // ── Background ──
  ctx.save();
  ctx.globalAlpha = 0.7;
  ctx.beginPath();
  ctx.arc(cx, cy, R + 6, 0, Math.PI * 2);
  ctx.fillStyle = '#040810';
  ctx.fill();
  ctx.globalAlpha = 1;

  // Clip to circle
  ctx.save();
  ctx.beginPath();
  ctx.arc(cx, cy, R + 1, 0, Math.PI * 2);
  ctx.clip();

  // ── Sweep fade trail (ghosting effect) ──
  ctx.fillStyle = 'rgba(4, 8, 16, 0.15)';
  ctx.fillRect(cx - R - 2, cy - R - 2, (R + 2) * 2, (R + 2) * 2);

  // ── Sweep line (cosmetic rotation, not tied to heading) ──
  radarSweepAngle += 0.03;
  if (radarSweepAngle > Math.PI * 2) radarSweepAngle -= Math.PI * 2;
  const sweepAng = radarSweepAngle;

  // Draw sweep as a filled wedge with gradient
  ctx.globalAlpha = 0.35;
  for (let i = 0; i < 12; i++) {
    const a0 = sweepAng - (i + 1) * 0.05;
    const a1 = sweepAng - i * 0.05;
    const alpha = 0.35 * (1 - i / 12);
    ctx.fillStyle = `rgba(0, 255, 128, ${alpha})`;
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.arc(cx, cy, R, a0, a1);
    ctx.closePath();
    ctx.fill();
  }
  ctx.globalAlpha = 1;

  // Bright sweep line
  neonGlow(ctx, '#0f8', 6);
  ctx.strokeStyle = '#0fa';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(cx, cy);
  ctx.lineTo(cx + Math.cos(sweepAng) * R, cy + Math.sin(sweepAng) * R);
  ctx.stroke();
  clearGlow(ctx);

  // ── Terrain contour in scope ──
  ctx.strokeStyle = 'rgba(0, 200, 80, 0.25)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  let terrainStarted = false;
  const terrainSamples = 60;
  for (let i = 0; i <= terrainSamples; i++) {
    const worldX = player.x - RANGE + (2 * RANGE * i / terrainSamples);
    const wrappedX = ((worldX % WORLD_W) + WORLD_W) % WORLD_W;
    const ty = getTerrainY(wrappedX);
    // Map: dx = worldX - player.x → horizontal on scope; dy = ty - player.y → vertical on scope
    const dx = worldX - player.x;
    const dy = ty - player.y;
    const sx = cx + dx * scale;
    const sy = cy + dy * scale;
    if (!terrainStarted) { ctx.moveTo(sx, sy); terrainStarted = true; }
    else ctx.lineTo(sx, sy);
  }
  ctx.stroke();

  // ── Range rings ──
  ctx.strokeStyle = 'rgba(0, 180, 80, 0.2)';
  ctx.lineWidth = 0.5;
  for (let ring = 1; ring <= 3; ring++) {
    ctx.beginPath();
    ctx.arc(cx, cy, R * ring / 3, 0, Math.PI * 2);
    ctx.stroke();
  }

  // ── Crosshair lines ──
  ctx.strokeStyle = 'rgba(0, 180, 80, 0.15)';
  ctx.beginPath();
  ctx.moveTo(cx - R, cy); ctx.lineTo(cx + R, cy);
  ctx.moveTo(cx, cy - R); ctx.lineTo(cx, cy + R);
  ctx.stroke();

  // ── Cardinal labels (N/S/E/W) ──
  ctx.fillStyle = 'rgba(0, 180, 80, 0.4)';
  ctx.font = '7px "Courier New", monospace';
  ctx.textAlign = 'center';
  ctx.fillText('N', cx, cy - R + 8);
  ctx.fillText('S', cx, cy + R - 3);
  ctx.textAlign = 'left';
  ctx.fillText('E', cx + R - 8, cy + 3);
  ctx.textAlign = 'right';
  ctx.fillText('W', cx - R + 8, cy + 3);
  ctx.textAlign = 'center';

  // ── Helper: world pos → scope pos (stationary — north=up, world X→horizontal) ──
  function toScope(wx, wy) {
    let dx = wx - player.x;
    let dy = wy - player.y;
    // Handle world wrapping
    if (dx > WORLD_W / 2) dx -= WORLD_W;
    if (dx < -WORLD_W / 2) dx += WORLD_W;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist > RANGE) return null;
    // Map directly: world X → screen horizontal, world Y → screen vertical (no rotation)
    return { x: cx + dx * scale, y: cy + dy * scale, dist };
  }

  // ── Helper: draw a chevron blip (small V pointing in travel direction) ──
  function drawChevron(sx, sy, angle, color, size) {
    neonGlow(ctx, color, 6);
    ctx.strokeStyle = color;
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    // Chevron: two lines from tip pointing in angle direction
    const tipX = sx + Math.cos(angle) * size;
    const tipY = sy + Math.sin(angle) * size;
    const leftX = sx + Math.cos(angle + 2.5) * size;
    const leftY = sy + Math.sin(angle + 2.5) * size;
    const rightX = sx + Math.cos(angle - 2.5) * size;
    const rightY = sy + Math.sin(angle - 2.5) * size;
    ctx.moveTo(leftX, leftY);
    ctx.lineTo(tipX, tipY);
    ctx.lineTo(rightX, rightY);
    ctx.stroke();
    clearGlow(ctx);
  }

  // ── Helper: draw a square blip for buildings ──
  function drawSquareBlip(sx, sy, color, size) {
    ctx.fillStyle = color;
    ctx.globalAlpha = 0.7;
    ctx.fillRect(sx - size, sy - size, size * 2, size * 2);
    ctx.globalAlpha = 1;
  }

  // ── Helper: draw a diamond blip for dragons ──
  function drawDiamondBlip(sx, sy, color, size) {
    neonGlow(ctx, color, 6);
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.moveTo(sx, sy - size);
    ctx.lineTo(sx + size, sy);
    ctx.lineTo(sx, sy + size);
    ctx.lineTo(sx - size, sy);
    ctx.closePath();
    ctx.fill();
    clearGlow(ctx);
  }

  // ── Home base marker ──
  const bp = toScope(baseX + BASE_WIDTH / 2, getTerrainY(baseX + BASE_WIDTH / 2));
  if (bp) {
    neonGlow(ctx, '#0af', 6);
    ctx.fillStyle = '#0af';
    ctx.font = 'bold 8px "Courier New", monospace';
    ctx.textAlign = 'center';
    ctx.fillText('H', bp.x, bp.y + 3);
    clearGlow(ctx);
  }

  // ── Enemies (chevrons pointing in travel direction) ──
  for (const en of enemies) {
    if (!en.alive || en.state === 'hangar') continue;
    const p = toScope(en.x, en.y);
    if (!p) continue;
    const spec = ENEMY_SPECS[en.type];
    if (en.type === 'zeppelin') {
      // Zeppelins: larger rectangle blip
      ctx.fillStyle = spec.color;
      ctx.globalAlpha = 0.7;
      ctx.fillRect(p.x - 3, p.y - 1.5, 6, 3);
      ctx.globalAlpha = 1;
    } else {
      const sz = en.type === 'bomber' ? 4 : 3;
      drawChevron(p.x, p.y, en.angle, spec.color, sz);
    }
  }

  // ── Dragons (diamond blip) ──
  for (const d of dragons) {
    if (!d.alive) continue;
    const p = toScope(d.x, d.y);
    if (!p) continue;
    drawDiamondBlip(p.x, p.y, '#f40', 3);
  }

  // ── Submarines (for sea levels) ──
  if (typeof submarines !== 'undefined') {
    for (const sub of submarines) {
      if (!sub.alive) continue;
      const p = toScope(sub.x, sub.y);
      if (!p) continue;
      ctx.fillStyle = '#48f';
      ctx.globalAlpha = sub.surfaced ? 0.8 : 0.3;
      ctx.fillRect(p.x - 2, p.y - 1, 4, 2);
      ctx.globalAlpha = 1;
    }
  }

  // ── Buildings (all types — small squares, color-coded) ──
  for (const bld of buildings) {
    if (!bld.alive) continue;
    const p = toScope(bld.x + bld.w / 2, bld.y);
    if (!p) continue;
    drawSquareBlip(p.x, p.y, buildingColors[bld.type] || '#fa0', 1.5);
  }

  // ── Bird flocks (goose/eagle only — dangerous ones, tiny dots) ──
  for (const bg of birds) {
    if (bg.type === 'sparrow') continue;
    const leader = bg.flock.find(b => b.alive);
    if (!leader) continue;
    const p = toScope(leader.x, leader.y);
    if (!p) continue;
    ctx.fillStyle = bg.type === 'eagle' ? '#a72' : '#dda';
    ctx.globalAlpha = 0.5;
    ctx.beginPath();
    ctx.arc(p.x, p.y, 1.5, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
  }

  // ── Flak shots (incoming — tiny yellow dots) ──
  for (const f of flakShots) {
    const p = toScope(f.x, f.y);
    if (!p) continue;
    ctx.fillStyle = '#ff0';
    ctx.globalAlpha = 0.4;
    ctx.fillRect(p.x - 0.5, p.y - 0.5, 1, 1);
    ctx.globalAlpha = 1;
  }

  // ── Enemy bombs (incoming) ──
  for (const b of bombs) {
    if (b.friendly !== false) continue;
    const p = toScope(b.x, b.y);
    if (!p) continue;
    ctx.fillStyle = '#f55';
    ctx.globalAlpha = 0.5;
    ctx.fillRect(p.x - 1, p.y - 1, 2, 2);
    ctx.globalAlpha = 1;
  }

  // ── Player center icon (small plane shape pointing in travel direction) ──
  const planeRad = getPlaneRadians(player);
  neonGlow(ctx, '#0ff', 8);
  ctx.strokeStyle = '#0ff';
  ctx.lineWidth = 1.5;
  // Small plane icon: nose + two wing stubs
  const noseX = cx + Math.cos(planeRad) * 5;
  const noseY = cy + Math.sin(planeRad) * 5;
  const tailX = cx - Math.cos(planeRad) * 4;
  const tailY = cy - Math.sin(planeRad) * 4;
  const wingPerp = planeRad + Math.PI / 2;
  ctx.beginPath();
  ctx.moveTo(tailX, tailY);
  ctx.lineTo(noseX, noseY);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(cx + Math.cos(wingPerp) * 4, cy + Math.sin(wingPerp) * 4);
  ctx.lineTo(cx - Math.cos(wingPerp) * 4, cy - Math.sin(wingPerp) * 4);
  ctx.stroke();
  clearGlow(ctx);

  ctx.restore(); // end clip

  // ── Bezel ring ──
  neonGlow(ctx, '#0a4', 4);
  ctx.strokeStyle = '#0a4';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(cx, cy, R + 3, 0, Math.PI * 2);
  ctx.stroke();

  // Outer thin ring
  ctx.strokeStyle = '#052';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.arc(cx, cy, R + 6, 0, Math.PI * 2);
  ctx.stroke();
  clearGlow(ctx);

  // ── Label ──
  ctx.fillStyle = '#0a4';
  ctx.globalAlpha = 0.6;
  ctx.font = '8px "Courier New", monospace';
  ctx.textAlign = 'center';
  ctx.fillText('RDR', cx, cy + R + 14);
  ctx.globalAlpha = 1;

  ctx.restore(); // end save from top
}

// ── Game loop ──
function gameLoop(timestamp) {
  if (!lastTime) lastTime = timestamp;
  let dt = (timestamp - lastTime) / 1000;
  lastTime = timestamp;
  if (dt > 0.05) dt = 0.05; // cap delta

  handleInput();
  update(dt);
  draw();
  requestAnimationFrame(gameLoop);
}

function handleInput() {
  if (keys['Enter']) {
    keys['Enter'] = false;
    if (state === ST.TITLE || state === ST.GAME_OVER) {
      initAudio();
      level = 1;
      score = 0;
      lives = 5;
      initLevel();
      state = ST.PLAYING;
      if (touchStartBtn) touchStartBtn.classList.remove('visible');
    }
  }

  // Show/hide touch start button based on game state
  if (isTouchDevice && touchStartBtn) {
    if (state === ST.TITLE || state === ST.GAME_OVER) {
      touchStartBtn.classList.add('visible');
      touchStartBtn.textContent = state === ST.TITLE ? 'TAP TO START' : 'TAP TO RETRY';
    } else {
      touchStartBtn.classList.remove('visible');
    }
  }
}

// ── Engine sound update ──
function updateEngineSound() {
  if (!engineGain || !audioCtx) return;
  if (state === ST.PLAYING && player && !player.landed) {
    const speed = player.speed * PIXELS_PER_UNIT;
    engineOsc.frequency.value = 60 + speed * 0.3 + player.accel * 10;
    engineGain.gain.value = 0.02 + (player.accel / PLANE_MAX_ACCEL) * 0.03;
  } else {
    engineGain.gain.value = 0;
  }
}
setInterval(updateEngineSound, 50);

// ── Start ──
particles = [];
fleeingPeople = [];
dragons = [];
generateTerrain();
requestAnimationFrame(gameLoop);

})();
</script>
</body>
</html>

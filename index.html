<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Neon Sopwith</title>
<style>
*,*::before,*::after{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#0a0a0f;font-family:'Courier New',monospace}
#wrap{position:relative;width:100%;height:100%;display:flex;flex-direction:column}
#radar{height:40px;background:#08080c;border-bottom:1px solid #1a1a2a;position:relative;overflow:hidden}
#game{flex:1;position:relative;image-rendering:auto}
#game canvas{width:100%;height:100%;display:block}
/* scanlines */
#game::after{content:'';position:absolute;inset:0;background:repeating-linear-gradient(0deg,transparent,transparent 2px,rgba(0,0,0,0.08) 2px,rgba(0,0,0,0.08) 4px);pointer-events:none;z-index:2}
/* CRT vignette */
#game::before{content:'';position:absolute;inset:0;background:radial-gradient(ellipse at center,transparent 60%,rgba(0,0,0,0.5) 100%);pointer-events:none;z-index:3}
#hud{height:36px;background:#08080c;border-top:1px solid #1a1a2a;display:flex;align-items:center;justify-content:center;gap:2rem;font-size:13px;color:#8af;padding:0 1rem;flex-shrink:0}
.hud-item{display:flex;align-items:center;gap:0.4rem;white-space:nowrap}
.hud-label{color:#557;font-size:11px;text-transform:uppercase;letter-spacing:1px}
.hud-val{color:#0ff;font-weight:bold;text-shadow:0 0 6px #0ff}
.hud-val.red{color:#f55;text-shadow:0 0 6px #f55}
.hud-val.green{color:#0fa;text-shadow:0 0 6px #0fa}
.fuel-bar{width:60px;height:8px;background:#112;border:1px solid #335;border-radius:2px;overflow:hidden;display:inline-block;vertical-align:middle}
.fuel-fill{height:100%;background:linear-gradient(90deg,#0f0,#0ff);transition:width 0.2s}
.ammo-bar{width:50px;height:8px;background:#112;border:1px solid #335;border-radius:2px;overflow:hidden;display:inline-block;vertical-align:middle}
.ammo-fill{height:100%;background:linear-gradient(90deg,#ff0,#fa0);transition:width 0.2s}
/* ── Touch controls ── */
#touch-zone{display:none;position:absolute;inset:0;z-index:5;touch-action:none}
#touch-actions{display:none;position:absolute;right:8px;bottom:50px;z-index:10;pointer-events:none;flex-direction:column;gap:8px}
.touch-btn{pointer-events:auto;width:52px;height:52px;border-radius:50%;border:2px solid rgba(0,255,255,0.35);background:rgba(0,20,40,0.45);color:#0ff;font:bold 12px 'Courier New',monospace;display:flex;align-items:center;justify-content:center;user-select:none;-webkit-user-select:none;touch-action:none;text-shadow:0 0 6px #0ff}
.touch-btn:active,.touch-btn.held{background:rgba(0,255,255,0.25);border-color:#0ff}
.touch-btn.fire{border-color:rgba(255,100,100,0.4);color:#f66;text-shadow:0 0 6px #f66;width:58px;height:58px}
.touch-btn.fire:active,.touch-btn.fire.held{background:rgba(255,50,50,0.25);border-color:#f66}
.touch-btn.bomb{border-color:rgba(255,160,0,0.4);color:#fa0;text-shadow:0 0 6px #fa0}
.touch-btn.bomb:active,.touch-btn.bomb.held{background:rgba(255,160,0,0.25);border-color:#fa0}
#touch-start{display:none;position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);z-index:20;pointer-events:auto;padding:18px 36px;border-radius:12px;border:2px solid #0ff;background:rgba(0,20,40,0.8);color:#0ff;font:bold 20px 'Courier New',monospace;text-shadow:0 0 10px #0ff;touch-action:none;user-select:none;-webkit-user-select:none}
#touch-pitch-indicator{display:none;position:absolute;left:12px;top:50%;transform:translateY(-50%);width:4px;height:80px;background:rgba(0,255,255,0.15);border-radius:2px;z-index:10;pointer-events:none}
#touch-pitch-dot{position:absolute;left:-4px;width:12px;height:12px;border-radius:50%;background:#0ff;box-shadow:0 0 8px #0ff;top:50%;transform:translateY(-50%);transition:top 0.05s}
@media (hover:none) and (pointer:coarse){
  #touch-zone{display:block !important}
  #touch-actions{display:flex !important}
  #touch-start.visible{display:block !important}
  #touch-start:not(.visible){display:none !important}
  #touch-pitch-indicator{display:block !important}
  #radar{height:60px}
}
</style>
</head>
<body>
<div id="wrap">
  <canvas id="radar"></canvas>
  <div id="game">
    <canvas id="c"></canvas>
    <!-- Touch: full-screen gesture zone (hold=throttle, drag=pitch) -->
    <div id="touch-zone"></div>
    <!-- Touch: start/retry button -->
    <div id="touch-start" class="visible">TAP TO START</div>
    <!-- Touch: pitch indicator -->
    <div id="touch-pitch-indicator"><div id="touch-pitch-dot"></div></div>
    <!-- Touch: action buttons (right side) -->
    <div id="touch-actions">
      <div class="touch-btn fire" data-key="Space">FIRE</div>
      <div class="touch-btn bomb" data-key="KeyB">BOMB</div>
      <div class="touch-btn" data-key="Period">FLIP</div>
      <div class="touch-btn" data-key="KeyH">HOME</div>
    </div>
  </div>
  <div id="hud">
    <div class="hud-item"><span class="hud-label">Lives</span><span id="h-lives" class="hud-val">●●●●●</span></div>
    <div class="hud-item"><span class="hud-label">Fuel</span><span class="fuel-bar"><span id="h-fuel" class="fuel-fill" style="width:100%"></span></span></div>
    <div class="hud-item"><span class="hud-label">Bombs</span><span id="h-bombs" class="hud-val">5</span></div>
    <div class="hud-item"><span class="hud-label">Ammo</span><span class="ammo-bar"><span id="h-ammo" class="ammo-fill" style="width:100%"></span></span></div>
    <div class="hud-item"><span class="hud-label">Score</span><span id="h-score" class="hud-val green">0</span></div>
    <div class="hud-item"><span class="hud-label">Level</span><span id="h-level" class="hud-val">1</span></div>
  </div>
</div>

<script>
// ═══════════════════════════════════════════════════════════════
//  NEON SOPWITH — A Sopwith-inspired neon retro biplane game
// ═══════════════════════════════════════════════════════════════
(() => {
'use strict';

// ── Canvas setup ──
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const radarCanvas = document.getElementById('radar');
const rctx = radarCanvas.getContext('2d');

function resize() {
  const gd = document.getElementById('game');
  canvas.width = gd.clientWidth;
  canvas.height = gd.clientHeight;
  radarCanvas.width = radarCanvas.parentElement ? radarCanvas.clientWidth || window.innerWidth : window.innerWidth;
  radarCanvas.height = radarCanvas.clientHeight || 40;
}
resize();
window.addEventListener('resize', resize);

// ── Constants ──
const WORLD_W = 12000;
const BULLET_SPEED = 600;
const BOMB_VXFRAC = 0.8;
const MAX_FUEL = 1000;
const MAX_AMMO = 200;
const MAX_BOMBS = 5;
const FLAK_INTERVAL = 90;
const FLAK_SPEED = 300;
const ENEMY_SPEED = 200;
const ENEMY_FIRE_INTERVAL = 60;
const BASE_WIDTH = 120;

// ── Enemy type constants ──
const JET_SPEED = 340;
const JET_FIRE_INTERVAL = 35;
const BOMBER_SPEED = 140;
const BOMBER_BOMB_INTERVAL = 120;
const ZEPPELIN_SPEED = 60;
const ZEPPELIN_BOMB_INTERVAL = 80;

const ENEMY_SPECS = {
  biplane: { hp: 2, speed: 200, fireInterval: ENEMY_FIRE_INTERVAL, score: 300, color: '#f0a', hitW: 20, hitH: 12 },
  jet:     { hp: 2, speed: JET_SPEED, fireInterval: JET_FIRE_INTERVAL, score: 500, color: '#f55', hitW: 20, hitH: 12 },
  bomber:  { hp: 4, speed: BOMBER_SPEED, fireInterval: BOMBER_BOMB_INTERVAL, score: 700, color: '#fa0', hitW: 30, hitH: 15 },
  zeppelin:{ hp: 8, speed: ZEPPELIN_SPEED, fireInterval: ZEPPELIN_BOMB_INTERVAL, score: 1500, color: '#aaf', hitW: 50, hitH: 20 }
};

// ── Building score/spec lookup ──
const buildingScores = { flak: 200, factory: 300, hangar: 100, dam: 500, radar_station: 250, fuel_depot: 200, bunker: 150 };
const buildingColors = { flak: '#f80', factory: '#f44', hangar: '#fa0', dam: '#48f', radar_station: '#af0', fuel_depot: '#f80', bunker: '#888' };

// ── Enemy accuracy debuff (from radar station destruction) ──
let enemyAccuracyDebuff = 0;

// ── Sopwith-style flight model ──
// 16 discrete angles (like original), speed scalar, gravity table
const NUM_ANGLES = 16;
const ANGLE_STEP = (Math.PI * 2) / NUM_ANGLES;
// Gravity effect per angle index (tuned from original Sopwith)
// Nose up = negative (slows you), nose down = positive (speeds you up)
// Reduced climb penalties so plane can maintain speed in moderate climbs
const GRAVITY_TABLE = [0, -1, -1, -2, -3, -2, -1, -1, 0, 1, 2, 3, 4, 3, 2, 1];
// Sine table (scaled to 1.0 instead of 256 as original)
const SIN_TABLE = [0, 0.383, 0.707, 0.924, 1.0, 0.924, 0.707, 0.383, 0, -0.383, -0.707, -0.924, -1.0, -0.924, -0.707, -0.383];
const COS_TABLE = SIN_TABLE.map((_, i) => SIN_TABLE[(i + 4) % 16]);

const PLANE_MIN_SPEED = 4;    // Minimum speed (like original)
const PLANE_MAX_SPEED = 9;    // Maximum speed
const PLANE_MAX_ACCEL = 5;    // Maximum throttle acceleration
const PIXELS_PER_UNIT = 28;   // Scale factor: Sopwith speed units → pixel velocity
const STALL_SPEED = 3;        // Below this speed, plane stalls
const TURN_RATE = 1;          // Angle steps per input (1 = one notch per press)
const PROJ_GRAVITY = 300;     // Gravity for projectiles (pixels/s²)

// ── Game State ──
const ST = { TITLE: 0, PLAYING: 1, DYING: 2, GAME_OVER: 3, LEVEL_COMPLETE: 4 };
let state = ST.TITLE;
let level = 1;
let score = 0;
let lives = 5;
let deathTimer = 0;
let levelTimer = 0;
let titlePlaneX = -200;

// ── Input ──
const keys = {};
window.addEventListener('keydown', e => { keys[e.code] = true; if(['Space','ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.code)) e.preventDefault(); });
window.addEventListener('keyup', e => { keys[e.code] = false; });

// ── Touch controls ──
// Hold anywhere = throttle (KeyX + ArrowUp), drag up/down = pitch
// Right-side buttons for fire, bomb, flip, home
const isTouchDevice = ('ontouchstart' in window) || navigator.maxTouchPoints > 0;
const touchStartBtn = document.getElementById('touch-start');
const touchZone = document.getElementById('touch-zone');
const pitchDot = document.getElementById('touch-pitch-dot');
let touchThrottleId = null;  // track the main gesture touch
let touchStartY = 0;         // Y where the touch began
let touchCurrentY = 0;
const PITCH_DEADZONE = 12;   // pixels before pitch kicks in
const PITCH_RANGE = 60;      // pixels for full up/down

// Start/retry button
if (touchStartBtn) {
  touchStartBtn.addEventListener('touchstart', (e) => {
    e.preventDefault();
    keys['Enter'] = true;
    setTimeout(() => { keys['Enter'] = false; }, 100);
    touchStartBtn.classList.remove('visible');
    initAudio();
  });
}

// Main touch zone — hold for throttle, drag for pitch
if (touchZone) {
  touchZone.addEventListener('touchstart', (e) => {
    e.preventDefault();
    initAudio();
    if (touchThrottleId !== null) return; // already tracking
    const t = e.changedTouches[0];
    touchThrottleId = t.identifier;
    touchStartY = t.clientY;
    touchCurrentY = t.clientY;
    // Throttle on (KeyX only — ArrowUp would also pitch up)
    keys['KeyX'] = true;
  });

  touchZone.addEventListener('touchmove', (e) => {
    e.preventDefault();
    for (const t of e.changedTouches) {
      if (t.identifier === touchThrottleId) {
        touchCurrentY = t.clientY;
        const dy = touchStartY - touchCurrentY; // positive = dragged up

        // Clear previous pitch keys
        keys['Comma'] = false;
        keys['Slash'] = false;

        if (dy > PITCH_DEADZONE) {
          // Dragged up → nose up
          keys['Comma'] = true;
        } else if (dy < -PITCH_DEADZONE) {
          // Dragged down → nose down
          keys['Slash'] = true;
        }

        // Update pitch indicator dot
        if (pitchDot) {
          const norm = Math.max(-1, Math.min(1, dy / PITCH_RANGE));
          pitchDot.style.top = (50 - norm * 40) + '%';
        }
      }
    }
  });

  const endTouch = (e) => {
    for (const t of e.changedTouches) {
      if (t.identifier === touchThrottleId) {
        touchThrottleId = null;
        keys['KeyX'] = false;
        keys['Comma'] = false;
        keys['Slash'] = false;
        if (pitchDot) pitchDot.style.top = '50%';
      }
    }
  };
  touchZone.addEventListener('touchend', endTouch);
  touchZone.addEventListener('touchcancel', endTouch);
}

// Action buttons (fire, bomb, flip, home)
document.querySelectorAll('.touch-btn').forEach(btn => {
  const keyCode = btn.dataset.key;
  if (!keyCode) return;
  btn.addEventListener('touchstart', (e) => {
    e.preventDefault();
    e.stopPropagation();
    keys[keyCode] = true;
    btn.classList.add('held');
    initAudio();
  });
  btn.addEventListener('touchend', (e) => {
    e.preventDefault();
    keys[keyCode] = false;
    btn.classList.remove('held');
  });
  btn.addEventListener('touchcancel', (e) => {
    keys[keyCode] = false;
    btn.classList.remove('held');
  });
});

// ── Audio (Web Audio synth) ──
let audioCtx = null;
let engineOsc = null;
let engineGain = null;
let audioStarted = false;

function initAudio() {
  if (audioStarted) return;
  audioStarted = true;
  try {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    engineOsc = audioCtx.createOscillator();
    engineGain = audioCtx.createGain();
    engineOsc.type = 'sawtooth';
    engineOsc.frequency.value = 80;
    engineGain.gain.value = 0;
    engineOsc.connect(engineGain);
    engineGain.connect(audioCtx.destination);
    engineOsc.start();
  } catch(e) {}
}

function playShoot() {
  if (!audioCtx) return;
  try {
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = 'square';
    o.frequency.value = 800;
    g.gain.value = 0.08;
    o.connect(g); g.connect(audioCtx.destination);
    o.start();
    o.frequency.exponentialRampToValueAtTime(200, audioCtx.currentTime + 0.05);
    g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.08);
    o.stop(audioCtx.currentTime + 0.08);
  } catch(e) {}
}

function playBoom(big) {
  if (!audioCtx) return;
  try {
    const dur = big ? 0.5 : 0.2;
    const buf = audioCtx.createBuffer(1, audioCtx.sampleRate * dur, audioCtx.sampleRate);
    const data = buf.getChannelData(0);
    for (let i = 0; i < data.length; i++) {
      data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / data.length, big ? 1.5 : 3);
    }
    const src = audioCtx.createBufferSource();
    const g = audioCtx.createGain();
    src.buffer = buf;
    g.gain.value = big ? 0.3 : 0.15;
    src.connect(g); g.connect(audioCtx.destination);
    src.start();
  } catch(e) {}
}

function playBombDrop() {
  if (!audioCtx) return;
  try {
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = 'sine';
    o.frequency.value = 400;
    g.gain.value = 0.07;
    o.connect(g); g.connect(audioCtx.destination);
    o.start();
    o.frequency.exponentialRampToValueAtTime(80, audioCtx.currentTime + 0.6);
    g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.6);
    o.stop(audioCtx.currentTime + 0.6);
  } catch(e) {}
}

function playFlood() {
  if (!audioCtx) return;
  try {
    const dur = 0.8;
    const buf = audioCtx.createBuffer(1, audioCtx.sampleRate * dur, audioCtx.sampleRate);
    const data = buf.getChannelData(0);
    for (let i = 0; i < data.length; i++) {
      const t = i / audioCtx.sampleRate;
      data[i] = (Math.random() * 2 - 1) * Math.pow(1 - t / dur, 0.8) * Math.sin(t * 30);
    }
    const src = audioCtx.createBufferSource();
    const g = audioCtx.createGain();
    src.buffer = buf;
    g.gain.value = 0.25;
    src.connect(g); g.connect(audioCtx.destination);
    src.start();
  } catch(e) {}
}

// ── Stars (background) ──
const stars = [];
for (let i = 0; i < 200; i++) {
  stars.push({ x: Math.random() * WORLD_W, y: Math.random() * 500, b: Math.random() * 0.5 + 0.2, s: Math.random() * 1.5 + 0.5 });
}

// ── Terrain generation ──
let terrain = [];
let baseX = 0;

function generateTerrain() {
  terrain = new Float32Array(WORLD_W);
  const groundBase = canvas.height * 0.75;
  // Multi-octave noise for hilly terrain
  for (let x = 0; x < WORLD_W; x++) {
    let h = 0;
    h += Math.sin(x * 0.002) * 60;
    h += Math.sin(x * 0.005 + 1.3) * 30;
    h += Math.sin(x * 0.01 + 2.7) * 15;
    h += Math.sin(x * 0.025 + 0.5) * 8;
    terrain[x] = groundBase + h;
  }
  // Place base in a flat valley area with long clear zone
  baseX = 200;
  const baseCenter = baseX + BASE_WIDTH / 2;
  const flatY = groundBase; // flat at the baseline (no sine offsets)
  // Flatten a wide area: 150px before base, runway, and 400px after for takeoff clearance
  const flatStart = baseX - 150;
  const flatEnd = baseX + BASE_WIDTH + 400;
  for (let x = Math.max(0, flatStart - 80); x < Math.min(WORLD_W, flatEnd + 80); x++) {
    if (x >= flatStart && x <= flatEnd) {
      // Fully flat
      terrain[x] = flatY;
    } else if (x < flatStart) {
      // Blend in from left
      const t = (flatStart - x) / 80;
      terrain[x] = flatY * (1 - t) + terrain[x] * t;
    } else {
      // Blend out to right
      const t = (x - flatEnd) / 80;
      terrain[x] = flatY * (1 - t) + terrain[x] * t;
    }
  }
}

function getTerrainY(x) {
  const ix = Math.floor(((x % WORLD_W) + WORLD_W) % WORLD_W);
  const ix2 = (ix + 1) % WORLD_W;
  const frac = x - Math.floor(x);
  return terrain[ix] * (1 - frac) + terrain[ix2] * frac;
}

// ── Entities ──
let player, bullets, bombs, particles, enemies, buildings, flakShots, birds, oxen;
let fleeingPeople, dragons;

function initPlayer() {
  const ty = getTerrainY(baseX + BASE_WIDTH / 2);
  player = {
    x: baseX + BASE_WIDTH / 2,
    y: ty - 30,
    // Sopwith-style: single speed scalar + angle index
    speed: 0,             // current speed (in Sopwith units)
    accel: 0,             // throttle acceleration (0 to PLANE_MAX_ACCEL)
    angleIdx: 0,          // 0=right, 4=up, 8=left, 12=down (16 steps)
    orient: false,        // upside-down (true = inverted, like ob_orient in original Sopwith)
    stalled: false,       // in stall state
    // Derived velocity (for rendering/collision)
    vx: 0, vy: 0,
    fuel: MAX_FUEL,
    ammo: MAX_AMMO,
    bombCount: MAX_BOMBS,
    fireCooldown: 0,
    bombCooldown: 0,
    invincible: 0,
    landed: true,
    autopilot: false,
    // Input edge detection
    _turnHeld: false,
    _turnTimer: 0,
    _flipHeld: false,
    _autoHeld: false,
    // Frame counter for speed updates (every 4 frames like original)
    moveCount: 0
  };
}

function spawnBuildings() {
  buildings = [];
  // Weighted type pool based on level
  const pool = [];
  const addW = (t, w) => { for (let i = 0; i < w; i++) pool.push(t); };
  addW('hangar', 3); addW('factory', 3); addW('flak', 3);
  if (level >= 2) { addW('bunker', 2); addW('fuel_depot', 2); }
  if (level >= 3) { addW('radar_station', 1); addW('dam', 1); }

  const sizeMap = {
    hangar: [50, 30], factory: [60, 40], flak: [30, 45],
    dam: [100, 25], radar_station: [40, 50], fuel_depot: [45, 30], bunker: [35, 20]
  };
  const hpMap = {
    hangar: 2, factory: 3, flak: 2, dam: 5, radar_station: 2, fuel_depot: 2, bunker: 4
  };

  const minGap = 300;
  let lastX = baseX + BASE_WIDTH + 600;
  const count = 8 + level * 3;
  for (let i = 0; i < count; i++) {
    const bx = lastX + minGap + Math.random() * 400;
    if (bx >= WORLD_W - 200) break;
    const ty = getTerrainY(bx);
    const type = pool[Math.floor(Math.random() * pool.length)];
    const [w, h] = sizeMap[type];
    buildings.push({
      x: bx, y: ty - h, w, h, type,
      hp: hpMap[type],
      alive: true,
      flakTimer: Math.random() * FLAK_INTERVAL | 0,
      isTarget: true
    });
    // Dam: dip terrain on left side (reservoir effect)
    if (type === 'dam') {
      for (let dx = -150; dx < 0; dx++) {
        const ix = Math.floor(((bx + dx) % WORLD_W + WORLD_W) % WORLD_W);
        if (ix >= 0 && ix < WORLD_W) {
          const factor = 1 - Math.abs(dx) / 150;
          terrain[ix] += 8 * factor;
        }
      }
    }
    lastX = bx + w;
  }
}

function spawnEnemies() {
  enemies = [];
  const count = 1 + level;
  let zeppelinCount = 0;
  for (let i = 0; i < count; i++) {
    // Type selection by level
    let type = 'biplane';
    const r = Math.random();
    if (level >= 5 && r < 0.10 && zeppelinCount < 1) { type = 'zeppelin'; zeppelinCount++; }
    else if (level >= 3 && r < 0.25) type = 'bomber';
    else if (level >= 2 && r < 0.50) type = 'jet';

    const spec = ENEMY_SPECS[type];
    const ex = 2000 + Math.random() * (WORLD_W - 3000);
    const ey = type === 'zeppelin' ? 50 + Math.random() * 30 :
               type === 'bomber' ? 80 + Math.random() * 40 :
               100 + Math.random() * 200;
    enemies.push({
      x: ex, y: ey,
      vx: -spec.speed + Math.random() * 40, vy: 0,
      angle: Math.PI,
      hp: spec.hp, alive: true,
      fireTimer: Math.random() * spec.fireInterval | 0,
      type,
      speed: spec.speed,
      stalled: false,
      stallTimer: 0,
      patrolDir: Math.random() < 0.5 ? 1 : -1
    });
  }
}

function spawnAnimals() {
  oxen = [];
  const count = 3 + level;
  for (let i = 0; i < count; i++) {
    const ax = 800 + Math.random() * (WORLD_W - 1000);
    const ty = getTerrainY(ax);
    // Pick animal type based on level
    let type = 'ox';
    const r = Math.random();
    if (level >= 3 && r < 0.15) type = 'camel';
    else if (level >= 2 && r < 0.35) type = 'horse';
    else if (r < 0.55) type = 'sheep';

    const sizeMap = { ox: [20, 10], sheep: [15, 7], horse: [22, 12], camel: [22, 11] };
    const speedMap = { ox: [15, 10], sheep: [25, 10], horse: [40, 10], camel: [12, 6] };
    const [w, h] = sizeMap[type];
    const [spd, spdR] = speedMap[type];

    if (type === 'sheep') {
      // Cluster sheep in groups of 3-4
      const groupSize = 3 + Math.floor(Math.random() * 2);
      for (let j = 0; j < groupSize; j++) {
        const sx = ax + j * 20 + Math.random() * 10;
        const sty = getTerrainY(sx);
        oxen.push({ x: sx, y: sty - h, w, h, alive: true, dir: Math.random() < 0.5 ? 1 : -1, speed: spd + Math.random() * spdR, type });
      }
    } else if (type === 'horse') {
      // Horses run in pairs
      for (let j = 0; j < 2; j++) {
        const hx = ax + j * 30;
        const hty = getTerrainY(hx);
        oxen.push({ x: hx, y: hty - h, w, h, alive: true, dir: Math.random() < 0.5 ? 1 : -1, speed: spd + Math.random() * spdR, type });
      }
    } else {
      oxen.push({ x: ax, y: ty - h, w, h, alive: true, dir: Math.random() < 0.5 ? 1 : -1, speed: spd + Math.random() * spdR, type: type || 'ox' });
    }
  }
}

function spawnBirds() {
  birds = [];
  const count = 2 + level;
  for (let i = 0; i < count; i++) {
    const bx = Math.random() * WORLD_W;
    // Type selection: 50% sparrows, 30% geese, 20% eagles
    const r = Math.random();
    let type = 'sparrow';
    if (r > 0.80) type = 'eagle';
    else if (r > 0.50) type = 'goose';

    const flock = [];
    if (type === 'eagle') {
      // Solitary, higher altitude, wider sinusoidal
      const by = 40 + Math.random() * 120;
      flock.push({ x: bx, y: by, alive: true });
      birds.push({ flock, vx: -25 - Math.random() * 15, vy: 0, type, sinAmp: 30 + Math.random() * 20, sinFreq: 0.002 });
    } else if (type === 'goose') {
      // V-formation
      const by = 80 + Math.random() * 150;
      for (let j = 0; j < 5; j++) {
        const offX = j * 14;
        const offY = Math.abs(j - 2) * 8; // V shape
        flock.push({ x: bx + offX, y: by + offY, alive: true });
      }
      birds.push({ flock, vx: -30 - Math.random() * 20, vy: Math.sin(bx) * 3, type, sinAmp: 5, sinFreq: 0.005 });
    } else {
      // Sparrows - small, fast
      const by = 60 + Math.random() * 200;
      for (let j = 0; j < 5; j++) {
        flock.push({ x: bx + j * 12 + Math.random() * 8, y: by + Math.sin(j) * 10, alive: true });
      }
      birds.push({ flock, vx: -40 - Math.random() * 30, vy: Math.sin(bx) * 5, type, sinAmp: 4, sinFreq: 0.01 });
    }
  }
}

function initLevel() {
  generateTerrain();
  initPlayer();
  bullets = [];
  bombs = [];
  particles = [];
  flakShots = [];
  fleeingPeople = [];
  dragons = [];
  enemyAccuracyDebuff = 0;
  spawnBuildings();
  spawnEnemies();
  spawnAnimals();
  spawnBirds();
  spawnDragons();
}

// ── Particle system ──
function addParticle(x, y, vx, vy, life, color, size) {
  particles.push({ x, y, vx, vy, life, maxLife: life, color, size: size || 2 });
}

function addExplosion(x, y, count, big) {
  for (let i = 0; i < count; i++) {
    const a = Math.random() * Math.PI * 2;
    const sp = (big ? 150 : 80) * Math.random();
    const colors = ['#ff0','#fa0','#f60','#fff','#ff8'];
    addParticle(x, y, Math.cos(a) * sp, Math.sin(a) * sp - 20, 0.4 + Math.random() * 0.4, colors[Math.floor(Math.random() * colors.length)], 2 + Math.random() * (big ? 4 : 2));
  }
}

function addEngineTrail(x, y, vx, vy) {
  addParticle(x, y, vx * 0.1 + (Math.random() - 0.5) * 20, vy * 0.1 + (Math.random() - 0.5) * 20, 0.2 + Math.random() * 0.15, Math.random() < 0.5 ? '#0af' : '#08f', 1.5);
}

// ── Dragon spawning ──
function spawnDragons() {
  if (level >= 4 && Math.random() < 0.5) {
    const dx = 3000 + Math.random() * (WORLD_W - 4000);
    dragons.push({
      x: dx, y: 100 + Math.random() * 100,
      vx: 60, vy: 0,
      hp: 3, alive: true,
      phase: 'circling', // circling, diving, breathing
      breathTimer: 5 + Math.random() * 5,
      wingFrame: 0,
      diveTarget: null,
      breathParticles: []
    });
  }
}

// ── Fleeing people spawning ──
function spawnFleeingPeople(x, groundY) {
  const count = 2 + Math.floor(Math.random() * 3);
  const colors = ['#0ff', '#f0f', '#ff0', '#0f0', '#fa0', '#f55'];
  for (let i = 0; i < count; i++) {
    fleeingPeople.push({
      x: x + (Math.random() - 0.5) * 30,
      y: groundY,
      dir: Math.random() < 0.5 ? -1 : 1,
      speed: 40 + Math.random() * 20,
      life: 4 + Math.random(),
      maxLife: 5,
      frame: Math.random() * Math.PI * 2,
      color: colors[Math.floor(Math.random() * colors.length)]
    });
  }
}

// ── Building destruction special effects ──
function onBuildingDestroyed(bld) {
  // Spawn fleeing people (except bunker)
  if (bld.type !== 'bunker') {
    spawnFleeingPeople(bld.x + bld.w / 2, bld.y + bld.h);
  }

  // Type-specific effects
  if (bld.type === 'dam') {
    // Flood effect: blue particles rushing rightward
    for (let i = 0; i < 40; i++) {
      addParticle(bld.x + bld.w / 2 + Math.random() * 40, bld.y + bld.h,
        80 + Math.random() * 120, -20 + Math.random() * 40,
        1.0 + Math.random() * 0.5, Math.random() < 0.5 ? '#48f' : '#0af', 3 + Math.random() * 2);
    }
    // Lower terrain downstream ~300px
    for (let dx = 0; dx < 300; dx++) {
      const ix = Math.floor(((bld.x + bld.w + dx) % WORLD_W + WORLD_W) % WORLD_W);
      if (ix >= 0 && ix < WORLD_W) {
        const factor = 1 - dx / 300;
        terrain[ix] += (5 + Math.random() * 10) * factor;
      }
    }
    playFlood();
  } else if (bld.type === 'fuel_depot') {
    // Chain explosion: massive explosion + damage nearby buildings
    addExplosion(bld.x + bld.w / 2, bld.y + bld.h / 2, 60, true);
    for (const other of buildings) {
      if (!other.alive || other === bld) continue;
      const dist = Math.abs((other.x + other.w / 2) - (bld.x + bld.w / 2));
      if (dist < 150) {
        other.hp -= 2;
        if (other.hp <= 0) {
          other.alive = false;
          addExplosion(other.x + other.w / 2, other.y + other.h / 2, 20, true);
          score += buildingScores[other.type] || 100;
          if (other.type !== 'bunker') spawnFleeingPeople(other.x + other.w / 2, other.y + other.h);
        }
      }
    }
  } else if (bld.type === 'radar_station') {
    enemyAccuracyDebuff = 15; // 15 seconds of doubled enemy fire intervals
  }
}

// ── Drawing helpers ──
function neonGlow(ctx, color, blur) {
  ctx.shadowColor = color;
  ctx.shadowBlur = blur;
}
function clearGlow(ctx) {
  ctx.shadowColor = 'transparent';
  ctx.shadowBlur = 0;
}

function drawBiplane(ctx, x, y, angle, facingLeft, color, scale, upsideDown) {
  scale = scale || 1;
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(angle);
  if (facingLeft) ctx.scale(-1, 1);
  if (upsideDown) ctx.scale(1, -1);
  ctx.scale(scale, scale);

  neonGlow(ctx, color, 8);
  ctx.strokeStyle = color;
  ctx.lineWidth = 1.5;

  // ── Fuselage (centered on y=0, nose right) ──
  // Rounded body shape, wider at cockpit
  ctx.beginPath();
  ctx.moveTo(-20, 1);         // tail bottom
  ctx.lineTo(-8, 2);          // rear bottom
  ctx.lineTo(12, 2);          // belly
  ctx.lineTo(20, 0);          // nose tip
  ctx.lineTo(12, -3);         // nose top
  ctx.lineTo(-8, -3);         // cockpit top
  ctx.lineTo(-20, -1);        // tail top
  ctx.closePath();
  ctx.stroke();

  // ── Cockpit canopy ──
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(0, -3);
  ctx.quadraticCurveTo(2, -6, 6, -3);
  ctx.stroke();

  // ── Top wing (above fuselage) ──
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(-10, -7);
  ctx.lineTo(12, -7);
  ctx.lineTo(14, -6);
  ctx.lineTo(-10, -6);
  ctx.closePath();
  ctx.stroke();

  // ── Bottom wing (below fuselage) ──
  ctx.beginPath();
  ctx.moveTo(-8, 4);
  ctx.lineTo(12, 4);
  ctx.lineTo(14, 5);
  ctx.lineTo(-8, 5);
  ctx.closePath();
  ctx.stroke();

  // ── Wing struts ──
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(-2, -7);
  ctx.lineTo(-2, 5);
  ctx.moveTo(8, -7);
  ctx.lineTo(8, 5);
  ctx.stroke();

  // ── Tail fin (vertical stabilizer, points UP) ──
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(-20, -1);
  ctx.lineTo(-24, -7);
  ctx.lineTo(-18, -7);
  ctx.lineTo(-16, -3);
  ctx.stroke();

  // ── Tail plane (horizontal stabilizer) ──
  ctx.beginPath();
  ctx.moveTo(-22, 0);
  ctx.lineTo(-26, -1);
  ctx.lineTo(-26, 1);
  ctx.lineTo(-22, 1);
  ctx.stroke();

  // ── Landing gear (two small struts + wheels) ──
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(0, 5);
  ctx.lineTo(-1, 9);
  ctx.moveTo(8, 5);
  ctx.lineTo(7, 9);
  // Axle
  ctx.moveTo(-2, 9);
  ctx.lineTo(8, 9);
  ctx.stroke();
  // Wheels
  ctx.beginPath();
  ctx.arc(-1, 10, 1.5, 0, Math.PI * 2);
  ctx.stroke();
  ctx.beginPath();
  ctx.arc(7, 10, 1.5, 0, Math.PI * 2);
  ctx.stroke();

  // ── Propeller (spinning) ──
  ctx.lineWidth = 2;
  ctx.strokeStyle = color;
  const pt = Date.now() * 0.03;
  const pLen = 7;
  ctx.beginPath();
  ctx.moveTo(20, -pLen * Math.sin(pt));
  ctx.lineTo(20, pLen * Math.sin(pt));
  ctx.stroke();

  // ── Engine cowling (nose cap) ──
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(18, -3);
  ctx.lineTo(18, 2);
  ctx.stroke();

  clearGlow(ctx);
  ctx.restore();
}

function drawJet(ctx, x, y, angle, facingLeft, color, scale) {
  scale = scale || 1;
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(angle);
  if (facingLeft) ctx.scale(-1, 1);
  ctx.scale(scale, scale);

  neonGlow(ctx, color, 8);
  ctx.strokeStyle = color;
  ctx.lineWidth = 1.5;

  // Pointed triangular fuselage
  ctx.beginPath();
  ctx.moveTo(22, 0);          // nose tip
  ctx.lineTo(-14, -4);        // top rear
  ctx.lineTo(-18, -3);        // tail notch top
  ctx.lineTo(-18, 3);         // tail notch bottom
  ctx.lineTo(-14, 4);         // bottom rear
  ctx.closePath();
  ctx.stroke();

  // Swept-back delta wings
  ctx.beginPath();
  ctx.moveTo(-2, -4);
  ctx.lineTo(-14, -14);
  ctx.lineTo(-10, -4);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(-2, 4);
  ctx.lineTo(-14, 14);
  ctx.lineTo(-10, 4);
  ctx.stroke();

  // Bubble canopy
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(8, -3);
  ctx.quadraticCurveTo(12, -6, 16, -3);
  ctx.stroke();

  // Vertical tail fin
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(-16, -3);
  ctx.lineTo(-20, -10);
  ctx.lineTo(-14, -8);
  ctx.stroke();

  // Afterburner glow (pulsing)
  const abPulse = 0.5 + 0.5 * Math.sin(Date.now() * 0.02);
  ctx.fillStyle = `rgba(255, ${Math.floor(160 * abPulse)}, 0, ${0.5 + abPulse * 0.5})`;
  ctx.beginPath();
  ctx.arc(-20, 0, 3 + abPulse * 2, 0, Math.PI * 2);
  ctx.fill();

  clearGlow(ctx);
  ctx.restore();
}

function drawBomber(ctx, x, y, angle, facingLeft, color, scale) {
  scale = scale || 1;
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(angle);
  if (facingLeft) ctx.scale(-1, 1);
  ctx.scale(scale, scale);

  neonGlow(ctx, color, 8);
  ctx.strokeStyle = color;
  ctx.lineWidth = 1.5;

  // Wider fuselage
  ctx.beginPath();
  ctx.moveTo(-22, 2);
  ctx.lineTo(-10, 4);
  ctx.lineTo(18, 3);
  ctx.lineTo(24, 0);
  ctx.lineTo(18, -4);
  ctx.lineTo(-10, -4);
  ctx.lineTo(-22, -2);
  ctx.closePath();
  ctx.stroke();

  // Long straight wings
  ctx.beginPath();
  ctx.moveTo(-12, -4);
  ctx.lineTo(14, -4);
  ctx.lineTo(16, -5);
  ctx.lineTo(-12, -5);
  ctx.closePath();
  ctx.stroke();
  // Wing extension (wider span)
  ctx.beginPath();
  ctx.moveTo(-8, -5); ctx.lineTo(-8, -16);
  ctx.moveTo(8, -5); ctx.lineTo(8, -16);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(-8, 4); ctx.lineTo(-8, 16);
  ctx.moveTo(8, 4); ctx.lineTo(8, 16);
  ctx.stroke();

  // Engine nacelles (rectangles under wings)
  ctx.strokeRect(-4, -18, 6, 4);
  ctx.strokeRect(-4, 14, 6, 4);

  // Twin tail fins
  ctx.beginPath();
  ctx.moveTo(-20, -2);
  ctx.lineTo(-24, -8);
  ctx.lineTo(-18, -6);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(-20, 2);
  ctx.lineTo(-24, 8);
  ctx.lineTo(-18, 6);
  ctx.stroke();

  // Bomb bay doors (dashed line underneath)
  ctx.lineWidth = 1;
  ctx.setLineDash([3, 3]);
  ctx.beginPath();
  ctx.moveTo(-6, 4);
  ctx.lineTo(10, 4);
  ctx.stroke();
  ctx.setLineDash([]);

  // Two spinning propellers
  ctx.lineWidth = 2;
  const pt = Date.now() * 0.03;
  const pLen = 5;
  ctx.beginPath();
  ctx.moveTo(-1, -18 - pLen * Math.sin(pt));
  ctx.lineTo(-1, -18 + pLen * Math.sin(pt));
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(-1, 18 - pLen * Math.sin(pt + 1));
  ctx.lineTo(-1, 18 + pLen * Math.sin(pt + 1));
  ctx.stroke();

  clearGlow(ctx);
  ctx.restore();
}

function drawZeppelin(ctx, x, y, angle, facingLeft, color, scale) {
  scale = scale || 1;
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(angle);
  if (facingLeft) ctx.scale(-1, 1);
  ctx.scale(scale, scale);

  neonGlow(ctx, color, 8);
  ctx.strokeStyle = color;
  ctx.lineWidth = 1.5;

  // Large elongated ellipse (envelope)
  ctx.beginPath();
  ctx.ellipse(0, 0, 40, 10, 0, 0, Math.PI * 2);
  ctx.stroke();

  // Internal frame lines
  for (let fx = -20; fx <= 20; fx += 13) {
    ctx.beginPath();
    ctx.moveTo(fx, -9);
    ctx.lineTo(fx, 9);
    ctx.stroke();
  }

  // Gondola rectangle hanging below
  ctx.strokeRect(-8, 12, 16, 6);
  // Connection lines
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(-6, 10); ctx.lineTo(-8, 12);
  ctx.moveTo(6, 10); ctx.lineTo(8, 12);
  ctx.stroke();

  // Cross-shaped rear stabilizer fins
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(-38, 0); ctx.lineTo(-46, -8);
  ctx.moveTo(-38, 0); ctx.lineTo(-46, 8);
  ctx.moveTo(-38, -5); ctx.lineTo(-46, 0);
  ctx.moveTo(-38, 5); ctx.lineTo(-46, 0);
  ctx.stroke();

  clearGlow(ctx);
  ctx.restore();
}

function drawDragon(ctx, dragon) {
  const d = dragon;
  ctx.save();
  ctx.translate(d.x, d.y);

  const wingFlap = Math.sin(d.wingFrame) * 0.4;
  const facingLeft = d.vx < 0;
  if (facingLeft) ctx.scale(-1, 1);

  neonGlow(ctx, '#f40', 10);
  ctx.strokeStyle = '#f40';
  ctx.lineWidth = 2;

  // Serpentine body (bezier curve)
  ctx.beginPath();
  ctx.moveTo(-25, 0);
  ctx.bezierCurveTo(-15, -5, 0, 5, 15, 0);
  ctx.bezierCurveTo(20, -2, 25, 0, 30, 2);
  ctx.stroke();

  // Head with horns and open jaw
  ctx.beginPath();
  ctx.moveTo(-25, 0);
  ctx.lineTo(-32, -3);  // upper jaw
  ctx.moveTo(-25, 0);
  ctx.lineTo(-30, 3);   // lower jaw
  // Horns
  ctx.moveTo(-24, -2);
  ctx.lineTo(-22, -8);
  ctx.moveTo(-20, -3);
  ctx.lineTo(-18, -9);
  ctx.stroke();

  // Eye
  ctx.fillStyle = '#ff0';
  ctx.beginPath();
  ctx.arc(-26, -1, 1.5, 0, Math.PI * 2);
  ctx.fill();

  // Bat-like wings (triangular, animated flap)
  ctx.strokeStyle = '#f40';
  ctx.beginPath();
  ctx.moveTo(-5, -2);
  ctx.lineTo(-15, -18 + wingFlap * 20);
  ctx.lineTo(5, -8 + wingFlap * 10);
  ctx.lineTo(10, -2);
  ctx.stroke();
  // Wing membrane lines
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(-10, -2);
  ctx.lineTo(-12, -15 + wingFlap * 18);
  ctx.moveTo(0, -2);
  ctx.lineTo(-5, -12 + wingFlap * 14);
  ctx.stroke();

  // Tail trailing behind
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(30, 2);
  ctx.quadraticCurveTo(38, 8, 42, 4);
  ctx.lineTo(46, 6);
  ctx.stroke();

  // Fire breath when in breathing phase
  if (d.phase === 'breathing') {
    ctx.strokeStyle = '#ff0';
    neonGlow(ctx, '#f80', 12);
    ctx.lineWidth = 1;
    for (let i = 0; i < 5; i++) {
      const fx = -32 - i * 4 - Math.random() * 3;
      const fy = (Math.random() - 0.5) * (4 + i * 2);
      ctx.beginPath();
      ctx.arc(fx, fy, 1.5 + Math.random(), 0, Math.PI * 2);
      ctx.stroke();
    }
  }

  clearGlow(ctx);
  ctx.restore();
}

function drawPerson(person) {
  const p = person;
  const alpha = p.life < 1 ? p.life : 1;
  ctx.globalAlpha = alpha;
  neonGlow(ctx, p.color, 4);
  ctx.strokeStyle = p.color;
  ctx.lineWidth = 1;

  const legAnim = Math.sin(p.frame * 8) * 3;
  const armAnim = Math.sin(p.frame * 6) * 2;

  // Head
  ctx.beginPath();
  ctx.arc(p.x, p.y - 7, 1.5, 0, Math.PI * 2);
  ctx.stroke();
  // Body
  ctx.beginPath();
  ctx.moveTo(p.x, p.y - 5.5);
  ctx.lineTo(p.x, p.y - 2);
  ctx.stroke();
  // Arms (waving)
  ctx.beginPath();
  ctx.moveTo(p.x - 2 - armAnim, p.y - 5);
  ctx.lineTo(p.x, p.y - 4);
  ctx.lineTo(p.x + 2 + armAnim, p.y - 5);
  ctx.stroke();
  // Legs (running)
  ctx.beginPath();
  ctx.moveTo(p.x - 1.5 - legAnim, p.y);
  ctx.lineTo(p.x, p.y - 2);
  ctx.lineTo(p.x + 1.5 + legAnim, p.y);
  ctx.stroke();

  clearGlow(ctx);
  ctx.globalAlpha = 1;
}

function drawAnimal(animal) {
  const o = animal;
  const type = o.type || 'ox';
  if (type === 'ox') {
    drawOx(o);
    return;
  }

  if (type === 'sheep') {
    neonGlow(ctx, '#ddd', 6);
    ctx.strokeStyle = '#ddd';
    ctx.lineWidth = 1.5;
    // Fluffy body (rounded rect with wavy top)
    ctx.beginPath();
    ctx.moveTo(o.x + 2, o.y + 2);
    ctx.lineTo(o.x + 13, o.y + 2);
    ctx.lineTo(o.x + 13, o.y + 6);
    ctx.lineTo(o.x + 2, o.y + 6);
    ctx.closePath();
    ctx.stroke();
    // Wavy top (fluffy)
    ctx.beginPath();
    ctx.moveTo(o.x + 2, o.y + 2);
    for (let wx = 3; wx < 13; wx += 2) {
      ctx.lineTo(o.x + wx, o.y + 2 - Math.sin(wx) * 1.5);
    }
    ctx.stroke();
    // Legs
    ctx.beginPath();
    ctx.moveTo(o.x + 4, o.y + 6); ctx.lineTo(o.x + 4, o.y + 8);
    ctx.moveTo(o.x + 11, o.y + 6); ctx.lineTo(o.x + 11, o.y + 8);
    ctx.stroke();
    // Head
    const headX = o.dir > 0 ? o.x + 13 : o.x + 2;
    ctx.beginPath();
    ctx.arc(headX, o.y + 2, 2, 0, Math.PI * 2);
    ctx.stroke();
    clearGlow(ctx);
  } else if (type === 'horse') {
    neonGlow(ctx, '#a72', 6);
    ctx.strokeStyle = '#a72';
    ctx.lineWidth = 1.5;
    // Body
    ctx.strokeRect(o.x + 3, o.y + 2, 16, 6);
    // Taller legs
    ctx.beginPath();
    ctx.moveTo(o.x + 5, o.y + 8); ctx.lineTo(o.x + 5, o.y + 12);
    ctx.moveTo(o.x + 8, o.y + 8); ctx.lineTo(o.x + 8, o.y + 12);
    ctx.moveTo(o.x + 15, o.y + 8); ctx.lineTo(o.x + 15, o.y + 12);
    ctx.moveTo(o.x + 18, o.y + 8); ctx.lineTo(o.x + 18, o.y + 12);
    ctx.stroke();
    // Longer neck and head
    const headX = o.dir > 0 ? o.x + 19 : o.x + 3;
    const neckDir = o.dir > 0 ? 1 : -1;
    ctx.beginPath();
    ctx.moveTo(headX, o.y + 2);
    ctx.lineTo(headX + neckDir * 3, o.y - 3);
    ctx.lineTo(headX + neckDir * 7, o.y - 3);
    ctx.lineTo(headX + neckDir * 7, o.y);
    ctx.stroke();
    // Mane
    ctx.beginPath();
    ctx.moveTo(headX + neckDir * 1, o.y);
    ctx.lineTo(headX + neckDir * 4, o.y - 5);
    ctx.stroke();
    // Tail
    const tailX = o.dir > 0 ? o.x + 3 : o.x + 19;
    ctx.beginPath();
    ctx.moveTo(tailX, o.y + 2);
    ctx.quadraticCurveTo(tailX - neckDir * 5, o.y, tailX - neckDir * 4, o.y + 5);
    ctx.stroke();
    clearGlow(ctx);
  } else if (type === 'camel') {
    neonGlow(ctx, '#da8', 6);
    ctx.strokeStyle = '#da8';
    ctx.lineWidth = 1.5;
    // Body
    ctx.strokeRect(o.x + 3, o.y + 2, 16, 5);
    // Humps (1-2 arcs on back)
    ctx.beginPath();
    ctx.arc(o.x + 8, o.y + 2, 3, Math.PI, 0);
    ctx.arc(o.x + 15, o.y + 2, 2.5, Math.PI, 0);
    ctx.stroke();
    // Longer legs
    ctx.beginPath();
    ctx.moveTo(o.x + 5, o.y + 7); ctx.lineTo(o.x + 5, o.y + 12);
    ctx.moveTo(o.x + 8, o.y + 7); ctx.lineTo(o.x + 8, o.y + 12);
    ctx.moveTo(o.x + 15, o.y + 7); ctx.lineTo(o.x + 15, o.y + 12);
    ctx.moveTo(o.x + 18, o.y + 7); ctx.lineTo(o.x + 18, o.y + 12);
    ctx.stroke();
    // Long neck
    const headX = o.dir > 0 ? o.x + 19 : o.x + 3;
    const neckDir = o.dir > 0 ? 1 : -1;
    ctx.beginPath();
    ctx.moveTo(headX, o.y + 2);
    ctx.lineTo(headX + neckDir * 2, o.y - 5);
    ctx.lineTo(headX + neckDir * 5, o.y - 5);
    ctx.stroke();
    // Head
    ctx.beginPath();
    ctx.arc(headX + neckDir * 5, o.y - 5, 2, 0, Math.PI * 2);
    ctx.stroke();
    clearGlow(ctx);
  }
}

// ── Camera ──
let camX = 0, camY = 0;

function updateCamera() {
  const targetX = player.x - canvas.width * 0.35;
  const targetY = player.y - canvas.height * 0.45;
  camX += (targetX - camX) * 0.08;
  camY += (targetY - camY) * 0.06;
  // Clamp vertical
  camY = Math.max(-100, Math.min(camY, 400));
}

// ── Update logic ──
let lastTime = 0;
let frameCount = 0;

function update(dt) {
  frameCount++;
  if (state === ST.PLAYING) {
    if (enemyAccuracyDebuff > 0) enemyAccuracyDebuff -= dt;
    updatePlayer(dt);
    updateBullets(dt);
    updateBombs(dt);
    updateEnemies(dt);
    updateFlak(dt);
    updateBirds(dt);
    updateOxen(dt);
    updateFleeingPeople(dt);
    updateDragons(dt);
    updateParticles(dt);
    updateCamera();
    checkLevelComplete();
    updateHUD();
  } else if (state === ST.DYING) {
    updateParticles(dt);
    deathTimer -= dt;
    if (deathTimer <= 0) {
      if (lives <= 0) {
        state = ST.GAME_OVER;
      } else {
        initPlayer();
        player.invincible = 3; // 3 seconds of invincibility after respawn
        // Clear hostile projectiles near spawn
        bullets = bullets.filter(b => b.friendly);
        bombs = bombs.filter(b => b.friendly !== false);
        flakShots = [];
        state = ST.PLAYING;
      }
    }
  } else if (state === ST.LEVEL_COMPLETE) {
    updateParticles(dt);
    levelTimer -= dt;
    if (levelTimer <= 0) {
      level++;
      initLevel();
      state = ST.PLAYING;
    }
  }
}

// ── Angle helpers ──
// Angle indices: 0=right, 4=up, 8=left, 12=down (counterclockwise)
// "Nose up" = increment toward 4, "Nose down" = decrement toward 12 (via 0→15→14→13...)

function getEffectiveAngle(p) {
  // angleIdx directly determines direction via COS/SIN tables — no mirroring needed
  return p.angleIdx;
}

// Radian angle for canvas rendering (canvas: 0=right, positive=clockwise=down)
function getPlaneRadians(p) {
  const effAngle = getEffectiveAngle(p);
  // effAngle goes counterclockwise, canvas goes clockwise, so negate
  return -effAngle * ANGLE_STEP;
}

function updatePlayer(dt) {
  const p = player;
  p.moveCount++;

  // ── Autopilot: fly home ──
  if (p.autopilot) {
    // Cancel orient — autopilot flies right-side-up
    p.orient = false;

    const homeX = baseX + BASE_WIDTH / 2;
    // World-aware signed distance to home
    let dx = homeX - p.x;
    if (dx > WORLD_W / 2) dx -= WORLD_W;
    if (dx < -WORLD_W / 2) dx += WORLD_W;

    const absDx = Math.abs(dx);
    // Desired heading: 0 = rightward, 8 = leftward
    const targetHeading = dx > 0 ? 0 : 8;

    if (absDx > 200) {
      // Cruise phase: steer toward target heading, full throttle
      p.accel = PLANE_MAX_ACCEL;
      // Move angleIdx toward targetHeading via shortest path
      if (p.angleIdx !== targetHeading) {
        const diff = ((targetHeading - p.angleIdx) + NUM_ANGLES) % NUM_ANGLES;
        if (diff <= 8) p.angleIdx = (p.angleIdx + 1) % NUM_ANGLES;
        else p.angleIdx = ((p.angleIdx - 1) + NUM_ANGLES) % NUM_ANGLES;
      }
    } else {
      // Approach phase: level off at runway altitude, slow down
      const homeY = getTerrainY(homeX) - 12;
      const dyToHome = p.y - homeY;

      // Ease off throttle as we approach
      if (absDx < 100) {
        if (p.accel > 1) p.accel--;
      } else {
        p.accel = PLANE_MAX_ACCEL - 1;
      }

      // Steer toward level flight heading
      if (p.angleIdx !== targetHeading) {
        const diff = ((targetHeading - p.angleIdx) + NUM_ANGLES) % NUM_ANGLES;
        if (diff <= 8) p.angleIdx = (p.angleIdx + 1) % NUM_ANGLES;
        else p.angleIdx = ((p.angleIdx - 1) + NUM_ANGLES) % NUM_ANGLES;
      } else if (dyToHome > 10) {
        // Too low (below runway), nose up slightly
        p.angleIdx = (p.angleIdx + 1) % NUM_ANGLES;
      } else if (dyToHome < -30) {
        // Too high, nose down slightly
        p.angleIdx = ((p.angleIdx - 1) + NUM_ANGLES) % NUM_ANGLES;
      }

      // Landing check
      const groundY = getTerrainY(p.x);
      const nearBase = p.x > baseX - 30 && p.x < baseX + BASE_WIDTH + 30;
      const apLevelEnough = (p.angleIdx <= 1 || p.angleIdx >= 15 || (p.angleIdx >= 7 && p.angleIdx <= 9));
      if (nearBase && p.y >= groundY - 15 && p.speed <= PLANE_MIN_SPEED + 2 && apLevelEnough) {
        p.landed = true;
        p.autopilot = false;
        p.speed = 0; p.accel = 0; p.angleIdx = 0;
        p.vx = 0; p.vy = 0; p.y = groundY - 8;
        p.fuel = MAX_FUEL; p.ammo = MAX_AMMO; p.bombCount = MAX_BOMBS;
        return;
      }
    }
  }

  // ── Manual controls ──
  if (!p.autopilot) {
    // Accelerate (X or ArrowUp)
    if (keys['KeyX'] || keys['ArrowUp']) {
      if (p.accel < PLANE_MAX_ACCEL) p.accel++;
    }
    // Decelerate (Backslash)
    if (keys['Backslash'] || keys['Backquote']) {
      if (p.accel > 0) p.accel--;
    }

    // Pitch: when orient=false, nose-up increments angleIdx; when orient=true, it decrements (inverted)
    // This matches original Sopwith: if (ob->ob_orient) nangle -= update; else nangle += update;
    const pitchUp = p.orient ? -1 : 1;
    const pitchDown = p.orient ? 1 : -1;

    // Nose up (Comma or ArrowUp)
    if (keys['Comma'] || keys['ArrowUp']) {
      if (!p._turnHeld) {
        p.angleIdx = ((p.angleIdx + pitchUp) + NUM_ANGLES) % NUM_ANGLES;
        p._turnHeld = true;
        p._turnTimer = 0;
      } else {
        p._turnTimer++;
        if (p._turnTimer >= 10) {
          p.angleIdx = ((p.angleIdx + pitchUp) + NUM_ANGLES) % NUM_ANGLES;
          p._turnTimer = 0;
        }
      }
    }
    // Nose down (Slash or ArrowDown)
    else if (keys['Slash'] || keys['ArrowDown']) {
      if (!p._turnHeld) {
        p.angleIdx = ((p.angleIdx + pitchDown) + NUM_ANGLES) % NUM_ANGLES;
        p._turnHeld = true;
        p._turnTimer = 0;
      } else {
        p._turnTimer++;
        if (p._turnTimer >= 10) {
          p.angleIdx = ((p.angleIdx + pitchDown) + NUM_ANGLES) % NUM_ANGLES;
          p._turnTimer = 0;
        }
      }
    } else {
      p._turnHeld = false;
      p._turnTimer = 0;
    }

    // Flip (Period or F) — toggles upside-down orientation, does NOT change angleIdx or direction
    if (keys['Period'] || keys['KeyF']) {
      if (!p._flipHeld && !p.landed) {
        p.orient = !p.orient;
        p.autopilot = false;
        p._flipHeld = true;
      }
    } else {
      p._flipHeld = false;
    }

    // Autopilot (H) — toggle; any other manual input cancels it
    if (keys['KeyH']) {
      if (!p._autoHeld) { p.autopilot = !p.autopilot; p._autoHeld = true; }
    } else { p._autoHeld = false; }

    // Cancel autopilot on any manual input (pitch, throttle, fire, bomb, flip)
    if (p.autopilot && (keys['Comma'] || keys['Slash'] || keys['ArrowUp'] || keys['ArrowDown']
        || keys['KeyX'] || keys['Backslash'] || keys['Backquote'] || keys['Space'] || keys['KeyB'])) {
      p.autopilot = false;
    }

    // Fire
    if (keys['Space'] && p.fireCooldown <= 0 && p.ammo > 0) {
      const rad = getPlaneRadians(p);
      const bx = p.x + Math.cos(rad) * 25;
      const by = p.y + Math.sin(rad) * 25;
      const bvx = Math.cos(rad) * BULLET_SPEED + p.vx * 0.3;
      const bvy = Math.sin(rad) * BULLET_SPEED + p.vy * 0.3;
      bullets.push({ x: bx, y: by, vx: bvx, vy: bvy, life: 1.2, friendly: true });
      p.ammo--;
      p.fireCooldown = 0.08;
      playShoot();
    }

    // Bomb
    if (keys['KeyB'] && p.bombCooldown <= 0 && p.bombCount > 0) {
      bombs.push({ x: p.x, y: p.y + 5, vx: p.vx * BOMB_VXFRAC, vy: p.vy + 20, life: 5, friendly: true });
      p.bombCount--;
      p.bombCooldown = 0.4;
      playBombDrop();
    }
  }

  p.fireCooldown -= dt;
  p.bombCooldown -= dt;
  if (p.invincible > 0) p.invincible -= dt;

  // ── Sopwith-style physics ──
  if (!p.landed) {
    const effAngle = getEffectiveAngle(p);

    // Speed update every 3 frames (slightly faster than original for responsiveness)
    if (p.moveCount % 3 === 0) {
      const grav = GRAVITY_TABLE[effAngle];
      const targetSpeed = PLANE_MIN_SPEED + p.accel + grav;
      if (p.speed < targetSpeed) p.speed++;
      else if (p.speed > targetSpeed) p.speed--;
      if (p.speed > PLANE_MAX_SPEED) p.speed = PLANE_MAX_SPEED;
    }

    // Stall: speed too low
    if (p.speed <= STALL_SPEED && !p.stalled) {
      p.stalled = true;
    }

    if (p.stalled) {
      // Nose drops toward "down" (angleIdx 12 = straight down)
      if (p.moveCount % 6 === 0) {
        if (p.angleIdx !== 12) {
          const diff = ((12 - p.angleIdx) + NUM_ANGLES) % NUM_ANGLES;
          if (diff <= 8) p.angleIdx = (p.angleIdx + 1) % NUM_ANGLES;
          else p.angleIdx = ((p.angleIdx - 1) + NUM_ANGLES) % NUM_ANGLES;
        }
      }
      // Recover when speed adequate and near level flight
      if (p.speed >= PLANE_MIN_SPEED && (effAngle <= 2 || effAngle >= 14)) {
        p.stalled = false;
      }
    }

    // Velocity from speed + angle
    // COS_TABLE/SIN_TABLE: index 0=right, 4=up in math coords
    // Canvas: Y-down, so negate SIN for vy
    p.vx = COS_TABLE[effAngle] * p.speed * PIXELS_PER_UNIT;
    p.vy = -SIN_TABLE[effAngle] * p.speed * PIXELS_PER_UNIT;

    // Stall gravity
    if (p.stalled || p.speed < PLANE_MIN_SPEED) {
      p.vy += 150 * dt;
    }

    // Move
    p.x += p.vx * dt;
    p.y += p.vy * dt;

    // Fuel
    p.fuel -= dt * (15 + p.accel * 8);
    if (p.fuel <= 0) { p.fuel = 0; p.accel = 0; }

    // Engine trail
    if (p.accel > 0) {
      const rad = getPlaneRadians(p);
      const tx = p.x - Math.cos(rad) * 20;
      const ty = p.y - Math.sin(rad) * 20;
      addEngineTrail(tx, ty, -p.vx * 0.3, -p.vy * 0.3);
    }

    // World wrap
    if (p.x < 0) p.x += WORLD_W;
    if (p.x >= WORLD_W) p.x -= WORLD_W;

    // Ceiling
    if (p.y < -50) {
      p.y = -50;
      p.stalled = true;
      p.speed = 0;
    }

    // Ground collision
    const groundY = getTerrainY(p.x);
    if (p.y >= groundY - 8) {
      const nearBase = p.x > baseX - 30 && p.x < baseX + BASE_WIDTH + 30;
      // Level = angleIdx near 0 (rightward: 0,1,15) or near 8 (leftward: 7,8,9)
      const levelEnough = (p.angleIdx <= 1 || p.angleIdx >= 15 || (p.angleIdx >= 7 && p.angleIdx <= 9));
      const slowEnough = p.speed <= PLANE_MIN_SPEED + 2;

      if (nearBase && levelEnough && slowEnough && !p.stalled && !p.orient) {
        p.y = groundY - 8;
        p.vy = 0; p.vx = 0; p.speed = 0; p.accel = 0; p.angleIdx = 0;
        p.orient = false;
        p.landed = true; p.stalled = false;
        p.fuel = MAX_FUEL; p.ammo = MAX_AMMO; p.bombCount = MAX_BOMBS;
      } else {
        killPlayer();
        return;
      }
    }
  } else {
    // ── On ground at base ──
    if (keys['KeyX'] || keys['ArrowUp']) {
      p.landed = false;
      p.stalled = false;
      p.orient = false;
      p.accel = PLANE_MAX_ACCEL;
      p.speed = PLANE_MAX_SPEED - 1;
      p.angleIdx = 2; // Slight nose-up: index 2 = climbing right at ~45°
    }
    p.y = getTerrainY(p.x) - 8;
  }
}

function killPlayer() {
  addExplosion(player.x, player.y, 40, true);
  playBoom(true);
  // Crater in terrain
  for (let dx = -30; dx <= 30; dx++) {
    const ix = Math.floor(((player.x + dx) % WORLD_W + WORLD_W) % WORLD_W);
    if (ix >= 0 && ix < WORLD_W) {
      terrain[ix] += (30 - Math.abs(dx)) * 0.5;
    }
  }
  lives--;
  state = ST.DYING;
  deathTimer = 2;
}

function updateBullets(dt) {
  for (let i = bullets.length - 1; i >= 0; i--) {
    const b = bullets[i];
    b.x += b.vx * dt;
    b.y += b.vy * dt;
    b.vy += PROJ_GRAVITY * 0.3 * dt;
    b.life -= dt;

    // World wrap
    if (b.x < 0) b.x += WORLD_W;
    if (b.x >= WORLD_W) b.x -= WORLD_W;

    // Ground hit
    if (b.y >= getTerrainY(b.x)) {
      addParticle(b.x, b.y, 0, -30, 0.2, '#ff0', 2);
      bullets.splice(i, 1);
      continue;
    }

    if (b.life <= 0 || b.y < -200) {
      bullets.splice(i, 1);
      continue;
    }

    // Hit buildings (friendly bullets only)
    if (b.friendly) {
      for (const bld of buildings) {
        if (!bld.alive) continue;
        if (b.x > bld.x && b.x < bld.x + bld.w && b.y > bld.y && b.y < bld.y + bld.h) {
          bld.hp--;
          if (bld.hp <= 0) {
            bld.alive = false;
            addExplosion(bld.x + bld.w / 2, bld.y + bld.h / 2, 25, true);
            playBoom(true);
            score += buildingScores[bld.type] || 100;
            // Terrain crater
            for (let dx = -20; dx <= 20; dx++) {
              const ix = Math.floor(((bld.x + bld.w / 2 + dx) % WORLD_W + WORLD_W) % WORLD_W);
              if (ix >= 0 && ix < WORLD_W) terrain[ix] += (20 - Math.abs(dx)) * 0.3;
            }
            onBuildingDestroyed(bld);
          } else {
            addExplosion(b.x, b.y, 5, false);
            // Dam hit: extra blue splash
            if (bld.type === 'dam') {
              for (let k = 0; k < 6; k++) {
                addParticle(b.x, b.y, (Math.random()-0.5)*60, -30-Math.random()*40, 0.4, '#48f', 2);
              }
            }
          }
          bullets.splice(i, 1);
          break;
        }
      }
    }

    // Friendly bullets hit enemies (type-aware hitbox)
    if (b.friendly) {
      for (const en of enemies) {
        if (!en.alive) continue;
        const spec = ENEMY_SPECS[en.type] || ENEMY_SPECS.biplane;
        if (Math.abs(b.x - en.x) < spec.hitW && Math.abs(b.y - en.y) < spec.hitH) {
          en.hp--;
          if (en.hp <= 0) {
            en.alive = false;
            addExplosion(en.x, en.y, 20, true);
            playBoom(false);
            score += spec.score;
          }
          bullets.splice(i, 1);
          break;
        }
      }
    }

    // Friendly bullets hit dragons
    if (b.friendly) {
      for (const d of dragons) {
        if (!d.alive) continue;
        if (Math.abs(b.x - d.x) < 25 && Math.abs(b.y - d.y) < 15) {
          d.hp--;
          if (d.hp <= 0) {
            d.alive = false;
            addExplosion(d.x, d.y, 40, true);
            playBoom(true);
            score += 1000;
          } else {
            addExplosion(b.x, b.y, 5, false);
          }
          bullets.splice(i, 1);
          break;
        }
      }
    }

    // Enemy bullets hit player
    if (!b.friendly && player.invincible <= 0) {
      if (Math.abs(b.x - player.x) < 18 && Math.abs(b.y - player.y) < 10) {
        killPlayer();
        bullets.splice(i, 1);
        break;
      }
    }
  }
}

function updateBombs(dt) {
  for (let i = bombs.length - 1; i >= 0; i--) {
    const b = bombs[i];
    b.x += b.vx * dt;
    b.y += b.vy * dt;
    b.vy += PROJ_GRAVITY * dt;
    b.life -= dt;

    if (b.x < 0) b.x += WORLD_W;
    if (b.x >= WORLD_W) b.x -= WORLD_W;

    let hit = false;

    // Ground hit
    if (b.y >= getTerrainY(b.x)) {
      hit = true;
    }

    // Building hit (only player/friendly bombs damage buildings)
    if (b.friendly !== false) {
      for (const bld of buildings) {
        if (!bld.alive) continue;
        if (b.x > bld.x - 5 && b.x < bld.x + bld.w + 5 && b.y > bld.y - 5 && b.y < bld.y + bld.h + 5) {
          bld.hp -= 2;
          if (bld.hp <= 0) {
            bld.alive = false;
            score += buildingScores[bld.type] || 100;
            onBuildingDestroyed(bld);
          }
          hit = true;
          break;
        }
      }
    }

    // Enemy bombs hit player
    if (b.friendly === false && player.invincible <= 0 && state === ST.PLAYING) {
      if (Math.abs(b.x - player.x) < 20 && Math.abs(b.y - player.y) < 15) {
        killPlayer();
        bombs.splice(i, 1);
        continue;
      }
    }

    if (hit || b.life <= 0) {
      addExplosion(b.x, b.y, 30, true);
      playBoom(true);
      // Crater
      for (let dx = -40; dx <= 40; dx++) {
        const ix = Math.floor(((b.x + dx) % WORLD_W + WORLD_W) % WORLD_W);
        if (ix >= 0 && ix < WORLD_W) {
          terrain[ix] += (40 - Math.abs(dx)) * 0.4;
        }
      }
      bombs.splice(i, 1);
    }
  }
}

function updateChaserEnemy(en, dt, playerSafe, turnRate, bulletSpeedMult) {
  let dx, dy, dist, desiredAngle;
  if (playerSafe) {
    const patrolX = 3000 + ((en.x * 7) % 5000);
    const patrolY = 150;
    dx = patrolX - en.x;
    dy = patrolY - en.y;
    dist = Math.sqrt(dx * dx + dy * dy);
    desiredAngle = Math.atan2(dy, dx);
  } else {
    dx = player.x - en.x;
    dy = player.y - en.y;
    dist = Math.sqrt(dx * dx + dy * dy);
    desiredAngle = Math.atan2(dy, dx);
  }

  // Handle bird-strike stall for jets
  if (en.stalled && en.stallTimer > 0) {
    en.stallTimer -= dt;
    en.speed = 40; // drastically reduced
    en.angle += 0.3 * dt; // nose drops
    if (en.stallTimer <= 0) { en.stalled = false; en.speed = ENEMY_SPECS[en.type].speed; }
  }

  let angleDiff = desiredAngle - en.angle;
  while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
  while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
  en.angle += Math.sign(angleDiff) * Math.min(Math.abs(angleDiff), turnRate * dt);

  const spd = en.stalled ? 40 : en.speed;
  en.vx = Math.cos(en.angle) * spd;
  en.vy = Math.sin(en.angle) * spd;
  en.x += en.vx * dt;
  en.y += en.vy * dt;

  const groundY = getTerrainY(en.x);
  if (en.y > groundY - 40) en.y = groundY - 40;
  if (en.y < 30) en.y = 30;

  // Fire at player
  const fireIntervalMult = enemyAccuracyDebuff > 0 ? 2 : 1;
  en.fireTimer--;
  if (en.fireTimer <= 0 && dist < 600 && !playerSafe) {
    const bvx = Math.cos(en.angle) * BULLET_SPEED * bulletSpeedMult;
    const bvy = Math.sin(en.angle) * BULLET_SPEED * bulletSpeedMult;
    bullets.push({ x: en.x + Math.cos(en.angle) * 20, y: en.y + Math.sin(en.angle) * 20, vx: bvx, vy: bvy, life: 1.0, friendly: false });
    en.fireTimer = (ENEMY_SPECS[en.type].fireInterval + Math.random() * 30 | 0) * fireIntervalMult;
  }

  return dist;
}

function updateBomberEnemy(en, dt, playerSafe) {
  // Flies toward player's base area at high altitude, drops bombs
  const targetX = playerSafe ? 6000 : baseX + BASE_WIDTH / 2;
  const targetY = 80 + Math.sin(Date.now() * 0.001 + en.x * 0.01) * 40;

  let dx = targetX - en.x;
  let dy = targetY - en.y;
  const dist = Math.sqrt(dx * dx + dy * dy);
  const desiredAngle = Math.atan2(dy, dx);

  let angleDiff = desiredAngle - en.angle;
  while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
  while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
  en.angle += Math.sign(angleDiff) * Math.min(Math.abs(angleDiff), 1.0 * dt); // Slower turn

  en.vx = Math.cos(en.angle) * en.speed;
  en.vy = Math.sin(en.angle) * en.speed;
  en.x += en.vx * dt;
  en.y += en.vy * dt;

  const groundY = getTerrainY(en.x);
  if (en.y > groundY - 60) en.y = groundY - 60;
  if (en.y < 50) en.y = 50;

  // Drop bombs when above base area or near player
  const fireIntervalMult = enemyAccuracyDebuff > 0 ? 2 : 1;
  en.fireTimer--;
  if (en.fireTimer <= 0 && !playerSafe) {
    const nearBase = Math.abs(en.x - baseX - BASE_WIDTH / 2) < 300;
    const nearPlayer = Math.abs(en.x - player.x) < 200;
    if (nearBase || nearPlayer) {
      bombs.push({ x: en.x, y: en.y + 10, vx: en.vx * 0.3, vy: 20, life: 5, friendly: false });
      en.fireTimer = (BOMBER_BOMB_INTERVAL + Math.random() * 40 | 0) * fireIntervalMult;
    }
  }

  return dist;
}

function updateZeppelinEnemy(en, dt) {
  // Patrols left-right slowly, drops bombs periodically
  en.x += en.patrolDir * en.speed * dt;
  en.y = 50 + Math.sin(Date.now() * 0.0005 + en.x * 0.001) * 30;

  // Reverse at world edges
  if (en.x > WORLD_W - 500) en.patrolDir = -1;
  if (en.x < 500) en.patrolDir = 1;

  en.vx = en.patrolDir * en.speed;
  en.vy = 0;
  en.angle = en.patrolDir > 0 ? 0 : Math.PI;

  const groundY = getTerrainY(en.x);
  if (en.y > groundY - 80) en.y = groundY - 80;

  // Drop 3 bombs in a spread periodically
  const fireIntervalMult = enemyAccuracyDebuff > 0 ? 2 : 1;
  en.fireTimer--;
  if (en.fireTimer <= 0) {
    for (let k = -1; k <= 1; k++) {
      bombs.push({ x: en.x + k * 15, y: en.y + 20, vx: en.vx * 0.2 + k * 10, vy: 15, life: 6, friendly: false });
    }
    en.fireTimer = (ZEPPELIN_BOMB_INTERVAL + Math.random() * 30 | 0) * fireIntervalMult;
  }

  return Math.sqrt((player.x - en.x) ** 2 + (player.y - en.y) ** 2);
}

function updateEnemies(dt) {
  for (const en of enemies) {
    if (!en.alive) continue;

    const playerSafe = player.invincible > 0 || player.landed;
    let dist;

    if (en.type === 'zeppelin') {
      dist = updateZeppelinEnemy(en, dt);
    } else if (en.type === 'bomber') {
      dist = updateBomberEnemy(en, dt, playerSafe);
    } else if (en.type === 'jet') {
      dist = updateChaserEnemy(en, dt, playerSafe, 2.5, 0.85);
    } else {
      dist = updateChaserEnemy(en, dt, playerSafe, 1.5, 0.7);
    }

    // World wrap
    if (en.x < 0) en.x += WORLD_W;
    if (en.x >= WORLD_W) en.x -= WORLD_W;

    // Engine trail (color per type)
    const trailColor = ENEMY_SPECS[en.type].color;
    addParticle(en.x - Math.cos(en.angle) * 18, en.y - Math.sin(en.angle) * 18, -en.vx * 0.05, -en.vy * 0.05, 0.15, trailColor, 1.5);

    // Collision with player
    if (player.invincible <= 0 && state === ST.PLAYING) {
      const spec = ENEMY_SPECS[en.type];
      if (Math.abs(en.x - player.x) < spec.hitW + 5 && Math.abs(en.y - player.y) < spec.hitH + 3) {
        en.alive = false;
        addExplosion(en.x, en.y, 20, true);
        killPlayer();
      }
    }

    // Bird strike check for jet enemies
    if (en.type === 'jet' && !en.stalled) {
      for (const bg of birds) {
        for (const bird of bg.flock) {
          if (!bird.alive) continue;
          if (Math.abs(bird.x - en.x) < 15 && Math.abs(bird.y - en.y) < 10) {
            bird.alive = false;
            addExplosion(bird.x, bird.y, 6, false);
            en.stalled = true;
            en.stallTimer = 3;
            en.speed = 40;
          }
        }
      }
    }
  }
}

function updateFlak(dt) {
  // Buildings shoot flak
  for (const bld of buildings) {
    if (!bld.alive || bld.type !== 'flak') continue;
    bld.flakTimer--;
    if (bld.flakTimer <= 0) {
      const dx = player.x - (bld.x + bld.w / 2);
      const dy = player.y - (bld.y);
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < 500) {
        const a = Math.atan2(dy, dx);
        flakShots.push({
          x: bld.x + bld.w / 2, y: bld.y,
          vx: Math.cos(a) * FLAK_SPEED, vy: Math.sin(a) * FLAK_SPEED,
          life: 1.5
        });
      }
      bld.flakTimer = FLAK_INTERVAL + Math.random() * 20 | 0;
    }
  }

  // Update flak shots
  for (let i = flakShots.length - 1; i >= 0; i--) {
    const f = flakShots[i];
    f.x += f.vx * dt;
    f.y += f.vy * dt;
    f.life -= dt;

    // Trail
    addParticle(f.x, f.y, 0, 0, 0.1, '#f80', 1);

    if (f.life <= 0) {
      // Burst
      addExplosion(f.x, f.y, 8, false);
      flakShots.splice(i, 1);
      continue;
    }

    // Hit player
    if (player.invincible <= 0 && state === ST.PLAYING) {
      if (Math.abs(f.x - player.x) < 20 && Math.abs(f.y - player.y) < 15) {
        killPlayer();
        flakShots.splice(i, 1);
      }
    }
  }
}

function updateBirds(dt) {
  for (const bg of birds) {
    for (const b of bg.flock) {
      if (!b.alive) continue;
      b.x += bg.vx * dt;
      const sinAmp = bg.sinAmp || 4;
      const sinFreq = bg.sinFreq || 0.005;
      b.y += bg.vy * dt + Math.sin(Date.now() * sinFreq + b.x * 0.1) * (sinAmp * 0.1);

      if (b.x < -100) b.x += WORLD_W + 200;

      // Collision with player
      if (player.invincible <= 0 && state === ST.PLAYING) {
        const hitRange = bg.type === 'eagle' ? 18 : bg.type === 'goose' ? 16 : 12;
        if (Math.abs(b.x - player.x) < hitRange && Math.abs(b.y - player.y) < 10) {
          b.alive = false;
          if (bg.type === 'sparrow') {
            // Sparrows: harmless to biplane, just feather particles
            for (let k = 0; k < 8; k++) {
              addParticle(b.x, b.y, (Math.random()-0.5)*40, (Math.random()-0.5)*40, 0.3, Math.random()<0.5?'#ddd':'#aaa', 1.5);
            }
          } else {
            // Geese and eagles: lethal on contact
            addExplosion(b.x, b.y, 8, false);
            killPlayer();
          }
        }
      }
    }
  }
}

function updateOxen(dt) {
  for (const o of oxen) {
    if (!o.alive) continue;
    o.x += o.dir * o.speed * dt;
    const ty = getTerrainY(o.x);
    o.y = ty - o.h;

    // Reverse at edges or randomly
    if (Math.random() < 0.005) o.dir *= -1;

    // Collision with player
    if (player.invincible <= 0 && state === ST.PLAYING) {
      if (player.x > o.x - 5 && player.x < o.x + o.w + 5 && player.y > o.y - 10 && player.y < o.y + o.h + 5) {
        o.alive = false;
        addExplosion(o.x + o.w / 2, o.y, 10, false);
        killPlayer();
      }
    }
  }
}

function updateParticles(dt) {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.vy += 40 * dt;
    p.life -= dt;
    if (p.life <= 0) particles.splice(i, 1);
  }
}

function updateFleeingPeople(dt) {
  for (let i = fleeingPeople.length - 1; i >= 0; i--) {
    const p = fleeingPeople[i];
    p.x += p.dir * p.speed * dt;
    p.y = getTerrainY(p.x);
    p.frame += dt;
    p.life -= dt;
    if (p.life <= 0) fleeingPeople.splice(i, 1);
  }
}

function updateDragons(dt) {
  for (const d of dragons) {
    if (!d.alive) continue;
    d.wingFrame += dt * 5;

    if (d.phase === 'circling') {
      // Circle in the sky at mid-altitude
      d.x += d.vx * dt;
      d.y = 120 + Math.sin(Date.now() * 0.001 + d.x * 0.002) * 60;
      d.vx = 60 * Math.sign(d.vx);

      // Reverse at world edges
      if (d.x > WORLD_W - 400) d.vx = -60;
      if (d.x < 400) d.vx = 60;

      d.breathTimer -= dt;
      if (d.breathTimer <= 0) {
        d.phase = 'diving';
        d.diveTarget = { x: player.x, y: player.y };
      }
    } else if (d.phase === 'diving') {
      // Dive toward ground
      const dx = d.diveTarget.x - d.x;
      const dy = (getTerrainY(d.diveTarget.x) - 50) - d.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      d.vx = (dx / (dist || 1)) * 120;
      d.vy = (dy / (dist || 1)) * 120;
      d.x += d.vx * dt;
      d.y += d.vy * dt;

      if (dist < 80 || d.y > getTerrainY(d.x) - 40) {
        d.phase = 'breathing';
        d.breathTimer = 1.5;
      }
    } else if (d.phase === 'breathing') {
      // Fire breath: spawn fire particles
      d.vx *= 0.95;
      d.vy *= 0.95;
      d.x += d.vx * dt;
      d.y += d.vy * dt;

      // Spawn fire particles in a cone
      if (Math.random() < 0.4) {
        const facingLeft = d.vx < 0;
        const dir = facingLeft ? -1 : 1;
        const fx = d.x + dir * 30;
        const fy = d.y;
        addParticle(fx, fy, dir * (80 + Math.random() * 60), (Math.random() - 0.5) * 40, 0.5, Math.random() < 0.5 ? '#f80' : '#ff0', 3);
        // Check fire particle collision with player
        if (player.invincible <= 0 && state === ST.PLAYING) {
          if (Math.abs(fx - player.x) < 25 && Math.abs(fy - player.y) < 20) {
            killPlayer();
          }
        }
      }

      d.breathTimer -= dt;
      if (d.breathTimer <= 0) {
        d.phase = 'circling';
        d.breathTimer = 5 + Math.random() * 5;
        d.vx = (Math.random() < 0.5 ? 1 : -1) * 60;
        d.vy = 0;
      }
    }

    // Keep above ground
    const groundY = getTerrainY(d.x);
    if (d.y > groundY - 30) d.y = groundY - 30;

    // World wrap
    if (d.x < 0) d.x += WORLD_W;
    if (d.x >= WORLD_W) d.x -= WORLD_W;

    // Collision with player (body)
    if (player.invincible <= 0 && state === ST.PLAYING) {
      if (Math.abs(d.x - player.x) < 25 && Math.abs(d.y - player.y) < 15) {
        killPlayer();
      }
    }
  }
}

function checkLevelComplete() {
  const targets = buildings.filter(b => b.isTarget && b.alive);
  if (targets.length === 0) {
    state = ST.LEVEL_COMPLETE;
    levelTimer = 3;
    score += 1000 * level;
  }
}

// ── HUD update ──
function updateHUD() {
  const p = player;
  let livesStr = '';
  for (let i = 0; i < 5; i++) livesStr += i < lives ? '●' : '○';
  document.getElementById('h-lives').textContent = livesStr;
  document.getElementById('h-fuel').style.width = (p.fuel / MAX_FUEL * 100) + '%';
  document.getElementById('h-bombs').textContent = p.bombCount;
  document.getElementById('h-ammo').style.width = (p.ammo / MAX_AMMO * 100) + '%';
  document.getElementById('h-score').textContent = String(score).padStart(6, '0');
  document.getElementById('h-level').textContent = level;
}

// ── Draw ──
function draw() {
  const W = canvas.width;
  const H = canvas.height;

  // Clear
  ctx.fillStyle = '#0a0a0f';
  ctx.fillRect(0, 0, W, H);

  if (state === ST.TITLE) {
    drawTitle(W, H);
    drawRadarEmpty();
    return;
  }

  // Stars
  ctx.fillStyle = '#fff';
  for (const s of stars) {
    const sx = ((s.x - camX * 0.3) % W + W) % W;
    const sy = s.y - camY * 0.1;
    if (sy < 0 || sy > H) continue;
    const flicker = s.b + Math.sin(Date.now() * 0.003 + s.x) * 0.1;
    ctx.globalAlpha = flicker;
    ctx.fillRect(sx, sy, s.s, s.s);
  }
  ctx.globalAlpha = 1;

  // ── World drawing (offset by camera) ──
  ctx.save();
  ctx.translate(-camX, -camY);

  // Terrain
  drawTerrain(W, H);

  // Home base
  drawBase();

  // Buildings
  for (const bld of buildings) {
    if (!bld.alive) continue;
    const screenX = bld.x - camX;
    if (screenX < -100 || screenX > W + 100) continue;
    drawBuilding(bld);
  }

  // Animals (oxen, sheep, horses, camels)
  for (const o of oxen) {
    if (!o.alive) continue;
    const screenX = o.x - camX;
    if (screenX < -50 || screenX > W + 50) continue;
    drawAnimal(o);
  }

  // Fleeing people
  for (const p of fleeingPeople) {
    const screenX = p.x - camX;
    if (screenX < -50 || screenX > W + 50) continue;
    drawPerson(p);
  }

  // Birds (per-type rendering)
  for (const bg of birds) {
    for (const b of bg.flock) {
      if (!b.alive) continue;
      const screenX = b.x - camX;
      if (screenX < -50 || screenX > W + 50) continue;

      if (bg.type === 'eagle') {
        // Wide wingspan, brown, slower soaring animation
        const col = '#a72';
        neonGlow(ctx, col, 5);
        ctx.strokeStyle = col;
        ctx.lineWidth = 1.5;
        const wing = Math.sin(Date.now() * 0.004 + b.x) * 5;
        ctx.beginPath();
        ctx.moveTo(b.x - 14, b.y + wing);
        ctx.lineTo(b.x - 4, b.y + wing * 0.3);
        ctx.lineTo(b.x, b.y);
        ctx.lineTo(b.x + 4, b.y + wing * 0.3);
        ctx.lineTo(b.x + 14, b.y + wing);
        ctx.stroke();
        // Body/tail
        ctx.beginPath();
        ctx.moveTo(b.x, b.y);
        ctx.lineTo(b.x + 5, b.y + 1);
        ctx.stroke();
        clearGlow(ctx);
      } else if (bg.type === 'goose') {
        // Larger V-shape, thicker lines
        const col = '#dda';
        neonGlow(ctx, col, 4);
        ctx.strokeStyle = col;
        ctx.lineWidth = 1.5;
        const wing = Math.sin(Date.now() * 0.008 + b.x) * 5;
        ctx.beginPath();
        ctx.moveTo(b.x - 10, b.y + wing);
        ctx.lineTo(b.x, b.y);
        ctx.lineTo(b.x + 10, b.y + wing);
        ctx.stroke();
        // Body dot
        ctx.fillStyle = col;
        ctx.beginPath();
        ctx.arc(b.x, b.y, 1.5, 0, Math.PI * 2);
        ctx.fill();
        clearGlow(ctx);
      } else {
        // Sparrows: small, fast V-shape
        neonGlow(ctx, '#aaf', 4);
        ctx.strokeStyle = '#aaf';
        ctx.lineWidth = 1;
        ctx.beginPath();
        const wing = Math.sin(Date.now() * 0.01 + b.x) * 4;
        ctx.moveTo(b.x - 6, b.y + wing);
        ctx.lineTo(b.x, b.y);
        ctx.lineTo(b.x + 6, b.y + wing);
        ctx.stroke();
        clearGlow(ctx);
      }
    }
  }

  // Dragons
  for (const d of dragons) {
    if (!d.alive) continue;
    const screenX = d.x - camX;
    if (screenX < -100 || screenX > W + 100) continue;
    drawDragon(ctx, d);
  }

  // Bombs
  for (const b of bombs) {
    const screenX = b.x - camX;
    if (screenX < -50 || screenX > W + 50) continue;
    const bombCol = b.friendly === false ? '#f55' : '#fa0';
    neonGlow(ctx, bombCol, 6);
    ctx.fillStyle = bombCol;
    ctx.beginPath();
    ctx.arc(b.x, b.y, 4, 0, Math.PI * 2);
    ctx.fill();
    clearGlow(ctx);
    addParticle(b.x, b.y - 2, 0, -10, 0.15, b.friendly === false ? '#f55' : '#f80', 1);
  }

  // Flak shots
  for (const f of flakShots) {
    neonGlow(ctx, '#f80', 6);
    ctx.fillStyle = '#ff0';
    ctx.beginPath();
    ctx.arc(f.x, f.y, 3, 0, Math.PI * 2);
    ctx.fill();
    clearGlow(ctx);
  }

  // Bullets
  for (const b of bullets) {
    const screenX = b.x - camX;
    if (screenX < -50 || screenX > W + 50) continue;
    const col = b.friendly ? '#0ff' : '#f55';
    neonGlow(ctx, col, 4);
    ctx.fillStyle = col;
    ctx.beginPath();
    ctx.arc(b.x, b.y, 2, 0, Math.PI * 2);
    ctx.fill();
    clearGlow(ctx);
  }

  // Enemies (dispatch by type)
  for (const en of enemies) {
    if (!en.alive) continue;
    const screenX = en.x - camX;
    const margin = en.type === 'zeppelin' ? 150 : 100;
    if (screenX < -margin || screenX > W + margin) continue;
    const enFacingLeft = en.vx < 0;
    const spec = ENEMY_SPECS[en.type];
    if (en.type === 'jet') {
      drawJet(ctx, en.x, en.y, en.angle, enFacingLeft, spec.color);
    } else if (en.type === 'bomber') {
      drawBomber(ctx, en.x, en.y, en.angle, enFacingLeft, spec.color);
    } else if (en.type === 'zeppelin') {
      drawZeppelin(ctx, en.x, en.y, en.angle, enFacingLeft, spec.color);
    } else {
      drawBiplane(ctx, en.x, en.y, en.angle, enFacingLeft, spec.color, undefined, false);
    }
  }

  // Player
  if (state === ST.PLAYING) {
    if (player.invincible <= 0 || Math.sin(Date.now() * 0.02) > 0) {
      const pAngle = getEffectiveAngle(player);
      const pFacingLeft = pAngle >= 5 && pAngle <= 11;
      drawBiplane(ctx, player.x, player.y, getPlaneRadians(player), pFacingLeft, '#0ff', undefined, player.orient);
    }
  }

  // Particles
  for (const p of particles) {
    const alpha = p.life / p.maxLife;
    ctx.globalAlpha = alpha;
    ctx.fillStyle = p.color;
    neonGlow(ctx, p.color, 4);
    ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
    clearGlow(ctx);
  }
  ctx.globalAlpha = 1;

  ctx.restore();

  // ── Overlays ──
  if (state === ST.DYING) {
    ctx.fillStyle = `rgba(255, 50, 0, ${0.3 * (deathTimer / 2)})`;
    ctx.fillRect(0, 0, W, H);
    ctx.fillStyle = '#fff';
    ctx.font = '24px "Courier New", monospace';
    ctx.textAlign = 'center';
    ctx.fillText(lives > 0 ? 'PLANE DESTROYED' : 'GAME OVER', W / 2, H / 2);
  }

  if (state === ST.GAME_OVER) {
    ctx.fillStyle = 'rgba(0,0,0,0.7)';
    ctx.fillRect(0, 0, W, H);
    neonGlow(ctx, '#f55', 12);
    ctx.fillStyle = '#f55';
    ctx.font = 'bold 36px "Courier New", monospace';
    ctx.textAlign = 'center';
    ctx.fillText('GAME OVER', W / 2, H / 2 - 30);
    clearGlow(ctx);
    ctx.fillStyle = '#888';
    ctx.font = '16px "Courier New", monospace';
    ctx.fillText(`FINAL SCORE: ${score}`, W / 2, H / 2 + 10);
    ctx.fillText('Press ENTER to restart', W / 2, H / 2 + 40);
  }

  if (state === ST.LEVEL_COMPLETE) {
    neonGlow(ctx, '#0f0', 12);
    ctx.fillStyle = '#0f0';
    ctx.font = 'bold 30px "Courier New", monospace';
    ctx.textAlign = 'center';
    ctx.fillText(`LEVEL ${level} COMPLETE!`, W / 2, H / 2 - 10);
    clearGlow(ctx);
    ctx.fillStyle = '#0ff';
    ctx.font = '16px "Courier New", monospace';
    ctx.fillText(`+${1000 * level} bonus points`, W / 2, H / 2 + 20);
  }

  // Top strip radar
  drawRadar();

  // Circular radar scope (HUD overlay)
  if (state === ST.PLAYING || state === ST.LEVEL_COMPLETE) {
    drawRadarScope(W, H);
  }
}

function drawTerrain(W, H) {
  const startX = Math.max(0, Math.floor(camX) - 2);
  const endX = Math.min(WORLD_W - 1, Math.floor(camX + W) + 2);
  const terrainBottom = camY + H + 50;

  // Filled terrain (dark)
  ctx.fillStyle = '#0d1a0d';
  ctx.beginPath();
  ctx.moveTo(startX, terrainBottom);
  for (let x = startX; x <= endX; x += 2) {
    ctx.lineTo(x, terrain[x]);
  }
  ctx.lineTo(endX, terrainBottom);
  ctx.closePath();
  ctx.fill();

  // Neon terrain line
  neonGlow(ctx, '#0f8', 8);
  ctx.strokeStyle = '#0fa';
  ctx.lineWidth = 2;
  ctx.beginPath();
  for (let x = startX; x <= endX; x += 2) {
    if (x === startX) ctx.moveTo(x, terrain[x]);
    else ctx.lineTo(x, terrain[x]);
  }
  ctx.stroke();

  // Second glow line (brighter, thinner)
  ctx.strokeStyle = '#5ff';
  ctx.lineWidth = 0.5;
  ctx.beginPath();
  for (let x = startX; x <= endX; x += 2) {
    if (x === startX) ctx.moveTo(x, terrain[x]);
    else ctx.lineTo(x, terrain[x]);
  }
  ctx.stroke();
  clearGlow(ctx);
}

function drawBase() {
  const by = getTerrainY(baseX + BASE_WIDTH / 2);
  // Runway
  neonGlow(ctx, '#0af', 6);
  ctx.strokeStyle = '#0af';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(baseX, by);
  ctx.lineTo(baseX + BASE_WIDTH, by);
  ctx.stroke();

  // Dashes
  ctx.strokeStyle = '#05a';
  ctx.lineWidth = 1;
  ctx.setLineDash([8, 8]);
  ctx.beginPath();
  ctx.moveTo(baseX + 10, by - 3);
  ctx.lineTo(baseX + BASE_WIDTH - 10, by - 3);
  ctx.stroke();
  ctx.setLineDash([]);

  // Label
  ctx.fillStyle = '#0af';
  ctx.font = '10px "Courier New", monospace';
  ctx.textAlign = 'center';
  ctx.fillText('HOME BASE', baseX + BASE_WIDTH / 2, by - 10);
  clearGlow(ctx);
}

function drawBuilding(bld) {
  const col = buildingColors[bld.type] || '#fa0';
  neonGlow(ctx, col, 8);
  ctx.strokeStyle = col;
  ctx.lineWidth = 1.5;
  ctx.strokeRect(bld.x, bld.y, bld.w, bld.h);

  // Inner detail per type
  if (bld.type === 'factory') {
    ctx.strokeRect(bld.x + bld.w - 10, bld.y - 15, 8, 15);
    if (Math.random() < 0.05) {
      addParticle(bld.x + bld.w - 6, bld.y - 15, (Math.random() - 0.5) * 10, -20, 0.5, '#555', 2);
    }
  } else if (bld.type === 'flak') {
    ctx.beginPath();
    ctx.moveTo(bld.x + bld.w / 2, bld.y);
    ctx.lineTo(bld.x + bld.w / 2, bld.y - 12);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(bld.x + bld.w / 2 - 6, bld.y - 10);
    ctx.lineTo(bld.x + bld.w / 2 + 6, bld.y - 10);
    ctx.stroke();
  } else if (bld.type === 'hangar') {
    ctx.beginPath();
    ctx.arc(bld.x + bld.w / 2, bld.y + bld.h, bld.w * 0.35, Math.PI, 0);
    ctx.stroke();
  } else if (bld.type === 'dam') {
    // Vertical buttress lines
    for (let bx = bld.x + 15; bx < bld.x + bld.w - 10; bx += 20) {
      ctx.beginPath();
      ctx.moveTo(bx, bld.y);
      ctx.lineTo(bx, bld.y + bld.h);
      ctx.stroke();
    }
    // Wavy water line on upstream (left) side
    ctx.strokeStyle = '#0af';
    ctx.lineWidth = 1;
    ctx.beginPath();
    for (let wx = bld.x - 40; wx < bld.x; wx += 3) {
      const wy = bld.y + bld.h - 5 + Math.sin(Date.now() * 0.004 + wx * 0.2) * 3;
      if (wx === bld.x - 40) ctx.moveTo(wx, wy);
      else ctx.lineTo(wx, wy);
    }
    ctx.stroke();
    // Label
    ctx.strokeStyle = col;
    ctx.fillStyle = col;
    ctx.font = '7px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('DAM', bld.x + bld.w / 2, bld.y + bld.h / 2 + 3);
  } else if (bld.type === 'radar_station') {
    // Base rectangle already drawn
    // Antenna mast
    const cx = bld.x + bld.w / 2;
    ctx.beginPath();
    ctx.moveTo(cx, bld.y);
    ctx.lineTo(cx, bld.y - 20);
    ctx.stroke();
    // Rotating dish (animated arc)
    const dishAngle = (Date.now() * 0.003) % (Math.PI * 2);
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(cx, bld.y - 20, 8, dishAngle, dishAngle + Math.PI * 0.6);
    ctx.stroke();
    ctx.lineWidth = 1.5;
  } else if (bld.type === 'fuel_depot') {
    // Cylindrical tank shapes (arcs) inside
    for (let t = 0; t < 3; t++) {
      const tx = bld.x + 8 + t * 13;
      ctx.beginPath();
      ctx.arc(tx, bld.y + bld.h, 8, Math.PI, 0);
      ctx.stroke();
    }
    // Diagonal hazard stripes
    ctx.lineWidth = 1;
    ctx.setLineDash([4, 4]);
    ctx.beginPath();
    ctx.moveTo(bld.x, bld.y + bld.h);
    ctx.lineTo(bld.x + bld.w, bld.y);
    ctx.stroke();
    ctx.setLineDash([]);
    // Occasional orange smoke
    if (Math.random() < 0.03) {
      addParticle(bld.x + bld.w / 2, bld.y, (Math.random()-0.5)*8, -15, 0.4, '#f80', 2);
    }
  } else if (bld.type === 'bunker') {
    // Rounded top (arc)
    ctx.beginPath();
    ctx.arc(bld.x + bld.w / 2, bld.y, bld.w / 2, Math.PI, 0);
    ctx.stroke();
    // Gun slit
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(bld.x + 5, bld.y + 5);
    ctx.lineTo(bld.x + bld.w - 5, bld.y + 5);
    ctx.stroke();
  }

  // HP indicator
  if (bld.hp > 1) {
    ctx.fillStyle = col;
    ctx.font = '8px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('●'.repeat(Math.min(bld.hp, 8)), bld.x + bld.w / 2, bld.y - 4);
  }
  clearGlow(ctx);
}

function drawOx(o) {
  neonGlow(ctx, '#0f0', 6);
  ctx.strokeStyle = '#0f0';
  ctx.lineWidth = 1.5;

  // Body
  ctx.strokeRect(o.x + 3, o.y + 1, 14, 6);
  // Legs
  ctx.beginPath();
  ctx.moveTo(o.x + 5, o.y + 7); ctx.lineTo(o.x + 5, o.y + 10);
  ctx.moveTo(o.x + 8, o.y + 7); ctx.lineTo(o.x + 8, o.y + 10);
  ctx.moveTo(o.x + 13, o.y + 7); ctx.lineTo(o.x + 13, o.y + 10);
  ctx.moveTo(o.x + 16, o.y + 7); ctx.lineTo(o.x + 16, o.y + 10);
  ctx.stroke();
  // Head
  const headX = o.dir > 0 ? o.x + 17 : o.x + 3;
  ctx.strokeRect(headX - 2, o.y - 1, 4, 4);
  // Horns
  ctx.beginPath();
  ctx.moveTo(headX - 2, o.y - 1); ctx.lineTo(headX - 4, o.y - 3);
  ctx.moveTo(headX + 2, o.y - 1); ctx.lineTo(headX + 4, o.y - 3);
  ctx.stroke();
  clearGlow(ctx);
}

function drawTitle(W, H) {
  // Animated background stars
  ctx.fillStyle = '#fff';
  for (const s of stars) {
    const sx = (s.x * 0.1 + Date.now() * 0.005) % W;
    const sy = s.y;
    if (sy > H) continue;
    ctx.globalAlpha = s.b + Math.sin(Date.now() * 0.003 + s.x) * 0.1;
    ctx.fillRect(sx, sy, s.s, s.s);
  }
  ctx.globalAlpha = 1;

  // Title
  neonGlow(ctx, '#0ff', 20);
  ctx.fillStyle = '#0ff';
  ctx.font = `bold ${Math.min(60, W * 0.08)}px "Courier New", monospace`;
  ctx.textAlign = 'center';
  ctx.fillText('NEON SOPWITH', W / 2, H * 0.25);
  clearGlow(ctx);

  neonGlow(ctx, '#0af', 10);
  ctx.fillStyle = '#0af';
  ctx.font = `${Math.min(18, W * 0.025)}px "Courier New", monospace`;
  ctx.fillText('A Retro Biplane Shooter', W / 2, H * 0.25 + 35);
  clearGlow(ctx);

  // Animated biplane
  titlePlaneX += 2;
  if (titlePlaneX > W + 200) titlePlaneX = -200;
  const titlePlaneY = H * 0.4 + Math.sin(Date.now() * 0.002) * 15;
  drawBiplane(ctx, titlePlaneX, titlePlaneY, Math.sin(Date.now() * 0.001) * 0.1, false, '#0ff', 2);
  // Engine trail
  for (let i = 0; i < 3; i++) {
    addParticle(titlePlaneX - 40 - i * 10, titlePlaneY + (Math.random() - 0.5) * 5, -30, (Math.random() - 0.5) * 10, 0.3, '#08f', 2);
  }
  // Update & draw title particles
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx * 0.016;
    p.y += p.vy * 0.016;
    p.life -= 0.016;
    if (p.life <= 0) { particles.splice(i, 1); continue; }
    ctx.globalAlpha = p.life / p.maxLife;
    ctx.fillStyle = p.color;
    ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
  }
  ctx.globalAlpha = 1;

  // Blinking "Press ENTER"
  if (Math.sin(Date.now() * 0.004) > 0) {
    neonGlow(ctx, '#fff', 8);
    ctx.fillStyle = '#fff';
    ctx.font = `${Math.min(20, W * 0.03)}px "Courier New", monospace`;
    ctx.fillText('PRESS ENTER TO START', W / 2, H * 0.55);
    clearGlow(ctx);
  }

  // Controls
  const ctrls = [
    [', or Arrow Up', 'Nose Up + Accelerate'],
    ['/ or Arrow Down', 'Nose Down'],
    ['X', 'Accelerate'],
    ['. or F', 'Flip Plane'],
    ['Space', 'Machine Gun'],
    ['B', 'Drop Bomb'],
    ['H', 'Autopilot Home'],
  ];
  ctx.fillStyle = '#557';
  ctx.font = `${Math.min(12, W * 0.018)}px "Courier New", monospace`;
  const startY = H * 0.65;
  ctx.textAlign = 'center';
  ctx.fillText('─── CONTROLS ───', W / 2, startY - 15);
  ctx.textAlign = 'left';
  for (let i = 0; i < ctrls.length; i++) {
    const cx = W / 2 - 160;
    const cy = startY + i * 22;
    ctx.fillStyle = '#0af';
    ctx.fillText(ctrls[i][0].padEnd(16), cx, cy);
    ctx.fillStyle = '#667';
    ctx.fillText(ctrls[i][1], cx + 170, cy);
  }

  // Footer
  ctx.textAlign = 'center';
  ctx.fillStyle = '#334';
  ctx.font = `${Math.min(11, W * 0.015)}px "Courier New", monospace`;
  ctx.fillText('Inspired by Sopwith (1984) by BMB Compuscience', W / 2, H * 0.95);
}

function drawRadar() {
  const rW = radarCanvas.width;
  const rH = radarCanvas.height;
  rctx.fillStyle = '#08080c';
  rctx.fillRect(0, 0, rW, rH);

  const scale = rW / WORLD_W;

  // Terrain silhouette
  rctx.strokeStyle = '#0a3';
  rctx.lineWidth = 1;
  rctx.beginPath();
  for (let x = 0; x < WORLD_W; x += 20) {
    const rx = x * scale;
    const ry = rH - (rH * 0.6 - terrain[x] * scale * 0.5);
    if (x === 0) rctx.moveTo(rx, Math.min(rH, ry));
    else rctx.lineTo(rx, Math.min(rH, ry));
  }
  rctx.stroke();

  // Base
  rctx.fillStyle = '#0af';
  rctx.fillRect(baseX * scale - 1, 2, Math.max(3, BASE_WIDTH * scale), 4);

  // Buildings (color-coded by type)
  for (const bld of buildings) {
    if (!bld.alive) continue;
    rctx.fillStyle = buildingColors[bld.type] || '#f44';
    rctx.fillRect(bld.x * scale, rH * 0.4, Math.max(2, bld.w * scale), 3);
  }

  // Enemies (color-coded by type)
  for (const en of enemies) {
    if (!en.alive) continue;
    const spec = ENEMY_SPECS[en.type];
    rctx.fillStyle = spec.color;
    const sz = en.type === 'zeppelin' ? 5 : 3;
    rctx.fillRect(en.x * scale - 1, en.y * scale * 0.05 + 5, sz, sz);
  }

  // Dragons
  for (const d of dragons) {
    if (!d.alive) continue;
    rctx.fillStyle = '#f40';
    rctx.fillRect(d.x * scale - 2, d.y * scale * 0.05 + 5, 4, 4);
  }

  // Player
  if (state === ST.PLAYING || state === ST.LEVEL_COMPLETE) {
    rctx.fillStyle = '#0ff';
    rctx.fillRect(player.x * scale - 2, player.y * scale * 0.05 + 5, 5, 4);
  }

  // Viewport indicator
  rctx.strokeStyle = '#225';
  rctx.lineWidth = 1;
  const viewL = camX * scale;
  const viewW = canvas.width * scale;
  rctx.strokeRect(viewL, 0, viewW, rH);
}

function drawRadarEmpty() {
  const rW = radarCanvas.width;
  const rH = radarCanvas.height;
  rctx.fillStyle = '#08080c';
  rctx.fillRect(0, 0, rW, rH);
  rctx.fillStyle = '#1a1a2a';
  rctx.font = '10px "Courier New", monospace';
  rctx.textAlign = 'center';
  rctx.fillText('RADAR', rW / 2, rH / 2 + 3);
}

// ── Circular radar scope (in-game HUD) ──
let radarSweepAngle = 0;

function drawRadarScope(W, H) {
  const R = Math.min(W, H) * 0.12;         // radius scales with screen
  const cx = 20 + R + 8;                     // center X (bottom-left)
  const cy = H - 20 - R - 8;                // center Y
  const RANGE = 1200;                        // world-unit detection range

  // Player heading in canvas radians (0=right, CW positive)
  // getPlaneRadians: 0=right, negative=up. We want "forward = up on scope"
  // so rotate everything by -(heading + PI/2)
  const heading = getPlaneRadians(player);
  const rot = -(heading + Math.PI / 2);      // offset so forward points up

  // ── Background ──
  ctx.save();
  ctx.globalAlpha = 0.7;
  ctx.beginPath();
  ctx.arc(cx, cy, R + 6, 0, Math.PI * 2);
  ctx.fillStyle = '#040810';
  ctx.fill();
  ctx.globalAlpha = 1;

  // Clip to circle
  ctx.save();
  ctx.beginPath();
  ctx.arc(cx, cy, R + 1, 0, Math.PI * 2);
  ctx.clip();

  // ── Sweep fade trail (ghosting effect) ──
  // Draw a translucent dark fill to create persistence-of-vision
  ctx.fillStyle = 'rgba(4, 8, 16, 0.15)';
  ctx.fillRect(cx - R - 2, cy - R - 2, (R + 2) * 2, (R + 2) * 2);

  // ── Sweep line ──
  radarSweepAngle += 0.03;
  if (radarSweepAngle > Math.PI * 2) radarSweepAngle -= Math.PI * 2;
  const sweepAng = radarSweepAngle + rot;

  // Sweep gradient (bright leading edge, fading trail)
  const sweepGrad = ctx.createConicalGradient
    ? null  // not widely supported
    : null;

  // Draw sweep as a filled wedge with gradient
  ctx.globalAlpha = 0.35;
  for (let i = 0; i < 12; i++) {
    const a0 = sweepAng - (i + 1) * 0.05;
    const a1 = sweepAng - i * 0.05;
    const alpha = 0.35 * (1 - i / 12);
    ctx.fillStyle = `rgba(0, 255, 128, ${alpha})`;
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.arc(cx, cy, R, a0, a1);
    ctx.closePath();
    ctx.fill();
  }
  ctx.globalAlpha = 1;

  // Bright sweep line
  neonGlow(ctx, '#0f8', 6);
  ctx.strokeStyle = '#0fa';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(cx, cy);
  ctx.lineTo(cx + Math.cos(sweepAng) * R, cy + Math.sin(sweepAng) * R);
  ctx.stroke();
  clearGlow(ctx);

  // ── Range rings ──
  ctx.strokeStyle = 'rgba(0, 180, 80, 0.2)';
  ctx.lineWidth = 0.5;
  for (let ring = 1; ring <= 3; ring++) {
    ctx.beginPath();
    ctx.arc(cx, cy, R * ring / 3, 0, Math.PI * 2);
    ctx.stroke();
  }

  // ── Crosshair lines ──
  ctx.strokeStyle = 'rgba(0, 180, 80, 0.15)';
  ctx.beginPath();
  ctx.moveTo(cx - R, cy); ctx.lineTo(cx + R, cy);
  ctx.moveTo(cx, cy - R); ctx.lineTo(cx, cy + R);
  ctx.stroke();

  // ── Plot blips ──
  // Helper: world pos → scope pos (rotated relative to player)
  function toScope(wx, wy) {
    let dx = wx - player.x;
    let dy = wy - player.y;
    // Handle world wrapping
    if (dx > WORLD_W / 2) dx -= WORLD_W;
    if (dx < -WORLD_W / 2) dx += WORLD_W;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist > RANGE) return null;
    // Rotate by rot so forward = up
    const cos = Math.cos(rot);
    const sin = Math.sin(rot);
    const rx = dx * cos - dy * sin;
    const ry = dx * sin + dy * cos;
    const scale = R / RANGE;
    return { x: cx + rx * scale, y: cy + ry * scale, dist };
  }

  // Helper: draw a blip with glow
  function drawBlip(sx, sy, color, size) {
    neonGlow(ctx, color, 6);
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(sx, sy, size, 0, Math.PI * 2);
    ctx.fill();
    clearGlow(ctx);
  }

  // Enemies
  for (const en of enemies) {
    if (!en.alive) continue;
    const p = toScope(en.x, en.y);
    if (!p) continue;
    const spec = ENEMY_SPECS[en.type];
    const sz = en.type === 'zeppelin' ? 3 : 2;
    drawBlip(p.x, p.y, spec.color, sz);
  }

  // Dragons
  for (const d of dragons) {
    if (!d.alive) continue;
    const p = toScope(d.x, d.y);
    if (!p) continue;
    drawBlip(p.x, p.y, '#f40', 2.5);
  }

  // Flak buildings (threat sources)
  for (const bld of buildings) {
    if (!bld.alive) continue;
    if (bld.type !== 'flak') continue;
    const p = toScope(bld.x + bld.w / 2, bld.y);
    if (!p) continue;
    // Square blip for ground threats
    ctx.fillStyle = '#f80';
    ctx.globalAlpha = 0.6;
    ctx.fillRect(p.x - 1.5, p.y - 1.5, 3, 3);
    ctx.globalAlpha = 1;
  }

  // Bird flocks (goose/eagle only — dangerous ones)
  for (const bg of birds) {
    if (bg.type === 'sparrow') continue;
    // Use first alive bird as flock position
    const leader = bg.flock.find(b => b.alive);
    if (!leader) continue;
    const p = toScope(leader.x, leader.y);
    if (!p) continue;
    ctx.fillStyle = bg.type === 'eagle' ? '#a72' : '#dda';
    ctx.globalAlpha = 0.5;
    ctx.beginPath();
    ctx.arc(p.x, p.y, 1.5, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
  }

  // Flak shots (incoming)
  for (const f of flakShots) {
    const p = toScope(f.x, f.y);
    if (!p) continue;
    ctx.fillStyle = '#ff0';
    ctx.globalAlpha = 0.4;
    ctx.fillRect(p.x - 0.5, p.y - 0.5, 1, 1);
    ctx.globalAlpha = 1;
  }

  // Enemy bombs (incoming)
  for (const b of bombs) {
    if (b.friendly !== false) continue;
    const p = toScope(b.x, b.y);
    if (!p) continue;
    ctx.fillStyle = '#f55';
    ctx.globalAlpha = 0.5;
    ctx.fillRect(p.x - 1, p.y - 1, 2, 2);
    ctx.globalAlpha = 1;
  }

  // ── Player center dot ──
  neonGlow(ctx, '#0ff', 8);
  ctx.fillStyle = '#0ff';
  ctx.beginPath();
  ctx.arc(cx, cy, 2, 0, Math.PI * 2);
  ctx.fill();

  // Small forward tick (nose direction)
  ctx.strokeStyle = '#0ff';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(cx, cy - 4);
  ctx.lineTo(cx, cy - 8);
  ctx.stroke();
  clearGlow(ctx);

  ctx.restore(); // end clip

  // ── Bezel ring ──
  neonGlow(ctx, '#0a4', 4);
  ctx.strokeStyle = '#0a4';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(cx, cy, R + 3, 0, Math.PI * 2);
  ctx.stroke();

  // Outer thin ring
  ctx.strokeStyle = '#052';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.arc(cx, cy, R + 6, 0, Math.PI * 2);
  ctx.stroke();
  clearGlow(ctx);

  // ── Label ──
  ctx.fillStyle = '#0a4';
  ctx.globalAlpha = 0.6;
  ctx.font = '8px "Courier New", monospace';
  ctx.textAlign = 'center';
  ctx.fillText('RDR', cx, cy + R + 14);
  ctx.globalAlpha = 1;

  ctx.restore(); // end save from top
}

// ── Game loop ──
function gameLoop(timestamp) {
  if (!lastTime) lastTime = timestamp;
  let dt = (timestamp - lastTime) / 1000;
  lastTime = timestamp;
  if (dt > 0.05) dt = 0.05; // cap delta

  handleInput();
  update(dt);
  draw();
  requestAnimationFrame(gameLoop);
}

function handleInput() {
  if (keys['Enter']) {
    keys['Enter'] = false;
    if (state === ST.TITLE || state === ST.GAME_OVER) {
      initAudio();
      level = 1;
      score = 0;
      lives = 5;
      initLevel();
      state = ST.PLAYING;
      if (touchStartBtn) touchStartBtn.classList.remove('visible');
    }
  }

  // Show/hide touch start button based on game state
  if (isTouchDevice && touchStartBtn) {
    if (state === ST.TITLE || state === ST.GAME_OVER) {
      touchStartBtn.classList.add('visible');
      touchStartBtn.textContent = state === ST.TITLE ? 'TAP TO START' : 'TAP TO RETRY';
    } else {
      touchStartBtn.classList.remove('visible');
    }
  }
}

// ── Engine sound update ──
function updateEngineSound() {
  if (!engineGain || !audioCtx) return;
  if (state === ST.PLAYING && player && !player.landed) {
    const speed = player.speed * PIXELS_PER_UNIT;
    engineOsc.frequency.value = 60 + speed * 0.3 + player.accel * 10;
    engineGain.gain.value = 0.02 + (player.accel / PLANE_MAX_ACCEL) * 0.03;
  } else {
    engineGain.gain.value = 0;
  }
}
setInterval(updateEngineSound, 50);

// ── Start ──
particles = [];
fleeingPeople = [];
dragons = [];
generateTerrain();
requestAnimationFrame(gameLoop);

})();
</script>
</body>
</html>

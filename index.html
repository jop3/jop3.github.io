<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Neon Sopwith</title>
<style>
*,*::before,*::after{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#0a0a0f;font-family:'Courier New',monospace}
#wrap{position:relative;width:100%;height:100%;display:flex;flex-direction:column}
#radar{height:40px;background:#08080c;border-bottom:1px solid #1a1a2a;position:relative;overflow:hidden}
#game{flex:1;position:relative;image-rendering:auto}
#game canvas{width:100%;height:100%;display:block}
/* scanlines */
#game::after{content:'';position:absolute;inset:0;background:repeating-linear-gradient(0deg,transparent,transparent 2px,rgba(0,0,0,0.08) 2px,rgba(0,0,0,0.08) 4px);pointer-events:none;z-index:2}
/* CRT vignette */
#game::before{content:'';position:absolute;inset:0;background:radial-gradient(ellipse at center,transparent 60%,rgba(0,0,0,0.5) 100%);pointer-events:none;z-index:3}
#hud{height:36px;background:#08080c;border-top:1px solid #1a1a2a;display:flex;align-items:center;justify-content:center;gap:2rem;font-size:13px;color:#8af;padding:0 1rem;flex-shrink:0}
.hud-item{display:flex;align-items:center;gap:0.4rem;white-space:nowrap}
.hud-label{color:#557;font-size:11px;text-transform:uppercase;letter-spacing:1px}
.hud-val{color:#0ff;font-weight:bold;text-shadow:0 0 6px #0ff}
.hud-val.red{color:#f55;text-shadow:0 0 6px #f55}
.hud-val.green{color:#0fa;text-shadow:0 0 6px #0fa}
.fuel-bar{width:60px;height:8px;background:#112;border:1px solid #335;border-radius:2px;overflow:hidden;display:inline-block;vertical-align:middle}
.fuel-fill{height:100%;background:linear-gradient(90deg,#0f0,#0ff);transition:width 0.2s}
.ammo-bar{width:50px;height:8px;background:#112;border:1px solid #335;border-radius:2px;overflow:hidden;display:inline-block;vertical-align:middle}
.ammo-fill{height:100%;background:linear-gradient(90deg,#ff0,#fa0);transition:width 0.2s}
/* ── Touch controls ── */
#touch-controls{display:none;position:absolute;bottom:42px;left:0;right:0;pointer-events:none;z-index:10;padding:0 8px 6px}
.touch-row{display:flex;justify-content:space-between;align-items:center;pointer-events:none}
.touch-btn{pointer-events:auto;width:56px;height:56px;border-radius:50%;border:2px solid rgba(0,255,255,0.4);background:rgba(0,20,40,0.5);color:#0ff;font:bold 13px 'Courier New',monospace;display:flex;align-items:center;justify-content:center;user-select:none;-webkit-user-select:none;touch-action:none;text-shadow:0 0 6px #0ff}
.touch-btn:active,.touch-btn.held{background:rgba(0,255,255,0.25);border-color:#0ff}
.touch-btn.fire{border-color:rgba(255,100,100,0.5);color:#f66;text-shadow:0 0 6px #f66;width:64px;height:64px}
.touch-btn.fire:active,.touch-btn.fire.held{background:rgba(255,50,50,0.25);border-color:#f66}
.touch-btn.bomb{border-color:rgba(255,160,0,0.5);color:#fa0;text-shadow:0 0 6px #fa0}
.touch-btn.bomb:active,.touch-btn.bomb.held{background:rgba(255,160,0,0.25);border-color:#fa0}
.touch-side{display:flex;flex-direction:column;gap:6px;align-items:center}
.touch-mid{display:flex;gap:10px;align-items:center}
#touch-start{display:none;position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);z-index:20;pointer-events:auto;padding:18px 36px;border-radius:12px;border:2px solid #0ff;background:rgba(0,20,40,0.8);color:#0ff;font:bold 20px 'Courier New',monospace;text-shadow:0 0 10px #0ff;touch-action:none;user-select:none;-webkit-user-select:none}
@media (hover:none) and (pointer:coarse){
  #touch-controls{display:flex !important}
  #touch-start{display:block !important}
}
</style>
</head>
<body>
<div id="wrap">
  <canvas id="radar"></canvas>
  <div id="game">
    <canvas id="c"></canvas>
    <!-- Touch start button (mobile only) -->
    <div id="touch-start">TAP TO START</div>
    <!-- Touch controls overlay (mobile only) -->
    <div id="touch-controls">
      <div class="touch-row">
        <div class="touch-side">
          <div class="touch-btn" data-key="ArrowUp">UP</div>
          <div class="touch-btn" data-key="ArrowDown">DN</div>
        </div>
        <div class="touch-mid">
          <div class="touch-btn fire" data-key="Space">FIRE</div>
          <div class="touch-btn bomb" data-key="KeyB">BOM</div>
        </div>
        <div class="touch-side">
          <div class="touch-btn" data-key="Period">FLIP</div>
          <div class="touch-btn" data-key="KeyH">HOME</div>
        </div>
      </div>
    </div>
  </div>
  <div id="hud">
    <div class="hud-item"><span class="hud-label">Lives</span><span id="h-lives" class="hud-val">●●●●●</span></div>
    <div class="hud-item"><span class="hud-label">Fuel</span><span class="fuel-bar"><span id="h-fuel" class="fuel-fill" style="width:100%"></span></span></div>
    <div class="hud-item"><span class="hud-label">Bombs</span><span id="h-bombs" class="hud-val">5</span></div>
    <div class="hud-item"><span class="hud-label">Ammo</span><span class="ammo-bar"><span id="h-ammo" class="ammo-fill" style="width:100%"></span></span></div>
    <div class="hud-item"><span class="hud-label">Score</span><span id="h-score" class="hud-val green">0</span></div>
    <div class="hud-item"><span class="hud-label">Level</span><span id="h-level" class="hud-val">1</span></div>
  </div>
</div>

<script>
// ═══════════════════════════════════════════════════════════════
//  NEON SOPWITH — A Sopwith-inspired neon retro biplane game
// ═══════════════════════════════════════════════════════════════
(() => {
'use strict';

// ── Canvas setup ──
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const radarCanvas = document.getElementById('radar');
const rctx = radarCanvas.getContext('2d');

function resize() {
  const gd = document.getElementById('game');
  canvas.width = gd.clientWidth;
  canvas.height = gd.clientHeight;
  radarCanvas.width = radarCanvas.parentElement ? radarCanvas.clientWidth || window.innerWidth : window.innerWidth;
  radarCanvas.height = 40;
}
resize();
window.addEventListener('resize', resize);

// ── Constants ──
const WORLD_W = 12000;
const BULLET_SPEED = 600;
const BOMB_VXFRAC = 0.8;
const MAX_FUEL = 1000;
const MAX_AMMO = 200;
const MAX_BOMBS = 5;
const FLAK_INTERVAL = 90;
const FLAK_SPEED = 300;
const ENEMY_SPEED = 200;
const ENEMY_FIRE_INTERVAL = 60;
const BASE_WIDTH = 120;

// ── Sopwith-style flight model ──
// 16 discrete angles (like original), speed scalar, gravity table
const NUM_ANGLES = 16;
const ANGLE_STEP = (Math.PI * 2) / NUM_ANGLES;
// Gravity effect per angle index (from original Sopwith source)
// Nose up = negative (slows you), nose down = positive (speeds you up)
const GRAVITY_TABLE = [0, -1, -2, -3, -4, -3, -2, -1, 0, 1, 2, 3, 4, 3, 2, 1];
// Sine table (scaled to 1.0 instead of 256 as original)
const SIN_TABLE = [0, 0.383, 0.707, 0.924, 1.0, 0.924, 0.707, 0.383, 0, -0.383, -0.707, -0.924, -1.0, -0.924, -0.707, -0.383];
const COS_TABLE = SIN_TABLE.map((_, i) => SIN_TABLE[(i + 4) % 16]);

const PLANE_MIN_SPEED = 4;    // Minimum speed (like original)
const PLANE_MAX_SPEED = 9;    // Maximum speed
const PLANE_MAX_ACCEL = 4;    // Maximum throttle acceleration
const PIXELS_PER_UNIT = 28;   // Scale factor: Sopwith speed units → pixel velocity
const STALL_SPEED = 3;        // Below this speed, plane stalls
const TURN_RATE = 1;          // Angle steps per input (1 = one notch per press)
const PROJ_GRAVITY = 300;     // Gravity for projectiles (pixels/s²)

// ── Game State ──
const ST = { TITLE: 0, PLAYING: 1, DYING: 2, GAME_OVER: 3, LEVEL_COMPLETE: 4 };
let state = ST.TITLE;
let level = 1;
let score = 0;
let lives = 5;
let deathTimer = 0;
let levelTimer = 0;
let titlePlaneX = -200;

// ── Input ──
const keys = {};
window.addEventListener('keydown', e => { keys[e.code] = true; if(['Space','ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.code)) e.preventDefault(); });
window.addEventListener('keyup', e => { keys[e.code] = false; });

// ── Touch controls ──
const isTouchDevice = ('ontouchstart' in window) || navigator.maxTouchPoints > 0;

// Touch start button
const touchStartBtn = document.getElementById('touch-start');
if (touchStartBtn) {
  touchStartBtn.addEventListener('touchstart', (e) => {
    e.preventDefault();
    keys['Enter'] = true;
    setTimeout(() => { keys['Enter'] = false; }, 100);
    touchStartBtn.style.display = 'none';
  });
}

// Touch control buttons — map to keys
document.querySelectorAll('.touch-btn').forEach(btn => {
  const keyCode = btn.dataset.key;
  if (!keyCode) return;

  btn.addEventListener('touchstart', (e) => {
    e.preventDefault();
    keys[keyCode] = true;
    btn.classList.add('held');
    initAudio();
  });
  btn.addEventListener('touchend', (e) => {
    e.preventDefault();
    keys[keyCode] = false;
    btn.classList.remove('held');
  });
  btn.addEventListener('touchcancel', (e) => {
    keys[keyCode] = false;
    btn.classList.remove('held');
  });
});

// ── Audio (Web Audio synth) ──
let audioCtx = null;
let engineOsc = null;
let engineGain = null;
let audioStarted = false;

function initAudio() {
  if (audioStarted) return;
  audioStarted = true;
  try {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    engineOsc = audioCtx.createOscillator();
    engineGain = audioCtx.createGain();
    engineOsc.type = 'sawtooth';
    engineOsc.frequency.value = 80;
    engineGain.gain.value = 0;
    engineOsc.connect(engineGain);
    engineGain.connect(audioCtx.destination);
    engineOsc.start();
  } catch(e) {}
}

function playShoot() {
  if (!audioCtx) return;
  try {
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = 'square';
    o.frequency.value = 800;
    g.gain.value = 0.08;
    o.connect(g); g.connect(audioCtx.destination);
    o.start();
    o.frequency.exponentialRampToValueAtTime(200, audioCtx.currentTime + 0.05);
    g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.08);
    o.stop(audioCtx.currentTime + 0.08);
  } catch(e) {}
}

function playBoom(big) {
  if (!audioCtx) return;
  try {
    const dur = big ? 0.5 : 0.2;
    const buf = audioCtx.createBuffer(1, audioCtx.sampleRate * dur, audioCtx.sampleRate);
    const data = buf.getChannelData(0);
    for (let i = 0; i < data.length; i++) {
      data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / data.length, big ? 1.5 : 3);
    }
    const src = audioCtx.createBufferSource();
    const g = audioCtx.createGain();
    src.buffer = buf;
    g.gain.value = big ? 0.3 : 0.15;
    src.connect(g); g.connect(audioCtx.destination);
    src.start();
  } catch(e) {}
}

function playBombDrop() {
  if (!audioCtx) return;
  try {
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = 'sine';
    o.frequency.value = 400;
    g.gain.value = 0.07;
    o.connect(g); g.connect(audioCtx.destination);
    o.start();
    o.frequency.exponentialRampToValueAtTime(80, audioCtx.currentTime + 0.6);
    g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.6);
    o.stop(audioCtx.currentTime + 0.6);
  } catch(e) {}
}

// ── Stars (background) ──
const stars = [];
for (let i = 0; i < 200; i++) {
  stars.push({ x: Math.random() * WORLD_W, y: Math.random() * 500, b: Math.random() * 0.5 + 0.2, s: Math.random() * 1.5 + 0.5 });
}

// ── Terrain generation ──
let terrain = [];
let baseX = 0;

function generateTerrain() {
  terrain = new Float32Array(WORLD_W);
  const groundBase = canvas.height * 0.75;
  // Multi-octave noise for hilly terrain
  for (let x = 0; x < WORLD_W; x++) {
    let h = 0;
    h += Math.sin(x * 0.002) * 60;
    h += Math.sin(x * 0.005 + 1.3) * 30;
    h += Math.sin(x * 0.01 + 2.7) * 15;
    h += Math.sin(x * 0.025 + 0.5) * 8;
    terrain[x] = groundBase + h;
  }
  // Place base in a flat valley area with long clear zone
  baseX = 200;
  const baseCenter = baseX + BASE_WIDTH / 2;
  const flatY = groundBase; // flat at the baseline (no sine offsets)
  // Flatten a wide area: 150px before base, runway, and 400px after for takeoff clearance
  const flatStart = baseX - 150;
  const flatEnd = baseX + BASE_WIDTH + 400;
  for (let x = Math.max(0, flatStart - 80); x < Math.min(WORLD_W, flatEnd + 80); x++) {
    if (x >= flatStart && x <= flatEnd) {
      // Fully flat
      terrain[x] = flatY;
    } else if (x < flatStart) {
      // Blend in from left
      const t = (flatStart - x) / 80;
      terrain[x] = flatY * (1 - t) + terrain[x] * t;
    } else {
      // Blend out to right
      const t = (x - flatEnd) / 80;
      terrain[x] = flatY * (1 - t) + terrain[x] * t;
    }
  }
}

function getTerrainY(x) {
  const ix = Math.floor(((x % WORLD_W) + WORLD_W) % WORLD_W);
  const ix2 = (ix + 1) % WORLD_W;
  const frac = x - Math.floor(x);
  return terrain[ix] * (1 - frac) + terrain[ix2] * frac;
}

// ── Entities ──
let player, bullets, bombs, particles, enemies, buildings, flakShots, birds, oxen;

function initPlayer() {
  const ty = getTerrainY(baseX + BASE_WIDTH / 2);
  player = {
    x: baseX + BASE_WIDTH / 2,
    y: ty - 30,
    // Sopwith-style: single speed scalar + angle index
    speed: 0,             // current speed (in Sopwith units)
    accel: 0,             // throttle acceleration (0 to PLANE_MAX_ACCEL)
    angleIdx: 0,          // 0=right, 4=up, 8=left, 12=down (16 steps)
    flipped: false,       // facing left (mirrors angle)
    stalled: false,       // in stall state
    // Derived velocity (for rendering/collision)
    vx: 0, vy: 0,
    fuel: MAX_FUEL,
    ammo: MAX_AMMO,
    bombCount: MAX_BOMBS,
    fireCooldown: 0,
    bombCooldown: 0,
    invincible: 0,
    landed: true,
    autopilot: false,
    // Input edge detection
    _turnHeld: false,
    _flipHeld: false,
    _autoHeld: false,
    // Frame counter for speed updates (every 4 frames like original)
    moveCount: 0
  };
}

function spawnBuildings() {
  buildings = [];
  const types = ['hangar', 'factory', 'flak'];
  const minGap = 300;
  let lastX = baseX + BASE_WIDTH + 600;
  const count = 8 + level * 3;
  for (let i = 0; i < count; i++) {
    const bx = lastX + minGap + Math.random() * 400;
    if (bx >= WORLD_W - 200) break;
    const ty = getTerrainY(bx);
    const type = types[Math.floor(Math.random() * types.length)];
    const w = type === 'factory' ? 60 : type === 'hangar' ? 50 : 30;
    const h = type === 'factory' ? 40 : type === 'hangar' ? 30 : 45;
    buildings.push({
      x: bx, y: ty - h, w, h, type,
      hp: type === 'factory' ? 3 : 2,
      alive: true,
      flakTimer: Math.random() * FLAK_INTERVAL | 0,
      isTarget: true
    });
    lastX = bx + w;
  }
}

function spawnEnemies() {
  enemies = [];
  const count = 1 + level;
  for (let i = 0; i < count; i++) {
    const ex = 2000 + Math.random() * (WORLD_W - 3000);
    enemies.push({
      x: ex, y: 100 + Math.random() * 200,
      vx: -ENEMY_SPEED + Math.random() * 40, vy: 0,
      angle: Math.PI,
      hp: 2, alive: true,
      fireTimer: Math.random() * ENEMY_FIRE_INTERVAL | 0
    });
  }
}

function spawnOxen() {
  oxen = [];
  const count = 3 + level;
  for (let i = 0; i < count; i++) {
    const ox = 800 + Math.random() * (WORLD_W - 1000);
    const ty = getTerrainY(ox);
    oxen.push({ x: ox, y: ty - 10, w: 20, h: 10, alive: true, dir: Math.random() < 0.5 ? 1 : -1, speed: 15 + Math.random() * 10 });
  }
}

function spawnBirds() {
  birds = [];
  const count = 2 + level;
  for (let i = 0; i < count; i++) {
    const bx = Math.random() * WORLD_W;
    const by = 60 + Math.random() * 200;
    const flock = [];
    for (let j = 0; j < 5; j++) {
      flock.push({ x: bx + j * 12 + Math.random() * 8, y: by + Math.sin(j) * 10, alive: true });
    }
    birds.push({ flock, vx: -40 - Math.random() * 30, vy: Math.sin(bx) * 5 });
  }
}

function initLevel() {
  generateTerrain();
  initPlayer();
  bullets = [];
  bombs = [];
  particles = [];
  flakShots = [];
  spawnBuildings();
  spawnEnemies();
  spawnOxen();
  spawnBirds();
}

// ── Particle system ──
function addParticle(x, y, vx, vy, life, color, size) {
  particles.push({ x, y, vx, vy, life, maxLife: life, color, size: size || 2 });
}

function addExplosion(x, y, count, big) {
  for (let i = 0; i < count; i++) {
    const a = Math.random() * Math.PI * 2;
    const sp = (big ? 150 : 80) * Math.random();
    const colors = ['#ff0','#fa0','#f60','#fff','#ff8'];
    addParticle(x, y, Math.cos(a) * sp, Math.sin(a) * sp - 20, 0.4 + Math.random() * 0.4, colors[Math.floor(Math.random() * colors.length)], 2 + Math.random() * (big ? 4 : 2));
  }
}

function addEngineTrail(x, y, vx, vy) {
  addParticle(x, y, vx * 0.1 + (Math.random() - 0.5) * 20, vy * 0.1 + (Math.random() - 0.5) * 20, 0.2 + Math.random() * 0.15, Math.random() < 0.5 ? '#0af' : '#08f', 1.5);
}

// ── Drawing helpers ──
function neonGlow(ctx, color, blur) {
  ctx.shadowColor = color;
  ctx.shadowBlur = blur;
}
function clearGlow(ctx) {
  ctx.shadowColor = 'transparent';
  ctx.shadowBlur = 0;
}

function drawBiplane(ctx, x, y, angle, flipped, color, scale) {
  scale = scale || 1;
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(angle);
  if (flipped) ctx.scale(-1, 1);
  ctx.scale(scale, scale);

  neonGlow(ctx, color, 8);
  ctx.strokeStyle = color;
  ctx.lineWidth = 1.5;
  ctx.fillStyle = 'transparent';

  // Fuselage
  ctx.beginPath();
  ctx.moveTo(-18, 0);
  ctx.lineTo(18, 0);
  ctx.lineTo(22, -2);
  ctx.lineTo(18, -4);
  ctx.lineTo(-14, -4);
  ctx.lineTo(-18, 0);
  ctx.stroke();

  // Top wing
  ctx.beginPath();
  ctx.moveTo(-12, -8);
  ctx.lineTo(14, -8);
  ctx.lineTo(16, -6);
  ctx.lineTo(-10, -6);
  ctx.closePath();
  ctx.stroke();

  // Bottom wing
  ctx.beginPath();
  ctx.moveTo(-10, 2);
  ctx.lineTo(14, 2);
  ctx.lineTo(16, 4);
  ctx.lineTo(-8, 4);
  ctx.closePath();
  ctx.stroke();

  // Wing struts
  ctx.beginPath();
  ctx.moveTo(-4, -8);
  ctx.lineTo(-4, 4);
  ctx.moveTo(8, -8);
  ctx.lineTo(8, 4);
  ctx.stroke();

  // Tail
  ctx.beginPath();
  ctx.moveTo(-18, 0);
  ctx.lineTo(-24, -6);
  ctx.lineTo(-16, -6);
  ctx.lineTo(-14, -4);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(-18, 0);
  ctx.lineTo(-22, 4);
  ctx.lineTo(-16, 4);
  ctx.lineTo(-14, 2);
  ctx.stroke();

  // Propeller
  ctx.lineWidth = 2;
  const pt = Date.now() * 0.02;
  ctx.beginPath();
  ctx.moveTo(22, -6 * Math.sin(pt));
  ctx.lineTo(22, 6 * Math.sin(pt));
  ctx.stroke();

  clearGlow(ctx);
  ctx.restore();
}

// ── Camera ──
let camX = 0, camY = 0;

function updateCamera() {
  const targetX = player.x - canvas.width * 0.35;
  const targetY = player.y - canvas.height * 0.45;
  camX += (targetX - camX) * 0.08;
  camY += (targetY - camY) * 0.06;
  // Clamp vertical
  camY = Math.max(-100, Math.min(camY, 400));
}

// ── Update logic ──
let lastTime = 0;
let frameCount = 0;

function update(dt) {
  frameCount++;
  if (state === ST.PLAYING) {
    updatePlayer(dt);
    updateBullets(dt);
    updateBombs(dt);
    updateEnemies(dt);
    updateFlak(dt);
    updateBirds(dt);
    updateOxen(dt);
    updateParticles(dt);
    updateCamera();
    checkLevelComplete();
    updateHUD();
  } else if (state === ST.DYING) {
    updateParticles(dt);
    deathTimer -= dt;
    if (deathTimer <= 0) {
      if (lives <= 0) {
        state = ST.GAME_OVER;
      } else {
        initPlayer();
        player.invincible = 3; // 3 seconds of invincibility after respawn
        // Clear hostile projectiles near spawn
        bullets = bullets.filter(b => b.friendly);
        flakShots = [];
        state = ST.PLAYING;
      }
    }
  } else if (state === ST.LEVEL_COMPLETE) {
    updateParticles(dt);
    levelTimer -= dt;
    if (levelTimer <= 0) {
      level++;
      initLevel();
      state = ST.PLAYING;
    }
  }
}

// ── Angle helpers ──
// Angle indices: 0=right, 4=up, 8=left, 12=down (counterclockwise)
// "Nose up" = increment toward 4, "Nose down" = decrement toward 12 (via 0→15→14→13...)

function getEffectiveAngle(p) {
  // When flipped (facing left), mirror: right-side angles map to left-side
  if (p.flipped) {
    return (NUM_ANGLES - p.angleIdx) % NUM_ANGLES;
  }
  return p.angleIdx;
}

// Radian angle for canvas rendering (canvas: 0=right, positive=clockwise=down)
function getPlaneRadians(p) {
  const effAngle = getEffectiveAngle(p);
  // effAngle goes counterclockwise, canvas goes clockwise, so negate
  return -effAngle * ANGLE_STEP;
}

function updatePlayer(dt) {
  const p = player;
  p.moveCount++;

  // ── Autopilot: fly home ──
  if (p.autopilot) {
    const homeX = baseX + BASE_WIDTH / 2;
    const dx = homeX - p.x;

    // Face toward home
    if (dx > 50 && p.flipped) { p.flipped = false; p.angleIdx = (NUM_ANGLES - p.angleIdx) % NUM_ANGLES; }
    if (dx < -50 && !p.flipped) { p.flipped = true; p.angleIdx = (NUM_ANGLES - p.angleIdx) % NUM_ANGLES; }

    p.accel = PLANE_MAX_ACCEL;

    if (Math.abs(dx) > 80) {
      // Level flight: move angleIdx toward 0
      if (p.angleIdx > 0 && p.angleIdx <= 8) p.angleIdx--;
      else if (p.angleIdx > 8) p.angleIdx++;
      if (p.angleIdx >= NUM_ANGLES) p.angleIdx = 0;
    } else {
      // Approach base
      const homeY = getTerrainY(homeX) - 12;
      if (p.y > homeY + 5) {
        // Too low, nose up
        if (p.angleIdx < 4) p.angleIdx++;
      } else if (p.y < homeY - 20) {
        // Too high, nose down
        if (p.angleIdx > 0 && p.angleIdx <= 4) p.angleIdx--;
        else if (p.angleIdx === 0) p.angleIdx = 15;
        else if (p.angleIdx > 12) p.angleIdx--;
      }

      // Landing check
      const groundY = getTerrainY(p.x);
      if (p.y >= groundY - 15 && p.speed <= PLANE_MIN_SPEED + 2 && (p.angleIdx <= 1 || p.angleIdx >= 15)) {
        p.landed = true;
        p.autopilot = false;
        p.speed = 0; p.accel = 0; p.angleIdx = 0;
        p.vx = 0; p.vy = 0; p.y = groundY - 8;
        p.fuel = MAX_FUEL; p.ammo = MAX_AMMO; p.bombCount = MAX_BOMBS;
        return;
      }
    }
  }

  // ── Manual controls ──
  if (!p.autopilot) {
    // Accelerate (X or ArrowUp)
    if (keys['KeyX'] || keys['ArrowUp']) {
      if (p.accel < PLANE_MAX_ACCEL) p.accel++;
    }
    // Decelerate (Backslash)
    if (keys['Backslash'] || keys['Backquote']) {
      if (p.accel > 0) p.accel--;
    }

    // Nose up (Comma or ArrowUp) — INCREMENT angle index toward 4
    if (keys['Comma'] || keys['ArrowUp']) {
      if (!p._turnHeld || (p.moveCount % 3 === 0)) {
        p.angleIdx = (p.angleIdx + 1) % NUM_ANGLES;
        p._turnHeld = true;
      }
    }
    // Nose down (Slash or ArrowDown) — DECREMENT angle index toward 12 via 0→15→14...
    else if (keys['Slash'] || keys['ArrowDown']) {
      if (!p._turnHeld || (p.moveCount % 3 === 0)) {
        p.angleIdx = ((p.angleIdx - 1) + NUM_ANGLES) % NUM_ANGLES;
        p._turnHeld = true;
      }
    } else {
      p._turnHeld = false;
    }

    // Flip (Period or F)
    if (keys['Period'] || keys['KeyF']) {
      if (!p._flipHeld) {
        p.flipped = !p.flipped;
        p.angleIdx = (NUM_ANGLES - p.angleIdx) % NUM_ANGLES;
        p._flipHeld = true;
      }
    } else {
      p._flipHeld = false;
    }

    // Autopilot (H)
    if (keys['KeyH']) {
      if (!p._autoHeld) { p.autopilot = true; p._autoHeld = true; }
    } else { p._autoHeld = false; }

    // Fire
    if (keys['Space'] && p.fireCooldown <= 0 && p.ammo > 0) {
      const rad = getPlaneRadians(p);
      const bx = p.x + Math.cos(rad) * 25;
      const by = p.y + Math.sin(rad) * 25;
      const bvx = Math.cos(rad) * BULLET_SPEED + p.vx * 0.3;
      const bvy = Math.sin(rad) * BULLET_SPEED + p.vy * 0.3;
      bullets.push({ x: bx, y: by, vx: bvx, vy: bvy, life: 1.2, friendly: true });
      p.ammo--;
      p.fireCooldown = 0.08;
      playShoot();
    }

    // Bomb
    if (keys['KeyB'] && p.bombCooldown <= 0 && p.bombCount > 0) {
      bombs.push({ x: p.x, y: p.y + 5, vx: p.vx * BOMB_VXFRAC, vy: p.vy + 20, life: 5 });
      p.bombCount--;
      p.bombCooldown = 0.4;
      playBombDrop();
    }
  }

  p.fireCooldown -= dt;
  p.bombCooldown -= dt;
  if (p.invincible > 0) p.invincible -= dt;

  // ── Sopwith-style physics ──
  if (!p.landed) {
    const effAngle = getEffectiveAngle(p);

    // Speed update every 4 frames (matches original)
    if (p.moveCount % 4 === 0) {
      const grav = GRAVITY_TABLE[effAngle];
      const targetSpeed = PLANE_MIN_SPEED + p.accel + grav;
      if (p.speed < targetSpeed) p.speed++;
      else if (p.speed > targetSpeed) p.speed--;
      if (p.speed > PLANE_MAX_SPEED) p.speed = PLANE_MAX_SPEED;
    }

    // Stall: speed too low
    if (p.speed <= STALL_SPEED && !p.stalled) {
      p.stalled = true;
    }

    if (p.stalled) {
      // Nose drops toward "down" (index 12 for right-facing, 4 for left-facing)
      if (p.moveCount % 6 === 0) {
        const downIdx = p.flipped ? 4 : 12;
        if (p.angleIdx !== downIdx) {
          // Find shortest path to downIdx
          const diff = ((downIdx - p.angleIdx) + NUM_ANGLES) % NUM_ANGLES;
          if (diff <= 8) p.angleIdx = (p.angleIdx + 1) % NUM_ANGLES;
          else p.angleIdx = ((p.angleIdx - 1) + NUM_ANGLES) % NUM_ANGLES;
        }
      }
      // Recover when speed adequate and near level flight
      if (p.speed >= PLANE_MIN_SPEED && (effAngle <= 2 || effAngle >= 14)) {
        p.stalled = false;
      }
    }

    // Velocity from speed + angle
    // COS_TABLE/SIN_TABLE: index 0=right, 4=up in math coords
    // Canvas: Y-down, so negate SIN for vy
    p.vx = COS_TABLE[effAngle] * p.speed * PIXELS_PER_UNIT;
    p.vy = -SIN_TABLE[effAngle] * p.speed * PIXELS_PER_UNIT;

    // Stall gravity
    if (p.stalled || p.speed < PLANE_MIN_SPEED) {
      p.vy += 150 * dt;
    }

    // Move
    p.x += p.vx * dt;
    p.y += p.vy * dt;

    // Fuel
    p.fuel -= dt * (15 + p.accel * 8);
    if (p.fuel <= 0) { p.fuel = 0; p.accel = 0; }

    // Engine trail
    if (p.accel > 0) {
      const rad = getPlaneRadians(p);
      const tx = p.x - Math.cos(rad) * 20;
      const ty = p.y - Math.sin(rad) * 20;
      addEngineTrail(tx, ty, -p.vx * 0.3, -p.vy * 0.3);
    }

    // World wrap
    if (p.x < 0) p.x += WORLD_W;
    if (p.x >= WORLD_W) p.x -= WORLD_W;

    // Ceiling
    if (p.y < -50) {
      p.y = -50;
      p.stalled = true;
      p.speed = 0;
    }

    // Ground collision
    const groundY = getTerrainY(p.x);
    if (p.y >= groundY - 8) {
      const nearBase = p.x > baseX - 30 && p.x < baseX + BASE_WIDTH + 30;
      // Level = angleIdx near 0 (either 0, 1, or 15)
      const levelEnough = (p.angleIdx <= 1 || p.angleIdx >= 15);
      const slowEnough = p.speed <= PLANE_MIN_SPEED + 2;

      if (nearBase && levelEnough && slowEnough && !p.stalled) {
        p.y = groundY - 8;
        p.vy = 0; p.vx = 0; p.speed = 0; p.accel = 0; p.angleIdx = 0;
        p.landed = true; p.stalled = false;
        p.fuel = MAX_FUEL; p.ammo = MAX_AMMO; p.bombCount = MAX_BOMBS;
      } else {
        killPlayer();
        return;
      }
    }
  } else {
    // ── On ground at base ──
    if (keys['KeyX'] || keys['ArrowUp']) {
      p.landed = false;
      p.stalled = false;
      p.accel = PLANE_MAX_ACCEL;
      p.speed = PLANE_MAX_SPEED - 1;
      p.angleIdx = 2; // Slight nose-up: index 2 = climbing right at ~45°
    }
    p.y = getTerrainY(p.x) - 8;
  }
}

function killPlayer() {
  addExplosion(player.x, player.y, 40, true);
  playBoom(true);
  // Crater in terrain
  for (let dx = -30; dx <= 30; dx++) {
    const ix = Math.floor(((player.x + dx) % WORLD_W + WORLD_W) % WORLD_W);
    if (ix >= 0 && ix < WORLD_W) {
      terrain[ix] += (30 - Math.abs(dx)) * 0.5;
    }
  }
  lives--;
  state = ST.DYING;
  deathTimer = 2;
}

function updateBullets(dt) {
  for (let i = bullets.length - 1; i >= 0; i--) {
    const b = bullets[i];
    b.x += b.vx * dt;
    b.y += b.vy * dt;
    b.vy += PROJ_GRAVITY * 0.3 * dt;
    b.life -= dt;

    // World wrap
    if (b.x < 0) b.x += WORLD_W;
    if (b.x >= WORLD_W) b.x -= WORLD_W;

    // Ground hit
    if (b.y >= getTerrainY(b.x)) {
      addParticle(b.x, b.y, 0, -30, 0.2, '#ff0', 2);
      bullets.splice(i, 1);
      continue;
    }

    if (b.life <= 0 || b.y < -200) {
      bullets.splice(i, 1);
      continue;
    }

    // Hit buildings
    if (b.friendly) {
      for (const bld of buildings) {
        if (!bld.alive) continue;
        if (b.x > bld.x && b.x < bld.x + bld.w && b.y > bld.y && b.y < bld.y + bld.h) {
          bld.hp--;
          if (bld.hp <= 0) {
            bld.alive = false;
            addExplosion(bld.x + bld.w / 2, bld.y + bld.h / 2, 25, true);
            playBoom(true);
            score += bld.type === 'flak' ? 200 : bld.type === 'factory' ? 300 : 100;
            // Terrain crater
            for (let dx = -20; dx <= 20; dx++) {
              const ix = Math.floor(((bld.x + bld.w / 2 + dx) % WORLD_W + WORLD_W) % WORLD_W);
              if (ix >= 0 && ix < WORLD_W) terrain[ix] += (20 - Math.abs(dx)) * 0.3;
            }
          } else {
            addExplosion(b.x, b.y, 5, false);
          }
          bullets.splice(i, 1);
          break;
        }
      }
    }

    // Friendly bullets hit enemies
    if (b.friendly) {
      for (const en of enemies) {
        if (!en.alive) continue;
        if (Math.abs(b.x - en.x) < 20 && Math.abs(b.y - en.y) < 12) {
          en.hp--;
          if (en.hp <= 0) {
            en.alive = false;
            addExplosion(en.x, en.y, 20, true);
            playBoom(false);
            score += 500;
          }
          bullets.splice(i, 1);
          break;
        }
      }
    }

    // Enemy bullets hit player
    if (!b.friendly && player.invincible <= 0) {
      if (Math.abs(b.x - player.x) < 18 && Math.abs(b.y - player.y) < 10) {
        killPlayer();
        bullets.splice(i, 1);
        break;
      }
    }
  }
}

function updateBombs(dt) {
  for (let i = bombs.length - 1; i >= 0; i--) {
    const b = bombs[i];
    b.x += b.vx * dt;
    b.y += b.vy * dt;
    b.vy += PROJ_GRAVITY * dt;
    b.life -= dt;

    if (b.x < 0) b.x += WORLD_W;
    if (b.x >= WORLD_W) b.x -= WORLD_W;

    let hit = false;

    // Ground hit
    if (b.y >= getTerrainY(b.x)) {
      hit = true;
    }

    // Building hit
    for (const bld of buildings) {
      if (!bld.alive) continue;
      if (b.x > bld.x - 5 && b.x < bld.x + bld.w + 5 && b.y > bld.y - 5 && b.y < bld.y + bld.h + 5) {
        bld.hp -= 2;
        if (bld.hp <= 0) {
          bld.alive = false;
          score += bld.type === 'flak' ? 200 : bld.type === 'factory' ? 300 : 100;
        }
        hit = true;
        break;
      }
    }

    if (hit || b.life <= 0) {
      addExplosion(b.x, b.y, 30, true);
      playBoom(true);
      // Crater
      for (let dx = -40; dx <= 40; dx++) {
        const ix = Math.floor(((b.x + dx) % WORLD_W + WORLD_W) % WORLD_W);
        if (ix >= 0 && ix < WORLD_W) {
          terrain[ix] += (40 - Math.abs(dx)) * 0.4;
        }
      }
      bombs.splice(i, 1);
    }
  }
}

function updateEnemies(dt) {
  for (const en of enemies) {
    if (!en.alive) continue;

    // Don't chase player if they are invincible (just respawned) or landed at base
    const playerSafe = player.invincible > 0 || player.landed;

    let dx, dy, dist, desiredAngle;
    if (playerSafe) {
      // Patrol: fly away from base, circle in the world
      const patrolX = 3000 + ((en.x * 7) % 5000);
      const patrolY = 150;
      dx = patrolX - en.x;
      dy = patrolY - en.y;
      dist = Math.sqrt(dx * dx + dy * dy);
      desiredAngle = Math.atan2(dy, dx);
    } else {
      dx = player.x - en.x;
      dy = player.y - en.y;
      dist = Math.sqrt(dx * dx + dy * dy);
      desiredAngle = Math.atan2(dy, dx);
    }

    // Adjust angle toward target
    let angleDiff = desiredAngle - en.angle;
    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
    en.angle += Math.sign(angleDiff) * Math.min(Math.abs(angleDiff), 1.5 * dt);

    en.vx = Math.cos(en.angle) * ENEMY_SPEED;
    en.vy = Math.sin(en.angle) * ENEMY_SPEED;

    en.x += en.vx * dt;
    en.y += en.vy * dt;

    // Keep above ground
    const groundY = getTerrainY(en.x);
    if (en.y > groundY - 40) en.y = groundY - 40;
    if (en.y < 30) en.y = 30;

    // World wrap
    if (en.x < 0) en.x += WORLD_W;
    if (en.x >= WORLD_W) en.x -= WORLD_W;

    // Fire at player (only when not safe)
    en.fireTimer--;
    if (en.fireTimer <= 0 && dist < 600 && !playerSafe) {
      const bvx = Math.cos(en.angle) * BULLET_SPEED * 0.7;
      const bvy = Math.sin(en.angle) * BULLET_SPEED * 0.7;
      bullets.push({ x: en.x + Math.cos(en.angle) * 20, y: en.y + Math.sin(en.angle) * 20, vx: bvx, vy: bvy, life: 1.0, friendly: false });
      en.fireTimer = ENEMY_FIRE_INTERVAL + Math.random() * 30 | 0;
    }

    // Engine trail
    addParticle(en.x - Math.cos(en.angle) * 18, en.y - Math.sin(en.angle) * 18, -en.vx * 0.05, -en.vy * 0.05, 0.15, '#f0a', 1.5);

    // Collision with player
    if (player.invincible <= 0 && state === ST.PLAYING) {
      if (Math.abs(en.x - player.x) < 25 && Math.abs(en.y - player.y) < 15) {
        en.alive = false;
        addExplosion(en.x, en.y, 20, true);
        killPlayer();
      }
    }
  }
}

function updateFlak(dt) {
  // Buildings shoot flak
  for (const bld of buildings) {
    if (!bld.alive || bld.type !== 'flak') continue;
    bld.flakTimer--;
    if (bld.flakTimer <= 0) {
      const dx = player.x - (bld.x + bld.w / 2);
      const dy = player.y - (bld.y);
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < 500) {
        const a = Math.atan2(dy, dx);
        flakShots.push({
          x: bld.x + bld.w / 2, y: bld.y,
          vx: Math.cos(a) * FLAK_SPEED, vy: Math.sin(a) * FLAK_SPEED,
          life: 1.5
        });
      }
      bld.flakTimer = FLAK_INTERVAL + Math.random() * 20 | 0;
    }
  }

  // Update flak shots
  for (let i = flakShots.length - 1; i >= 0; i--) {
    const f = flakShots[i];
    f.x += f.vx * dt;
    f.y += f.vy * dt;
    f.life -= dt;

    // Trail
    addParticle(f.x, f.y, 0, 0, 0.1, '#f80', 1);

    if (f.life <= 0) {
      // Burst
      addExplosion(f.x, f.y, 8, false);
      flakShots.splice(i, 1);
      continue;
    }

    // Hit player
    if (player.invincible <= 0 && state === ST.PLAYING) {
      if (Math.abs(f.x - player.x) < 20 && Math.abs(f.y - player.y) < 15) {
        killPlayer();
        flakShots.splice(i, 1);
      }
    }
  }
}

function updateBirds(dt) {
  for (const bg of birds) {
    for (const b of bg.flock) {
      if (!b.alive) continue;
      b.x += bg.vx * dt;
      b.y += bg.vy * dt + Math.sin(Date.now() * 0.005 + b.x * 0.1) * 0.3;

      if (b.x < -100) b.x += WORLD_W + 200;

      // Collision with player
      if (player.invincible <= 0 && state === ST.PLAYING) {
        if (Math.abs(b.x - player.x) < 15 && Math.abs(b.y - player.y) < 10) {
          b.alive = false;
          addExplosion(b.x, b.y, 8, false);
          killPlayer();
        }
      }
    }
  }
}

function updateOxen(dt) {
  for (const o of oxen) {
    if (!o.alive) continue;
    o.x += o.dir * o.speed * dt;
    const ty = getTerrainY(o.x);
    o.y = ty - o.h;

    // Reverse at edges or randomly
    if (Math.random() < 0.005) o.dir *= -1;

    // Collision with player
    if (player.invincible <= 0 && state === ST.PLAYING) {
      if (player.x > o.x - 5 && player.x < o.x + o.w + 5 && player.y > o.y - 10 && player.y < o.y + o.h + 5) {
        o.alive = false;
        addExplosion(o.x + o.w / 2, o.y, 10, false);
        killPlayer();
      }
    }
  }
}

function updateParticles(dt) {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.vy += 40 * dt;
    p.life -= dt;
    if (p.life <= 0) particles.splice(i, 1);
  }
}

function checkLevelComplete() {
  const targets = buildings.filter(b => b.isTarget && b.alive);
  if (targets.length === 0) {
    state = ST.LEVEL_COMPLETE;
    levelTimer = 3;
    score += 1000 * level;
  }
}

// ── HUD update ──
function updateHUD() {
  const p = player;
  let livesStr = '';
  for (let i = 0; i < 5; i++) livesStr += i < lives ? '●' : '○';
  document.getElementById('h-lives').textContent = livesStr;
  document.getElementById('h-fuel').style.width = (p.fuel / MAX_FUEL * 100) + '%';
  document.getElementById('h-bombs').textContent = p.bombCount;
  document.getElementById('h-ammo').style.width = (p.ammo / MAX_AMMO * 100) + '%';
  document.getElementById('h-score').textContent = String(score).padStart(6, '0');
  document.getElementById('h-level').textContent = level;
}

// ── Draw ──
function draw() {
  const W = canvas.width;
  const H = canvas.height;

  // Clear
  ctx.fillStyle = '#0a0a0f';
  ctx.fillRect(0, 0, W, H);

  if (state === ST.TITLE) {
    drawTitle(W, H);
    drawRadarEmpty();
    return;
  }

  // Stars
  ctx.fillStyle = '#fff';
  for (const s of stars) {
    const sx = ((s.x - camX * 0.3) % W + W) % W;
    const sy = s.y - camY * 0.1;
    if (sy < 0 || sy > H) continue;
    const flicker = s.b + Math.sin(Date.now() * 0.003 + s.x) * 0.1;
    ctx.globalAlpha = flicker;
    ctx.fillRect(sx, sy, s.s, s.s);
  }
  ctx.globalAlpha = 1;

  // ── World drawing (offset by camera) ──
  ctx.save();
  ctx.translate(-camX, -camY);

  // Terrain
  drawTerrain(W, H);

  // Home base
  drawBase();

  // Buildings
  for (const bld of buildings) {
    if (!bld.alive) continue;
    const screenX = bld.x - camX;
    if (screenX < -100 || screenX > W + 100) continue;
    drawBuilding(bld);
  }

  // Oxen
  for (const o of oxen) {
    if (!o.alive) continue;
    const screenX = o.x - camX;
    if (screenX < -50 || screenX > W + 50) continue;
    drawOx(o);
  }

  // Birds
  for (const bg of birds) {
    for (const b of bg.flock) {
      if (!b.alive) continue;
      const screenX = b.x - camX;
      if (screenX < -50 || screenX > W + 50) continue;
      neonGlow(ctx, '#aaf', 4);
      ctx.strokeStyle = '#aaf';
      ctx.lineWidth = 1;
      ctx.beginPath();
      const wing = Math.sin(Date.now() * 0.01 + b.x) * 4;
      ctx.moveTo(b.x - 6, b.y + wing);
      ctx.lineTo(b.x, b.y);
      ctx.lineTo(b.x + 6, b.y + wing);
      ctx.stroke();
      clearGlow(ctx);
    }
  }

  // Bombs
  for (const b of bombs) {
    const screenX = b.x - camX;
    if (screenX < -50 || screenX > W + 50) continue;
    neonGlow(ctx, '#fa0', 6);
    ctx.fillStyle = '#fa0';
    ctx.beginPath();
    ctx.arc(b.x, b.y, 4, 0, Math.PI * 2);
    ctx.fill();
    clearGlow(ctx);
    // Trail
    addParticle(b.x, b.y - 2, 0, -10, 0.15, '#f80', 1);
  }

  // Flak shots
  for (const f of flakShots) {
    neonGlow(ctx, '#f80', 6);
    ctx.fillStyle = '#ff0';
    ctx.beginPath();
    ctx.arc(f.x, f.y, 3, 0, Math.PI * 2);
    ctx.fill();
    clearGlow(ctx);
  }

  // Bullets
  for (const b of bullets) {
    const screenX = b.x - camX;
    if (screenX < -50 || screenX > W + 50) continue;
    const col = b.friendly ? '#0ff' : '#f55';
    neonGlow(ctx, col, 4);
    ctx.fillStyle = col;
    ctx.beginPath();
    ctx.arc(b.x, b.y, 2, 0, Math.PI * 2);
    ctx.fill();
    clearGlow(ctx);
  }

  // Enemies
  for (const en of enemies) {
    if (!en.alive) continue;
    const screenX = en.x - camX;
    if (screenX < -100 || screenX > W + 100) continue;
    const flipped = en.vx < 0;
    drawBiplane(ctx, en.x, en.y, en.angle, flipped, '#f0a');
  }

  // Player
  if (state === ST.PLAYING) {
    if (player.invincible <= 0 || Math.sin(Date.now() * 0.02) > 0) {
      drawBiplane(ctx, player.x, player.y, getPlaneRadians(player), player.flipped, '#0ff');
    }
  }

  // Particles
  for (const p of particles) {
    const alpha = p.life / p.maxLife;
    ctx.globalAlpha = alpha;
    ctx.fillStyle = p.color;
    neonGlow(ctx, p.color, 4);
    ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
    clearGlow(ctx);
  }
  ctx.globalAlpha = 1;

  ctx.restore();

  // ── Overlays ──
  if (state === ST.DYING) {
    ctx.fillStyle = `rgba(255, 50, 0, ${0.3 * (deathTimer / 2)})`;
    ctx.fillRect(0, 0, W, H);
    ctx.fillStyle = '#fff';
    ctx.font = '24px "Courier New", monospace';
    ctx.textAlign = 'center';
    ctx.fillText(lives > 0 ? 'PLANE DESTROYED' : 'GAME OVER', W / 2, H / 2);
  }

  if (state === ST.GAME_OVER) {
    ctx.fillStyle = 'rgba(0,0,0,0.7)';
    ctx.fillRect(0, 0, W, H);
    neonGlow(ctx, '#f55', 12);
    ctx.fillStyle = '#f55';
    ctx.font = 'bold 36px "Courier New", monospace';
    ctx.textAlign = 'center';
    ctx.fillText('GAME OVER', W / 2, H / 2 - 30);
    clearGlow(ctx);
    ctx.fillStyle = '#888';
    ctx.font = '16px "Courier New", monospace';
    ctx.fillText(`FINAL SCORE: ${score}`, W / 2, H / 2 + 10);
    ctx.fillText('Press ENTER to restart', W / 2, H / 2 + 40);
  }

  if (state === ST.LEVEL_COMPLETE) {
    neonGlow(ctx, '#0f0', 12);
    ctx.fillStyle = '#0f0';
    ctx.font = 'bold 30px "Courier New", monospace';
    ctx.textAlign = 'center';
    ctx.fillText(`LEVEL ${level} COMPLETE!`, W / 2, H / 2 - 10);
    clearGlow(ctx);
    ctx.fillStyle = '#0ff';
    ctx.font = '16px "Courier New", monospace';
    ctx.fillText(`+${1000 * level} bonus points`, W / 2, H / 2 + 20);
  }

  // Radar
  drawRadar();
}

function drawTerrain(W, H) {
  const startX = Math.max(0, Math.floor(camX) - 2);
  const endX = Math.min(WORLD_W - 1, Math.floor(camX + W) + 2);
  const terrainBottom = camY + H + 50;

  // Filled terrain (dark)
  ctx.fillStyle = '#0d1a0d';
  ctx.beginPath();
  ctx.moveTo(startX, terrainBottom);
  for (let x = startX; x <= endX; x += 2) {
    ctx.lineTo(x, terrain[x]);
  }
  ctx.lineTo(endX, terrainBottom);
  ctx.closePath();
  ctx.fill();

  // Neon terrain line
  neonGlow(ctx, '#0f8', 8);
  ctx.strokeStyle = '#0fa';
  ctx.lineWidth = 2;
  ctx.beginPath();
  for (let x = startX; x <= endX; x += 2) {
    if (x === startX) ctx.moveTo(x, terrain[x]);
    else ctx.lineTo(x, terrain[x]);
  }
  ctx.stroke();

  // Second glow line (brighter, thinner)
  ctx.strokeStyle = '#5ff';
  ctx.lineWidth = 0.5;
  ctx.beginPath();
  for (let x = startX; x <= endX; x += 2) {
    if (x === startX) ctx.moveTo(x, terrain[x]);
    else ctx.lineTo(x, terrain[x]);
  }
  ctx.stroke();
  clearGlow(ctx);
}

function drawBase() {
  const by = getTerrainY(baseX + BASE_WIDTH / 2);
  // Runway
  neonGlow(ctx, '#0af', 6);
  ctx.strokeStyle = '#0af';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(baseX, by);
  ctx.lineTo(baseX + BASE_WIDTH, by);
  ctx.stroke();

  // Dashes
  ctx.strokeStyle = '#05a';
  ctx.lineWidth = 1;
  ctx.setLineDash([8, 8]);
  ctx.beginPath();
  ctx.moveTo(baseX + 10, by - 3);
  ctx.lineTo(baseX + BASE_WIDTH - 10, by - 3);
  ctx.stroke();
  ctx.setLineDash([]);

  // Label
  ctx.fillStyle = '#0af';
  ctx.font = '10px "Courier New", monospace';
  ctx.textAlign = 'center';
  ctx.fillText('HOME BASE', baseX + BASE_WIDTH / 2, by - 10);
  clearGlow(ctx);
}

function drawBuilding(bld) {
  const col = bld.type === 'flak' ? '#f80' : bld.type === 'factory' ? '#f44' : '#fa0';
  neonGlow(ctx, col, 8);
  ctx.strokeStyle = col;
  ctx.lineWidth = 1.5;
  ctx.strokeRect(bld.x, bld.y, bld.w, bld.h);

  // Inner detail
  if (bld.type === 'factory') {
    // Chimney
    ctx.strokeRect(bld.x + bld.w - 10, bld.y - 15, 8, 15);
    // Smoke particle occasionally
    if (Math.random() < 0.05) {
      addParticle(bld.x + bld.w - 6, bld.y - 15, (Math.random() - 0.5) * 10, -20, 0.5, '#555', 2);
    }
  } else if (bld.type === 'flak') {
    // Gun barrel
    ctx.beginPath();
    ctx.moveTo(bld.x + bld.w / 2, bld.y);
    ctx.lineTo(bld.x + bld.w / 2, bld.y - 12);
    ctx.stroke();
    // Cross
    ctx.beginPath();
    ctx.moveTo(bld.x + bld.w / 2 - 6, bld.y - 10);
    ctx.lineTo(bld.x + bld.w / 2 + 6, bld.y - 10);
    ctx.stroke();
  } else {
    // Hangar door
    ctx.beginPath();
    ctx.arc(bld.x + bld.w / 2, bld.y + bld.h, bld.w * 0.35, Math.PI, 0);
    ctx.stroke();
  }

  // HP indicator
  if (bld.hp > 1) {
    ctx.fillStyle = col;
    ctx.font = '8px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('●'.repeat(bld.hp), bld.x + bld.w / 2, bld.y - 4);
  }
  clearGlow(ctx);
}

function drawOx(o) {
  neonGlow(ctx, '#0f0', 6);
  ctx.strokeStyle = '#0f0';
  ctx.lineWidth = 1.5;

  // Body
  ctx.strokeRect(o.x + 3, o.y + 1, 14, 6);
  // Legs
  ctx.beginPath();
  ctx.moveTo(o.x + 5, o.y + 7); ctx.lineTo(o.x + 5, o.y + 10);
  ctx.moveTo(o.x + 8, o.y + 7); ctx.lineTo(o.x + 8, o.y + 10);
  ctx.moveTo(o.x + 13, o.y + 7); ctx.lineTo(o.x + 13, o.y + 10);
  ctx.moveTo(o.x + 16, o.y + 7); ctx.lineTo(o.x + 16, o.y + 10);
  ctx.stroke();
  // Head
  const headX = o.dir > 0 ? o.x + 17 : o.x + 3;
  ctx.strokeRect(headX - 2, o.y - 1, 4, 4);
  // Horns
  ctx.beginPath();
  ctx.moveTo(headX - 2, o.y - 1); ctx.lineTo(headX - 4, o.y - 3);
  ctx.moveTo(headX + 2, o.y - 1); ctx.lineTo(headX + 4, o.y - 3);
  ctx.stroke();
  clearGlow(ctx);
}

function drawTitle(W, H) {
  // Animated background stars
  ctx.fillStyle = '#fff';
  for (const s of stars) {
    const sx = (s.x * 0.1 + Date.now() * 0.005) % W;
    const sy = s.y;
    if (sy > H) continue;
    ctx.globalAlpha = s.b + Math.sin(Date.now() * 0.003 + s.x) * 0.1;
    ctx.fillRect(sx, sy, s.s, s.s);
  }
  ctx.globalAlpha = 1;

  // Title
  neonGlow(ctx, '#0ff', 20);
  ctx.fillStyle = '#0ff';
  ctx.font = `bold ${Math.min(60, W * 0.08)}px "Courier New", monospace`;
  ctx.textAlign = 'center';
  ctx.fillText('NEON SOPWITH', W / 2, H * 0.25);
  clearGlow(ctx);

  neonGlow(ctx, '#0af', 10);
  ctx.fillStyle = '#0af';
  ctx.font = `${Math.min(18, W * 0.025)}px "Courier New", monospace`;
  ctx.fillText('A Retro Biplane Shooter', W / 2, H * 0.25 + 35);
  clearGlow(ctx);

  // Animated biplane
  titlePlaneX += 2;
  if (titlePlaneX > W + 200) titlePlaneX = -200;
  const titlePlaneY = H * 0.4 + Math.sin(Date.now() * 0.002) * 15;
  drawBiplane(ctx, titlePlaneX, titlePlaneY, Math.sin(Date.now() * 0.001) * 0.1, false, '#0ff', 2);
  // Engine trail
  for (let i = 0; i < 3; i++) {
    addParticle(titlePlaneX - 40 - i * 10, titlePlaneY + (Math.random() - 0.5) * 5, -30, (Math.random() - 0.5) * 10, 0.3, '#08f', 2);
  }
  // Update & draw title particles
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx * 0.016;
    p.y += p.vy * 0.016;
    p.life -= 0.016;
    if (p.life <= 0) { particles.splice(i, 1); continue; }
    ctx.globalAlpha = p.life / p.maxLife;
    ctx.fillStyle = p.color;
    ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
  }
  ctx.globalAlpha = 1;

  // Blinking "Press ENTER"
  if (Math.sin(Date.now() * 0.004) > 0) {
    neonGlow(ctx, '#fff', 8);
    ctx.fillStyle = '#fff';
    ctx.font = `${Math.min(20, W * 0.03)}px "Courier New", monospace`;
    ctx.fillText('PRESS ENTER TO START', W / 2, H * 0.55);
    clearGlow(ctx);
  }

  // Controls
  const ctrls = [
    [', or Arrow Up', 'Nose Up + Accelerate'],
    ['/ or Arrow Down', 'Nose Down'],
    ['X', 'Accelerate'],
    ['. or F', 'Flip Plane'],
    ['Space', 'Machine Gun'],
    ['B', 'Drop Bomb'],
    ['H', 'Autopilot Home'],
  ];
  ctx.fillStyle = '#557';
  ctx.font = `${Math.min(12, W * 0.018)}px "Courier New", monospace`;
  const startY = H * 0.65;
  ctx.textAlign = 'center';
  ctx.fillText('─── CONTROLS ───', W / 2, startY - 15);
  ctx.textAlign = 'left';
  for (let i = 0; i < ctrls.length; i++) {
    const cx = W / 2 - 160;
    const cy = startY + i * 22;
    ctx.fillStyle = '#0af';
    ctx.fillText(ctrls[i][0].padEnd(16), cx, cy);
    ctx.fillStyle = '#667';
    ctx.fillText(ctrls[i][1], cx + 170, cy);
  }

  // Footer
  ctx.textAlign = 'center';
  ctx.fillStyle = '#334';
  ctx.font = `${Math.min(11, W * 0.015)}px "Courier New", monospace`;
  ctx.fillText('Inspired by Sopwith (1984) by BMB Compuscience', W / 2, H * 0.95);
}

function drawRadar() {
  const rW = radarCanvas.width;
  const rH = radarCanvas.height;
  rctx.fillStyle = '#08080c';
  rctx.fillRect(0, 0, rW, rH);

  const scale = rW / WORLD_W;

  // Terrain silhouette
  rctx.strokeStyle = '#0a3';
  rctx.lineWidth = 1;
  rctx.beginPath();
  for (let x = 0; x < WORLD_W; x += 20) {
    const rx = x * scale;
    const ry = rH - (rH * 0.6 - terrain[x] * scale * 0.5);
    if (x === 0) rctx.moveTo(rx, Math.min(rH, ry));
    else rctx.lineTo(rx, Math.min(rH, ry));
  }
  rctx.stroke();

  // Base
  rctx.fillStyle = '#0af';
  rctx.fillRect(baseX * scale - 1, 2, Math.max(3, BASE_WIDTH * scale), 4);

  // Buildings
  for (const bld of buildings) {
    if (!bld.alive) continue;
    rctx.fillStyle = bld.type === 'flak' ? '#f80' : '#f44';
    rctx.fillRect(bld.x * scale, rH * 0.4, Math.max(2, bld.w * scale), 3);
  }

  // Enemies
  for (const en of enemies) {
    if (!en.alive) continue;
    rctx.fillStyle = '#f0a';
    rctx.fillRect(en.x * scale - 1, en.y * scale * 0.05 + 5, 3, 3);
  }

  // Player
  if (state === ST.PLAYING || state === ST.LEVEL_COMPLETE) {
    rctx.fillStyle = '#0ff';
    rctx.fillRect(player.x * scale - 2, player.y * scale * 0.05 + 5, 5, 4);
  }

  // Viewport indicator
  rctx.strokeStyle = '#225';
  rctx.lineWidth = 1;
  const viewL = camX * scale;
  const viewW = canvas.width * scale;
  rctx.strokeRect(viewL, 0, viewW, rH);
}

function drawRadarEmpty() {
  const rW = radarCanvas.width;
  const rH = radarCanvas.height;
  rctx.fillStyle = '#08080c';
  rctx.fillRect(0, 0, rW, rH);
  rctx.fillStyle = '#1a1a2a';
  rctx.font = '10px "Courier New", monospace';
  rctx.textAlign = 'center';
  rctx.fillText('RADAR', rW / 2, rH / 2 + 3);
}

// ── Game loop ──
function gameLoop(timestamp) {
  if (!lastTime) lastTime = timestamp;
  let dt = (timestamp - lastTime) / 1000;
  lastTime = timestamp;
  if (dt > 0.05) dt = 0.05; // cap delta

  handleInput();
  update(dt);
  draw();
  requestAnimationFrame(gameLoop);
}

function handleInput() {
  if (keys['Enter']) {
    keys['Enter'] = false;
    if (state === ST.TITLE || state === ST.GAME_OVER) {
      initAudio();
      level = 1;
      score = 0;
      lives = 5;
      initLevel();
      state = ST.PLAYING;
      // Hide touch start button, show controls
      if (touchStartBtn) touchStartBtn.style.display = 'none';
    }
  }

  // Show touch start on title/game over screens
  if (isTouchDevice && touchStartBtn) {
    if (state === ST.TITLE || state === ST.GAME_OVER) {
      touchStartBtn.style.display = 'block';
      touchStartBtn.textContent = state === ST.TITLE ? 'TAP TO START' : 'TAP TO RETRY';
    }
  }
}

// ── Engine sound update ──
function updateEngineSound() {
  if (!engineGain || !audioCtx) return;
  if (state === ST.PLAYING && player && !player.landed) {
    const speed = player.speed * PIXELS_PER_UNIT;
    engineOsc.frequency.value = 60 + speed * 0.3 + player.accel * 10;
    engineGain.gain.value = 0.02 + (player.accel / PLANE_MAX_ACCEL) * 0.03;
  } else {
    engineGain.gain.value = 0;
  }
}
setInterval(updateEngineSound, 50);

// ── Start ──
particles = [];
generateTerrain();
requestAnimationFrame(gameLoop);

})();
</script>
</body>
</html>

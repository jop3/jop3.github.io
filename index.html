<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Neon Sopwith</title>
<style>
*,*::before,*::after{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#0a0a0f;font-family:'Courier New',monospace}
#wrap{position:relative;width:100%;height:100%;display:flex;flex-direction:column}
#radar{height:40px;background:#08080c;border-bottom:1px solid #1a1a2a;position:relative;overflow:hidden}
#game{flex:1;position:relative;image-rendering:auto}
#game canvas{width:100%;height:100%;display:block}
/* scanlines */
#game::after{content:'';position:absolute;inset:0;background:repeating-linear-gradient(0deg,transparent,transparent 2px,rgba(0,0,0,0.08) 2px,rgba(0,0,0,0.08) 4px);pointer-events:none;z-index:2}
/* CRT vignette */
#game::before{content:'';position:absolute;inset:0;background:radial-gradient(ellipse at center,transparent 60%,rgba(0,0,0,0.5) 100%);pointer-events:none;z-index:3}
#hud{height:36px;background:#08080c;border-top:1px solid #1a1a2a;display:flex;align-items:center;justify-content:center;gap:2rem;font-size:13px;color:#8af;padding:0 1rem;flex-shrink:0}
.hud-item{display:flex;align-items:center;gap:0.4rem;white-space:nowrap}
.hud-label{color:#557;font-size:11px;text-transform:uppercase;letter-spacing:1px}
.hud-val{color:#0ff;font-weight:bold;text-shadow:0 0 6px #0ff}
.hud-val.red{color:#f55;text-shadow:0 0 6px #f55}
.hud-val.green{color:#0fa;text-shadow:0 0 6px #0fa}
.fuel-bar{width:80px;height:8px;background:#112;border:1px solid #335;border-radius:2px;overflow:hidden;display:inline-block;vertical-align:middle;position:relative}
.fuel-fill{display:block;height:100%;background:linear-gradient(90deg,#0f0,#0ff);transition:width 0.2s}
.fuel-bar.warning .fuel-fill{animation:bar-flash 0.5s ease-in-out infinite;background:linear-gradient(90deg,#f22,#f55)}
.fuel-pct{font-size:9px;color:#8af;margin-left:4px;min-width:28px;display:inline-block;vertical-align:middle}
.ammo-bar{width:70px;height:8px;background:#112;border:1px solid #335;border-radius:2px;overflow:hidden;display:inline-block;vertical-align:middle;position:relative}
.ammo-fill{display:block;height:100%;background:linear-gradient(90deg,#ff0,#fa0);transition:width 0.2s}
.ammo-bar.warning .ammo-fill{animation:bar-flash 0.5s ease-in-out infinite;background:linear-gradient(90deg,#f22,#f55)}
.ammo-pct{font-size:9px;color:#8af;margin-left:4px;min-width:28px;display:inline-block;vertical-align:middle}
@keyframes bar-flash{0%,100%{box-shadow:0 0 6px #f00 inset}50%{box-shadow:0 0 12px #f55 inset}}
/* ‚îÄ‚îÄ Touch controls ‚îÄ‚îÄ */
#touch-zone{display:none;position:absolute;inset:0;z-index:5;touch-action:none}
#touch-actions{display:none;position:absolute;right:8px;bottom:50px;z-index:10;pointer-events:none;flex-direction:column;gap:8px}
.touch-btn{pointer-events:auto;width:52px;height:52px;border-radius:50%;border:2px solid rgba(0,255,255,0.35);background:rgba(0,20,40,0.45);color:#0ff;font:bold 12px 'Courier New',monospace;display:flex;align-items:center;justify-content:center;user-select:none;-webkit-user-select:none;touch-action:none;text-shadow:0 0 6px #0ff}
.touch-btn:active,.touch-btn.held{background:rgba(0,255,255,0.25);border-color:#0ff}
.touch-btn.fire{border-color:rgba(255,100,100,0.4);color:#f66;text-shadow:0 0 6px #f66;width:58px;height:58px}
.touch-btn.fire:active,.touch-btn.fire.held{background:rgba(255,50,50,0.25);border-color:#f66}
.touch-btn.bomb{border-color:rgba(255,160,0,0.4);color:#fa0;text-shadow:0 0 6px #fa0}
.touch-btn.bomb:active,.touch-btn.bomb.held{background:rgba(255,160,0,0.25);border-color:#fa0}
#touch-start{display:none;position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);z-index:20;pointer-events:auto;padding:18px 36px;border-radius:12px;border:2px solid #0ff;background:rgba(0,20,40,0.8);color:#0ff;font:bold 20px 'Courier New',monospace;text-shadow:0 0 10px #0ff;touch-action:none;user-select:none;-webkit-user-select:none}
#touch-pitch-indicator{display:none;position:absolute;left:12px;top:50%;transform:translateY(-50%);width:4px;height:80px;background:rgba(0,255,255,0.15);border-radius:2px;z-index:10;pointer-events:none}
#touch-pitch-dot{position:absolute;left:-4px;width:12px;height:12px;border-radius:50%;background:#0ff;box-shadow:0 0 8px #0ff;top:50%;transform:translateY(-50%);transition:top 0.05s}
@media (hover:none) and (pointer:coarse){
  #touch-zone{display:block !important}
  #touch-actions{display:flex !important}
  #touch-start.visible{display:block !important}
  #touch-start:not(.visible){display:none !important}
  #touch-pitch-indicator{display:block !important}
  #radar{height:60px}
}
</style>
</head>
<body>
<div id="wrap">
  <canvas id="radar"></canvas>
  <div id="game">
    <canvas id="c"></canvas>
    <!-- Touch: full-screen gesture zone (hold=throttle, drag=pitch) -->
    <div id="touch-zone"></div>
    <!-- Touch: start/retry button -->
    <div id="touch-start" class="visible">TAP TO START</div>
    <!-- Touch: pitch indicator -->
    <div id="touch-pitch-indicator"><div id="touch-pitch-dot"></div></div>
    <!-- Touch: action buttons (right side) -->
    <div id="touch-actions">
      <div class="touch-btn fire" data-key="Space">FIRE</div>
      <div class="touch-btn bomb" data-key="KeyB">BOMB</div>
      <div class="touch-btn" data-key="KeyH">HOME</div>
    </div>
  </div>
  <div id="hud">
    <div class="hud-item"><span class="hud-label">HP</span><span id="h-hp" class="hud-val green">‚ñ†‚ñ†‚ñ†</span></div>
    <div class="hud-item"><span class="hud-label">Lives</span><span id="h-lives" class="hud-val">‚óè‚óè‚óè‚óè‚óè</span></div>
    <div class="hud-item"><span class="hud-label">Fuel</span><span id="fuel-bar-wrap" class="fuel-bar"><span id="h-fuel" class="fuel-fill" style="width:100%"></span></span><span id="h-fuel-pct" class="fuel-pct">100%</span></div>
    <div class="hud-item"><span class="hud-label">Bombs</span><span id="h-bombs" class="hud-val">5</span></div>
    <div class="hud-item" id="h-dc-wrap" style="display:none"><span class="hud-label">DC</span><span id="h-dc" class="hud-val">3</span></div>
    <div class="hud-item"><span class="hud-label">Ammo</span><span id="ammo-bar-wrap" class="ammo-bar"><span id="h-ammo" class="ammo-fill" style="width:100%"></span></span><span id="h-ammo-pct" class="ammo-pct">100%</span></div>
    <div class="hud-item"><span class="hud-label">Score</span><span id="h-score" class="hud-val green">0</span></div>
    <div class="hud-item"><span class="hud-label">Level</span><span id="h-level" class="hud-val">1</span></div>
  </div>
</div>

<script>
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  NEON SOPWITH ‚Äî A Sopwith-inspired neon retro biplane game
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
(() => {
'use strict';
const GAME_VERSION = '70c9d85'; // git short hash ‚Äî updated each commit

// ‚îÄ‚îÄ Canvas setup ‚îÄ‚îÄ
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const radarCanvas = document.getElementById('radar');
const rctx = radarCanvas.getContext('2d');

function resize() {
  const gd = document.getElementById('game');
  canvas.width = gd.clientWidth;
  canvas.height = gd.clientHeight;
  radarCanvas.width = radarCanvas.parentElement ? radarCanvas.clientWidth || window.innerWidth : window.innerWidth;
  radarCanvas.height = radarCanvas.clientHeight || 40;
}
resize();
window.addEventListener('resize', resize);

// ‚îÄ‚îÄ Constants ‚îÄ‚îÄ
const WORLD_W = 12000;
const BULLET_SPEED = 600;
const BOMB_VXFRAC = 0.8;
const MAX_FUEL = 2500;
const MAX_AMMO = 200;
const MAX_BOMBS = 5;
const MAX_DEPTH_CHARGES = 3;
const FLAK_INTERVAL = 90;
const FLAK_SPEED = 300;
const ENEMY_SPEED = 200;
const ENEMY_FIRE_INTERVAL = 60;
const BASE_WIDTH = 120;

// ‚îÄ‚îÄ Enemy type constants ‚îÄ‚îÄ
const JET_SPEED = 340;
const JET_FIRE_INTERVAL = 35;
const BOMBER_SPEED = 140;
const BOMBER_BOMB_INTERVAL = 120;
const ZEPPELIN_SPEED = 60;
const ZEPPELIN_BOMB_INTERVAL = 80;

const ENEMY_SPECS = {
  biplane: { hp: 2, speed: 200, fireInterval: ENEMY_FIRE_INTERVAL, score: 300, color: '#f0a', hitW: 20, hitH: 12 },
  jet:     { hp: 2, speed: JET_SPEED, fireInterval: JET_FIRE_INTERVAL, score: 500, color: '#f55', hitW: 20, hitH: 12 },
  bomber:  { hp: 5, speed: BOMBER_SPEED, fireInterval: BOMBER_BOMB_INTERVAL, score: 700, color: '#fa0', hitW: 30, hitH: 15 },
  zeppelin:{ hp: 8, speed: ZEPPELIN_SPEED, fireInterval: ZEPPELIN_BOMB_INTERVAL, score: 1500, color: '#aaf', hitW: 50, hitH: 20 },
  ace:     { hp: 3, speed: 280, fireInterval: 30, score: 800, color: '#f0f', hitW: 20, hitH: 12 }
};

// ‚îÄ‚îÄ Building score/spec lookup ‚îÄ‚îÄ
const buildingScores = { flak: 200, factory: 300, hangar: 100, dam: 500, radar_station: 250, fuel_depot: 200, bunker: 150, heavyBunker: 400, observation_tower: 300 };
const buildingColors = { flak: '#f80', factory: '#f44', hangar: '#fa0', dam: '#48f', radar_station: '#af0', fuel_depot: '#f80', bunker: '#888', heavyBunker: '#a86', observation_tower: '#af0' };

// ‚îÄ‚îÄ Enemy accuracy debuff (from radar station destruction) ‚îÄ‚îÄ
let enemyAccuracyDebuff = 0;

// ‚îÄ‚îÄ Level theme system ‚îÄ‚îÄ
const THEME_ORDER = ['land', 'sea', 'cloud', 'cave', 'normandy', 'forest'];
const THEME_CONFIG = {
  land:     { bg: '#0d1a0d', terrainColor: '#0fa', glow: '#0f8', hasWater: false, hasCeiling: false, hasCanopy: false },
  sea:      { bg: '#0a1a2a', terrainColor: '#0af', glow: '#0af', hasWater: true,  hasCeiling: false, hasCanopy: false },
  cloud:    { bg: '#1a2a3a', terrainColor: '#aaf', glow: '#88f', hasWater: false, hasCeiling: false, hasCanopy: false },
  cave:     { bg: '#1a0d00', terrainColor: '#f80', glow: '#fa0', hasWater: false, hasCeiling: true,  hasCanopy: false },
  normandy: { bg: '#1a1a0d', terrainColor: '#aa8', glow: '#cc9', hasWater: 'partial', hasCeiling: false, hasCanopy: false },
  forest:   { bg: '#0d1f0d', terrainColor: '#0a0', glow: '#0f0', hasWater: false, hasCeiling: false, hasCanopy: true }
};
function getLevelTheme(lvl) { return THEME_ORDER[(lvl - 1) % 6]; }
function getThemeConfig(lvl) { return THEME_CONFIG[getLevelTheme(lvl || level)]; }

// ‚îÄ‚îÄ Submarine data ‚îÄ‚îÄ
let submarines = [];

// ‚îÄ‚îÄ Speedboat data ‚îÄ‚îÄ
let speedboats = [];

// ‚îÄ‚îÄ New theme data ‚îÄ‚îÄ
let ceilingTerrain = null; // Float32Array for cave ceiling
let canopyHeight = null;   // Float32Array for forest tree canopy
let fuelTankers = [];
let bats = [];
let caveTurrets = [];
let tanks = [];
let barrageBalloons = [];
let aaGuns = [];
let trains = [];

// ‚îÄ‚îÄ Sopwith-style flight model ‚îÄ‚îÄ
// 16 discrete angles (like original), speed scalar, gravity table
const NUM_ANGLES = 16;
const ANGLE_STEP = (Math.PI * 2) / NUM_ANGLES;
// Gravity effect per angle index (tuned from original Sopwith)
// Nose up = negative (slows you), nose down = positive (speeds you up)
// Reduced climb penalties so plane can maintain speed in moderate climbs
const GRAVITY_TABLE = [0, 0, -1, -1, -2, -1, -1, 0, 0, 1, 1, 2, 3, 2, 1, 1];
// Sine table (scaled to 1.0 instead of 256 as original)
const SIN_TABLE = [0, 0.383, 0.707, 0.924, 1.0, 0.924, 0.707, 0.383, 0, -0.383, -0.707, -0.924, -1.0, -0.924, -0.707, -0.383];
const COS_TABLE = SIN_TABLE.map((_, i) => SIN_TABLE[(i + 4) % 16]);

const PLANE_MIN_SPEED = 4;    // Minimum speed (like original)
const PLANE_MAX_SPEED = 9;    // Maximum speed
const PLANE_MAX_ACCEL = 5;    // Maximum throttle acceleration
const PIXELS_PER_UNIT = 28;   // Scale factor: Sopwith speed units ‚Üí pixel velocity
const STALL_SPEED = 2;        // Below this speed, plane stalls
const PLAYER_MAX_HP = 3;      // Hits before plane goes down
const TURN_RATE = 1;          // Angle steps per input (1 = one notch per press)
const PROJ_GRAVITY = 300;     // Gravity for projectiles (pixels/s¬≤)

// ‚îÄ‚îÄ Game State ‚îÄ‚îÄ
const ST = { TITLE: 0, PLAYING: 1, DYING: 2, GAME_OVER: 3, LEVEL_COMPLETE: 4 };
let state = ST.TITLE;
let level = 1;
let highestLevel = 1; // highest level reached (for continue)
let score = 0;
let lives = 5;
let deathTimer = 0;
let levelTimer = 0;
let extraLifeMsg = 0;  // timer for "+1 LIFE" message
let lastChanceMsg = 0; // timer for "LAST CHANCE" message
let titlePlaneX = -200;

// ‚îÄ‚îÄ Medal & stats system ‚îÄ‚îÄ
const MEDALS = {
  purple_heart:  { name: 'PURPLE HEART',  desc: 'Survived a wound',         icon: 'üíú', color: '#c0f' },
  ace:           { name: 'ACE',            desc: '5 kills in one flight',    icon: '‚òÖ',  color: '#ff0' },
  top_ace:       { name: 'TOP ACE',        desc: '15 kills in one flight',   icon: '‚òÖ‚òÖ', color: '#fa0' },
  valour:        { name: 'VALOUR CROSS',   desc: 'Score 500+ valour pts',    icon: '‚Ä†',  color: '#f55' },
  perfect:       { name: 'PERFECT FLIGHT', desc: 'Complete level undamaged', icon: '‚óÜ',  color: '#0ff' },
  deep_strike:   { name: 'DEEP STRIKE',    desc: 'Destroy target 4000+ from base', icon: '‚ñ∏', color: '#0f0' }
};
let flightStats = { kills: 0, damageTaken: 0, valour: 0 };
let earnedMedals = new Set(); // medals earned this game
let allTimeMedals = new Set(); // persisted across games (in memory)
let medalPopup = null; // { medal, timer }

function awardMedal(key) {
  if (earnedMedals.has(key)) return;
  earnedMedals.add(key);
  allTimeMedals.add(key);
  medalPopup = { medal: key, timer: 3 };
}

function addValourScore(baseScore, targetX) {
  const dist = Math.abs(targetX - baseX - BASE_WIDTH / 2);
  if (dist > 500) {
    const valourPts = Math.floor((dist - 500) / 350 * (player.fuel / MAX_FUEL) * 100);
    const wounded = player.wounded ? 3 : 1;
    const total = valourPts * wounded;
    flightStats.valour += total;
    score += total;
    if (dist > 4000) awardMedal('deep_strike');
  }
  flightStats.kills++;
}

// ‚îÄ‚îÄ Input ‚îÄ‚îÄ
const keys = {};
window.addEventListener('keydown', e => { keys[e.code] = true; if(['Space','ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.code)) e.preventDefault(); });
window.addEventListener('keyup', e => { keys[e.code] = false; });

// ‚îÄ‚îÄ Touch controls ‚îÄ‚îÄ
// Hold anywhere = throttle (KeyX + ArrowUp), drag up/down = pitch
// Right-side buttons for fire, bomb, flip, home
const isTouchDevice = ('ontouchstart' in window) || navigator.maxTouchPoints > 0;
const touchStartBtn = document.getElementById('touch-start');
const touchZone = document.getElementById('touch-zone');
const pitchDot = document.getElementById('touch-pitch-dot');
let touchThrottleId = null;  // track the main gesture touch
let touchStartY = 0;         // Y where the touch began
let touchCurrentY = 0;
const PITCH_DEADZONE = 12;   // pixels before pitch kicks in
const PITCH_RANGE = 60;      // pixels for full up/down

// Start/retry button
if (touchStartBtn) {
  touchStartBtn.addEventListener('touchstart', (e) => {
    e.preventDefault();
    keys['Enter'] = true;
    setTimeout(() => { keys['Enter'] = false; }, 100);
    touchStartBtn.classList.remove('visible');
    initAudio();
  });
}

// Main touch zone ‚Äî hold for throttle, drag for pitch
if (touchZone) {
  touchZone.addEventListener('touchstart', (e) => {
    e.preventDefault();
    initAudio();
    if (touchThrottleId !== null) return; // already tracking
    const t = e.changedTouches[0];
    touchThrottleId = t.identifier;
    touchStartY = t.clientY;
    touchCurrentY = t.clientY;
    // Throttle on (KeyX only ‚Äî ArrowUp would also pitch up)
    keys['KeyX'] = true;
  });

  touchZone.addEventListener('touchmove', (e) => {
    e.preventDefault();
    for (const t of e.changedTouches) {
      if (t.identifier === touchThrottleId) {
        touchCurrentY = t.clientY;
        const dy = touchStartY - touchCurrentY; // positive = dragged up

        // Clear previous pitch keys
        keys['Comma'] = false;
        keys['Slash'] = false;

        if (dy > PITCH_DEADZONE) {
          // Dragged up ‚Üí nose up
          keys['Comma'] = true;
        } else if (dy < -PITCH_DEADZONE) {
          // Dragged down ‚Üí nose down
          keys['Slash'] = true;
        }

        // Update pitch indicator dot
        if (pitchDot) {
          const norm = Math.max(-1, Math.min(1, dy / PITCH_RANGE));
          pitchDot.style.top = (50 - norm * 40) + '%';
        }
      }
    }
  });

  const endTouch = (e) => {
    for (const t of e.changedTouches) {
      if (t.identifier === touchThrottleId) {
        touchThrottleId = null;
        keys['KeyX'] = false;
        keys['Comma'] = false;
        keys['Slash'] = false;
        if (pitchDot) pitchDot.style.top = '50%';
      }
    }
  };
  touchZone.addEventListener('touchend', endTouch);
  touchZone.addEventListener('touchcancel', endTouch);
}

// Action buttons (fire, bomb, flip, home)
document.querySelectorAll('.touch-btn').forEach(btn => {
  const keyCode = btn.dataset.key;
  if (!keyCode) return;
  btn.addEventListener('touchstart', (e) => {
    e.preventDefault();
    e.stopPropagation();
    keys[keyCode] = true;
    btn.classList.add('held');
    initAudio();
  });
  btn.addEventListener('touchend', (e) => {
    e.preventDefault();
    keys[keyCode] = false;
    btn.classList.remove('held');
  });
  btn.addEventListener('touchcancel', (e) => {
    keys[keyCode] = false;
    btn.classList.remove('held');
  });
});

// ‚îÄ‚îÄ Audio (Web Audio synth) ‚îÄ‚îÄ
let audioCtx = null;
let engineOsc = null;
let engineGain = null;
let audioStarted = false;

function initAudio() {
  if (audioStarted) return;
  audioStarted = true;
  try {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    engineOsc = audioCtx.createOscillator();
    engineGain = audioCtx.createGain();
    engineOsc.type = 'sawtooth';
    engineOsc.frequency.value = 80;
    engineGain.gain.value = 0;
    engineOsc.connect(engineGain);
    engineGain.connect(audioCtx.destination);
    engineOsc.start();
  } catch(e) {}
}

function playShoot() {
  if (!audioCtx) return;
  try {
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = 'square';
    o.frequency.value = 800;
    g.gain.value = 0.08;
    o.connect(g); g.connect(audioCtx.destination);
    o.start();
    o.frequency.exponentialRampToValueAtTime(200, audioCtx.currentTime + 0.05);
    g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.08);
    o.stop(audioCtx.currentTime + 0.08);
  } catch(e) {}
}

function playBoom(big) {
  if (!audioCtx) return;
  try {
    const dur = big ? 0.5 : 0.2;
    const buf = audioCtx.createBuffer(1, audioCtx.sampleRate * dur, audioCtx.sampleRate);
    const data = buf.getChannelData(0);
    for (let i = 0; i < data.length; i++) {
      data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / data.length, big ? 1.5 : 3);
    }
    const src = audioCtx.createBufferSource();
    const g = audioCtx.createGain();
    src.buffer = buf;
    g.gain.value = big ? 0.3 : 0.15;
    src.connect(g); g.connect(audioCtx.destination);
    src.start();
  } catch(e) {}
}

function playBombDrop() {
  if (!audioCtx) return;
  try {
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = 'sine';
    o.frequency.value = 400;
    g.gain.value = 0.07;
    o.connect(g); g.connect(audioCtx.destination);
    o.start();
    o.frequency.exponentialRampToValueAtTime(80, audioCtx.currentTime + 0.6);
    g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.6);
    o.stop(audioCtx.currentTime + 0.6);
  } catch(e) {}
}

function playFlood() {
  if (!audioCtx) return;
  try {
    const dur = 0.8;
    const buf = audioCtx.createBuffer(1, audioCtx.sampleRate * dur, audioCtx.sampleRate);
    const data = buf.getChannelData(0);
    for (let i = 0; i < data.length; i++) {
      const t = i / audioCtx.sampleRate;
      data[i] = (Math.random() * 2 - 1) * Math.pow(1 - t / dur, 0.8) * Math.sin(t * 30);
    }
    const src = audioCtx.createBufferSource();
    const g = audioCtx.createGain();
    src.buffer = buf;
    g.gain.value = 0.25;
    src.connect(g); g.connect(audioCtx.destination);
    src.start();
  } catch(e) {}
}

// ‚îÄ‚îÄ Stars (background) ‚îÄ‚îÄ
const stars = [];
for (let i = 0; i < 200; i++) {
  stars.push({ x: Math.random() * WORLD_W, y: Math.random() * 500, b: Math.random() * 0.5 + 0.2, s: Math.random() * 1.5 + 0.5 });
}

// ‚îÄ‚îÄ Terrain generation ‚îÄ‚îÄ
let terrain = [];
let baseX = 0;

// ‚îÄ‚îÄ Sea level: water line Y and island peak positions ‚îÄ‚îÄ
let waterLineY = 0;
let islandPeaks = [];

function generateTerrain() {
  terrain = new Float32Array(WORLD_W);
  ceilingTerrain = null;
  canopyHeight = null;
  const groundBase = canvas.height * 0.75;
  baseX = Math.floor(WORLD_W / 2 - BASE_WIDTH / 2);
  const theme = getLevelTheme(level);

  if (theme === 'sea') generateSeaTerrain(groundBase);
  else if (theme === 'cloud') generateCloudTerrain(groundBase);
  else if (theme === 'cave') generateCaveTerrain(groundBase);
  else if (theme === 'normandy') generateNormandyTerrain(groundBase);
  else if (theme === 'forest') generateForestTerrain(groundBase);
  else generateLandTerrain(groundBase);
}

function generateLandTerrain(groundBase) {
  // Multi-octave noise for hilly terrain
  for (let x = 0; x < WORLD_W; x++) {
    let h = 0;
    h += Math.sin(x * 0.002) * 60;
    h += Math.sin(x * 0.005 + 1.3) * 30;
    h += Math.sin(x * 0.01 + 2.7) * 15;
    h += Math.sin(x * 0.025 + 0.5) * 8;
    terrain[x] = groundBase + h;
  }
  const flatY = groundBase;
  // Flatten a wide area around base
  const flatStart = baseX - 150;
  const flatEnd = baseX + BASE_WIDTH + 400;
  for (let x = Math.max(0, flatStart - 80); x < Math.min(WORLD_W, flatEnd + 80); x++) {
    if (x >= flatStart && x <= flatEnd) {
      terrain[x] = flatY;
    } else if (x < flatStart) {
      const t = (flatStart - x) / 80;
      terrain[x] = flatY * (1 - t) + terrain[x] * t;
    } else {
      const t = (x - flatEnd) / 80;
      terrain[x] = flatY * (1 - t) + terrain[x] * t;
    }
  }
  waterLineY = 0;
  islandPeaks = [];

  // Barrier mountains at world edges
  addBarrierMountains(groundBase);
}

function generateSeaTerrain(groundBase) {
  // Ocean: base terrain is low and flat (water surface)
  waterLineY = groundBase + 30; // water surface is lower than land ground
  islandPeaks = [];

  // Start with flat ocean floor
  for (let x = 0; x < WORLD_W; x++) {
    terrain[x] = waterLineY;
  }

  // Generate 8-12 islands as terrain peaks rising above water
  const numIslands = 8 + Math.floor(Math.random() * 5);
  const islandSpacing = WORLD_W / (numIslands + 2);
  for (let i = 0; i < numIslands; i++) {
    // Spread islands across the world, avoiding center (carrier area)
    let islandCenter, attempts = 0;
    do {
      islandCenter = Math.floor(islandSpacing * (i + 1) + (Math.random() - 0.5) * islandSpacing * 0.6);
      attempts++;
    } while (attempts < 20 && Math.abs(islandCenter - baseX - BASE_WIDTH / 2) < 800);
    if (Math.abs(islandCenter - baseX - BASE_WIDTH / 2) < 800) continue;

    const islandWidth = 200 + Math.floor(Math.random() * 300);
    const islandHeight = 50 + Math.random() * 60; // how much above water

    islandPeaks.push({ cx: islandCenter, w: islandWidth, h: islandHeight });

    for (let dx = -islandWidth / 2; dx <= islandWidth / 2; dx++) {
      const ix = Math.floor(((islandCenter + dx) % WORLD_W + WORLD_W) % WORLD_W);
      // Bell-curve shape for island
      const factor = Math.cos((dx / (islandWidth / 2)) * Math.PI * 0.5);
      const noiseOffset = Math.sin(ix * 0.02) * 8 + Math.sin(ix * 0.05 + 1.7) * 4;
      terrain[ix] = waterLineY - islandHeight * factor * factor + noiseOffset;
    }
  }

  // Carrier flat area at world center
  const carrierFlatStart = baseX - 80;
  const carrierFlatEnd = baseX + BASE_WIDTH + 80;
  const carrierDeckY = waterLineY - 18; // deck sits above water
  for (let x = Math.max(0, carrierFlatStart - 40); x < Math.min(WORLD_W, carrierFlatEnd + 40); x++) {
    if (x >= carrierFlatStart && x <= carrierFlatEnd) {
      terrain[x] = carrierDeckY;
    } else if (x < carrierFlatStart) {
      const t = (carrierFlatStart - x) / 40;
      terrain[x] = carrierDeckY * (1 - t) + waterLineY * t;
    } else {
      const t = (x - carrierFlatEnd) / 40;
      terrain[x] = carrierDeckY * (1 - t) + waterLineY * t;
    }
  }

  // Barrier mountains at world edges
  addBarrierMountains(waterLineY - 60);
}

function addBarrierMountains(groundBase) {
  // Left barrier: tall mountain from x=0 to x=150
  const barrierHeight = 350; // very tall ‚Äî reaches above screen
  const barrierWidth = 150;
  for (let x = 0; x < barrierWidth; x++) {
    const factor = Math.cos((x / barrierWidth) * Math.PI * 0.5);
    terrain[x] = Math.min(terrain[x], groundBase - barrierHeight * factor * factor);
  }
  // Right barrier: tall mountain from x=WORLD_W-150 to WORLD_W
  for (let x = WORLD_W - barrierWidth; x < WORLD_W; x++) {
    const dx = WORLD_W - x;
    const factor = Math.cos((dx / barrierWidth) * Math.PI * 0.5);
    terrain[x] = Math.min(terrain[x], groundBase - barrierHeight * factor * factor);
  }
}

// ‚îÄ‚îÄ Cloud terrain ‚îÄ‚îÄ
function generateCloudTerrain(groundBase) {
  const cloudBase = canvas.height * 0.78;
  // Mostly flat cloud layer with mountain peaks poking through
  for (let x = 0; x < WORLD_W; x++) {
    terrain[x] = cloudBase;
  }

  // Mountain peaks sticking above the cloud layer (8-12 peaks)
  const numPeaks = 8 + Math.floor(Math.random() * 5);
  const spacing = WORLD_W / (numPeaks + 2);
  islandPeaks = []; // reuse for building placement
  for (let i = 0; i < numPeaks; i++) {
    let peakX, attempts = 0;
    do {
      peakX = Math.floor(spacing * (i + 1) + (Math.random() - 0.5) * spacing * 0.5);
      attempts++;
    } while (attempts < 20 && Math.abs(peakX - baseX - BASE_WIDTH / 2) < 600);
    if (Math.abs(peakX - baseX - BASE_WIDTH / 2) < 600) continue; // skip this peak

    const peakWidth = 150 + Math.floor(Math.random() * 200);
    const peakHeight = 40 + Math.random() * 50;
    islandPeaks.push({ cx: peakX, w: peakWidth, h: peakHeight });

    for (let dx = -peakWidth / 2; dx <= peakWidth / 2; dx++) {
      const ix = Math.floor(((peakX + dx) % WORLD_W + WORLD_W) % WORLD_W);
      const factor = Math.cos((dx / (peakWidth / 2)) * Math.PI * 0.5);
      const noise = Math.sin(ix * 0.02) * 5;
      terrain[ix] = Math.min(terrain[ix], cloudBase - peakHeight * factor * factor + noise);
    }
  }

  // Flat base on mountain peak
  const basePeakHeight = 30;
  for (let dx = -200; dx <= BASE_WIDTH + 200; dx++) {
    const ix = ((baseX + dx) % WORLD_W + WORLD_W) % WORLD_W;
    const factor = Math.cos((dx / 200) * Math.PI * 0.5);
    terrain[ix] = Math.min(terrain[ix], cloudBase - basePeakHeight * factor * factor);
  }
  const flatY = cloudBase - basePeakHeight;
  for (let x = baseX - 80; x < baseX + BASE_WIDTH + 80; x++) {
    if (x >= 0 && x < WORLD_W) {
      if (x >= baseX && x <= baseX + BASE_WIDTH) terrain[x] = flatY;
      else if (x < baseX) terrain[x] = flatY * (1 - (baseX - x) / 80) + terrain[x] * ((baseX - x) / 80);
      else terrain[x] = flatY * (1 - (x - baseX - BASE_WIDTH) / 80) + terrain[x] * ((x - baseX - BASE_WIDTH) / 80);
    }
  }
  waterLineY = 0;
  addBarrierMountains(cloudBase - 60);
}

// ‚îÄ‚îÄ Cave terrain ‚îÄ‚îÄ
function generateCaveTerrain(groundBase) {
  ceilingTerrain = new Float32Array(WORLD_W);
  const caveFloor = groundBase + 20;

  // Floor ‚Äî undulating with noise
  for (let x = 0; x < WORLD_W; x++) {
    let h = 0;
    h += Math.sin(x * 0.003) * 40;
    h += Math.sin(x * 0.007 + 1.3) * 20;
    h += Math.sin(x * 0.015 + 2.7) * 10;
    terrain[x] = caveFloor + h;
  }

  // Ceiling ‚Äî inverted noise, variable gap above floor
  for (let x = 0; x < WORLD_W; x++) {
    let gap = 280; // default gap
    // Tight passages at random intervals
    gap += Math.sin(x * 0.002 + 5.1) * 80;
    gap += Math.sin(x * 0.006 + 3.3) * 40;
    // Open chambers periodically
    if (Math.sin(x * 0.001) > 0.7) gap += 100;
    gap = Math.max(110, Math.min(400, gap));
    ceilingTerrain[x] = terrain[x] - gap;
  }

  // Base ‚Äî large open chamber
  const chamberStart = baseX - 200;
  const chamberEnd = baseX + BASE_WIDTH + 200;
  const flatFloorY = caveFloor;
  for (let x = Math.max(0, chamberStart - 80); x < Math.min(WORLD_W, chamberEnd + 80); x++) {
    if (x >= chamberStart && x <= chamberEnd) {
      terrain[x] = flatFloorY;
      ceilingTerrain[x] = flatFloorY - 400;
    } else if (x < chamberStart) {
      const t = (chamberStart - x) / 80;
      terrain[x] = flatFloorY * (1 - t) + terrain[x] * t;
      ceilingTerrain[x] = (flatFloorY - 400) * (1 - t) + ceilingTerrain[x] * t;
    } else {
      const t = (x - chamberEnd) / 80;
      terrain[x] = flatFloorY * (1 - t) + terrain[x] * t;
      ceilingTerrain[x] = (flatFloorY - 400) * (1 - t) + ceilingTerrain[x] * t;
    }
  }

  waterLineY = 0;
  islandPeaks = [];
  addBarrierMountains(caveFloor);
}

function getCeilingY(x) {
  if (!ceilingTerrain) return -9999;
  const ix = Math.floor(((x % WORLD_W) + WORLD_W) % WORLD_W);
  const ix2 = (ix + 1) % WORLD_W;
  const frac = x - Math.floor(x);
  return ceilingTerrain[ix] * (1 - frac) + ceilingTerrain[ix2] * frac;
}

// ‚îÄ‚îÄ Normandy terrain ‚îÄ‚îÄ
function generateNormandyTerrain(groundBase) {
  waterLineY = groundBase + 30;
  islandPeaks = [];

  // Left third: ocean water
  for (let x = 0; x < WORLD_W; x++) {
    terrain[x] = waterLineY;
  }

  // Beach transition: from ~30% to ~50% ‚Äî sloping sand
  const beachStart = Math.floor(WORLD_W * 0.3);
  const beachEnd = Math.floor(WORLD_W * 0.5);
  for (let x = beachStart; x < beachEnd; x++) {
    const t = (x - beachStart) / (beachEnd - beachStart);
    const beachY = waterLineY - t * 60; // gradual slope up
    const noise = Math.sin(x * 0.01) * 5 + Math.sin(x * 0.03) * 3;
    terrain[x] = beachY + noise;
  }

  // Cliffs and bunker platforms: 50% to 90%
  const cliffStart = beachEnd;
  const cliffEnd = Math.floor(WORLD_W * 0.9);
  for (let x = cliffStart; x < cliffEnd; x++) {
    const t = (x - cliffStart) / (cliffEnd - cliffStart);
    let h = 0;
    h += Math.sin(x * 0.003) * 30;
    h += Math.sin(x * 0.008 + 1.3) * 15;
    h += Math.sin(x * 0.02 + 2.7) * 8;
    terrain[x] = waterLineY - 60 - t * 40 + h;
  }

  // Register cliff areas as "islands" for building placement
  const numCliffSections = 5;
  for (let i = 0; i < numCliffSections; i++) {
    const cx = cliffStart + (cliffEnd - cliffStart) * (i + 0.5) / numCliffSections;
    islandPeaks.push({ cx, w: (cliffEnd - cliffStart) / numCliffSections, h: 80 });
  }

  // Carrier base offshore (left side water)
  const carrierX = Math.floor(WORLD_W * 0.15);
  baseX = carrierX;
  const carrierFlatStart = baseX - 80;
  const carrierFlatEnd = baseX + BASE_WIDTH + 80;
  const carrierDeckY = waterLineY - 18;
  for (let x = Math.max(0, carrierFlatStart - 40); x < Math.min(WORLD_W, carrierFlatEnd + 40); x++) {
    if (x >= carrierFlatStart && x <= carrierFlatEnd) terrain[x] = carrierDeckY;
    else if (x < carrierFlatStart) {
      const t = (carrierFlatStart - x) / 40;
      terrain[x] = carrierDeckY * (1 - t) + waterLineY * t;
    } else {
      const t = (x - carrierFlatEnd) / 40;
      terrain[x] = carrierDeckY * (1 - t) + waterLineY * t;
    }
  }

  addBarrierMountains(waterLineY - 60);
}

// ‚îÄ‚îÄ Forest terrain ‚îÄ‚îÄ
function generateForestTerrain(groundBase) {
  canopyHeight = new Float32Array(WORLD_W);

  // Standard hilly terrain like land
  for (let x = 0; x < WORLD_W; x++) {
    let h = 0;
    h += Math.sin(x * 0.002) * 60;
    h += Math.sin(x * 0.005 + 1.3) * 30;
    h += Math.sin(x * 0.01 + 2.7) * 15;
    h += Math.sin(x * 0.025 + 0.5) * 8;
    terrain[x] = groundBase + h;
  }

  // Tree canopy ‚Äî variable height above ground with gaps
  for (let x = 0; x < WORLD_W; x++) {
    // Gaps every ~300-500px, and at the base
    const nearBase = Math.abs(x - baseX - BASE_WIDTH / 2) < 300;
    const gapNoise = Math.sin(x * 0.005) + Math.sin(x * 0.012 + 2.1) + Math.sin(x * 0.003 + 0.7);
    const isGap = gapNoise > 1.5 || nearBase;

    if (!isGap) {
      canopyHeight[x] = 40 + Math.sin(x * 0.008) * 15 + Math.sin(x * 0.02 + 1.5) * 10 + Math.random() * 5;
    } else {
      canopyHeight[x] = 0;
    }
  }

  // Flatten base area
  const flatY = groundBase;
  const flatStart = baseX - 150;
  const flatEnd = baseX + BASE_WIDTH + 400;
  for (let x = Math.max(0, flatStart - 80); x < Math.min(WORLD_W, flatEnd + 80); x++) {
    canopyHeight[x] = 0; // clear canopy near base
    if (x >= flatStart && x <= flatEnd) {
      terrain[x] = flatY;
    } else if (x < flatStart) {
      const t = (flatStart - x) / 80;
      terrain[x] = flatY * (1 - t) + terrain[x] * t;
    } else {
      const t = (x - flatEnd) / 80;
      terrain[x] = flatY * (1 - t) + terrain[x] * t;
    }
  }

  // Flat sections for train tracks
  const trackSections = 3;
  for (let i = 0; i < trackSections; i++) {
    const trackX = 1500 + i * 3000 + Math.floor(Math.random() * 500);
    if (Math.abs(trackX - baseX) < 500) continue;
    const trackLen = 600 + Math.floor(Math.random() * 400);
    const trackY = getTerrainY(trackX + trackLen / 2);
    for (let dx = -20; dx < trackLen + 20; dx++) {
      const tx = trackX + dx;
      if (tx >= 0 && tx < WORLD_W) {
        if (dx >= 0 && dx < trackLen) terrain[tx] = trackY;
        else if (dx < 0) terrain[tx] = trackY * (1 - (-dx) / 20) + terrain[tx] * ((-dx) / 20);
        else terrain[tx] = trackY * (1 - (dx - trackLen) / 20) + terrain[tx] * ((dx - trackLen) / 20);
        canopyHeight[tx] = 0; // clear canopy over tracks
      }
    }
  }

  waterLineY = 0;
  islandPeaks = [];
  addBarrierMountains(groundBase);
}

function getCanopyY(x) {
  if (!canopyHeight) return 9999;
  const ix = Math.floor(((x % WORLD_W) + WORLD_W) % WORLD_W);
  const ch = canopyHeight[ix];
  if (ch <= 0) return 9999;
  return terrain[ix] - ch;
}

function getTerrainY(x) {
  const ix = Math.floor(((x % WORLD_W) + WORLD_W) % WORLD_W);
  const ix2 = (ix + 1) % WORLD_W;
  const frac = x - Math.floor(x);
  return terrain[ix] * (1 - frac) + terrain[ix2] * frac;
}

// ‚îÄ‚îÄ Base territory protection: no cratering within this zone ‚îÄ‚îÄ
function isInBaseTerritory(x) {
  const margin = 80;
  if (x >= baseX - margin && x <= baseX + BASE_WIDTH + margin) return true;
  // Also protect enemy bases
  for (const eb of enemyBases) {
    if (x >= eb.x - margin && x <= eb.x + eb.width + margin) return true;
  }
  return false;
}

// ‚îÄ‚îÄ Entities ‚îÄ‚îÄ
let player, bullets, bombs, depthCharges, particles, enemies, buildings, flakShots, birds, oxen;
let fleeingPeople, dragons;
let shockwaves = []; // underwater depth charge shockwaves

function initPlayer() {
  const ty = getTerrainY(baseX + BASE_WIDTH / 2);
  player = {
    x: baseX + BASE_WIDTH / 2,
    y: ty - 30,
    // Sopwith-style: single speed scalar + angle index
    speed: 0,             // current speed (in Sopwith units)
    accel: 0,             // throttle acceleration (0 to PLANE_MAX_ACCEL)
    angleIdx: 0,          // 0=right, 4=up, 8=left, 12=down (16 steps)
    orient: false,        // upside-down (true = inverted, like ob_orient in original Sopwith)
    stalled: false,       // in stall state
    // Derived velocity (for rendering/collision)
    vx: 0, vy: 0,
    fuel: MAX_FUEL,
    ammo: MAX_AMMO,
    bombCount: MAX_BOMBS,
    depthCharges: MAX_DEPTH_CHARGES,
    fireCooldown: 0,
    bombCooldown: 0,
    depthChargeCooldown: 0,
    invincible: 0,
    landed: true,
    autopilot: false,
    hp: PLAYER_MAX_HP,
    wounded: false,        // damaged but flyable ‚Äî controls respond every other frame
    burning: false,        // on fire or engine out, diving to crash
    engineOut: false,      // true = fuel empty (no fire), false = damage fire
    burnTimer: 0,          // time until explosion
    hitFlash: 0,           // visual flash on damage
    // Input edge detection
    _turnHeld: false,
    _turnTimer: 0,
    _autoHeld: false,
    // Frame counter for speed updates (every 4 frames like original)
    moveCount: 0
  };
}

function spawnBuildings() {
  buildings = [];
  const theme = getLevelTheme(level);
  const tc = THEME_CONFIG[theme];

  // Weighted type pool based on level and theme
  const pool = [];
  const addW = (t, w) => { for (let i = 0; i < w; i++) pool.push(t); };
  if (theme === 'sea') {
    addW('bunker', 3); addW('flak', 3); addW('radar_station', 2); addW('fuel_depot', 2);
  } else if (theme === 'normandy') {
    addW('heavyBunker', 4); addW('flak', 3); addW('bunker', 3); addW('radar_station', 2);
  } else if (theme === 'cave') {
    addW('bunker', 3); addW('flak', 2); addW('fuel_depot', 2);
  } else if (theme === 'forest') {
    addW('flak', 2); addW('bunker', 2); addW('observation_tower', 3); addW('radar_station', 2); addW('fuel_depot', 2);
  } else if (theme === 'cloud') {
    addW('flak', 3); addW('bunker', 2); addW('radar_station', 2); addW('fuel_depot', 2);
  } else {
    addW('hangar', 3); addW('factory', 3); addW('flak', 3);
    if (level >= 2) { addW('bunker', 2); addW('fuel_depot', 2); }
    if (level >= 3) { addW('radar_station', 1); addW('dam', 1); }
  }

  const sizeMap = {
    hangar: [50, 30], factory: [60, 40], flak: [30, 45],
    dam: [100, 25], radar_station: [40, 50], fuel_depot: [45, 30], bunker: [35, 20],
    heavyBunker: [50, 25], observation_tower: [20, 60]
  };
  const hpMap = {
    hangar: 2, factory: 3, flak: 2, dam: 5, radar_station: 2, fuel_depot: 2, bunker: 4,
    heavyBunker: 6, observation_tower: 3
  };

  const minGap = 300;
  const totalCount = 8 + level * 3;

  function placeBuilding(bx) {
    const ty = getTerrainY(bx);
    const type = pool[Math.floor(Math.random() * pool.length)];
    const [w, h] = sizeMap[type];
    buildings.push({
      x: bx, y: ty - h, w, h, type,
      hp: hpMap[type],
      alive: true,
      flakTimer: Math.random() * FLAK_INTERVAL | 0,
      isTarget: true
    });
    // Dam: dip terrain on left side (reservoir effect)
    if (type === 'dam') {
      for (let dx = -150; dx < 0; dx++) {
        const ix = Math.floor(((bx + dx) % WORLD_W + WORLD_W) % WORLD_W);
        if (ix >= 0 && ix < WORLD_W) {
          const factor = 1 - Math.abs(dx) / 150;
          terrain[ix] += 8 * factor;
        }
      }
    }
    return w;
  }

  if (theme === 'sea' || (theme === 'normandy' && islandPeaks.length > 0)) {
    // Sea/normandy levels: place buildings on islands or elevated terrain
    let placed = 0;
    for (const island of islandPeaks) {
      if (placed >= totalCount) break;
      const islandLeft = island.cx - island.w / 2 + 40;
      const islandRight = island.cx + island.w / 2 - 40;
      const buildingsPerIsland = Math.ceil(totalCount / islandPeaks.length);
      let lastIX = islandLeft;
      for (let j = 0; j < buildingsPerIsland && placed < totalCount; j++) {
        const bx = lastIX + 60 + Math.random() * 80;
        if (bx >= islandRight) break;
        const ty = getTerrainY(bx);
        if (ty < waterLineY - 15) {
          const w = placeBuilding(bx);
          lastIX = bx + w;
          placed++;
        }
      }
    }
    // Normandy: also place bunkers on beach/cliff areas
    if (theme === 'normandy') {
      const beachStart = Math.floor(WORLD_W * 0.35);
      const beachEnd = Math.floor(WORLD_W * 0.85);
      let lastBX = beachStart;
      while (placed < totalCount && lastBX < beachEnd) {
        const bx = lastBX + minGap + Math.random() * 300;
        if (bx >= beachEnd) break;
        const ty = getTerrainY(bx);
        if (ty < waterLineY - 15) {
          const w = placeBuilding(bx);
          lastBX = bx + w;
          placed++;
        } else {
          lastBX = bx + 100;
        }
      }
    }
  } else {
    // Land levels: bidirectional placement
    const rightCount = Math.ceil(totalCount / 2);
    const leftCount = totalCount - rightCount;

    // Right set: starts right of base, goes rightward
    let lastX = baseX + BASE_WIDTH + 600;
    for (let i = 0; i < rightCount; i++) {
      const bx = lastX + minGap + Math.random() * 400;
      if (bx >= WORLD_W - 200) break;
      const w = placeBuilding(bx);
      lastX = bx + w;
    }

    // Left set: starts left of base, goes leftward
    lastX = baseX - 600;
    for (let i = 0; i < leftCount; i++) {
      const bx = lastX - minGap - Math.random() * 400;
      if (bx < 200) break;
      const w = placeBuilding(bx);
      lastX = bx - w;
    }
  }
}

// ‚îÄ‚îÄ Enemy airfields ‚îÄ‚îÄ
const ENEMY_MAX_FUEL = 600;
let enemyBases = []; // { x, width } ‚Äî enemy landing fields

function spawnEnemyBases() {
  enemyBases = [];
  const theme = getLevelTheme(level);
  const needsIsland = theme === 'sea' || theme === 'normandy';

  // Always place enemy airfields at world edges ‚Äî both land and sea levels
  const positions = [300, WORLD_W - 300 - BASE_WIDTH];
  for (const bx of positions) {
    // On water levels, ensure there's solid ground (create an island) at edge positions
    if (needsIsland) {
      const centerX = bx + BASE_WIDTH / 2;
      const islandWidth = 300;
      for (let dx = -islandWidth / 2; dx <= islandWidth / 2; dx++) {
        const ix = Math.floor(((centerX + dx) % WORLD_W + WORLD_W) % WORLD_W);
        if (ix >= 0 && ix < WORLD_W) {
          const factor = Math.cos((dx / (islandWidth / 2)) * Math.PI * 0.5);
          terrain[ix] = waterLineY - 60 * factor * factor;
        }
      }
    }
    flattenTerrainForBase(bx);
    enemyBases.push({ x: bx, width: BASE_WIDTH });
  }
}

function flattenTerrainForBase(bx) {
  const flatY = getTerrainY(bx + BASE_WIDTH / 2);
  for (let x = bx - 80; x < bx + BASE_WIDTH + 80; x++) {
    if (x >= 0 && x < WORLD_W) {
      if (x >= bx && x <= bx + BASE_WIDTH) terrain[x] = flatY;
      else if (x < bx) {
        const t = (bx - x) / 80;
        terrain[x] = flatY * (1 - t) + terrain[x] * t;
      } else {
        const t = (x - bx - BASE_WIDTH) / 80;
        terrain[x] = flatY * (1 - t) + terrain[x] * t;
      }
    }
  }
}

function drawEnemyBases() {
  for (const eb of enemyBases) {
    const by = getTerrainY(eb.x + eb.width / 2);
    const facesRight = eb.x < WORLD_W / 2;
    neonGlow(ctx, '#f55', 4);
    ctx.strokeStyle = '#f55';
    ctx.lineWidth = 2;
    // Runway
    ctx.beginPath();
    ctx.moveTo(eb.x, by);
    ctx.lineTo(eb.x + eb.width, by);
    ctx.stroke();
    // Dashes
    ctx.strokeStyle = '#a22';
    ctx.lineWidth = 1;
    ctx.setLineDash([8, 8]);
    ctx.beginPath();
    ctx.moveTo(eb.x + 10, by - 3);
    ctx.lineTo(eb.x + eb.width - 10, by - 3);
    ctx.stroke();
    ctx.setLineDash([]);
    // Hangar ‚Äî small building at the far end of the strip
    const hangarX = facesRight ? eb.x + eb.width + 8 : eb.x - 38;
    const hangarW = 30;
    const hangarH = 22;
    ctx.strokeStyle = '#a44';
    ctx.lineWidth = 1.5;
    // Hangar body
    ctx.strokeRect(hangarX, by - hangarH, hangarW, hangarH);
    // Arched roof
    ctx.beginPath();
    ctx.moveTo(hangarX, by - hangarH);
    ctx.quadraticCurveTo(hangarX + hangarW / 2, by - hangarH - 10, hangarX + hangarW, by - hangarH);
    ctx.stroke();
    // Door opening
    ctx.strokeStyle = '#822';
    ctx.lineWidth = 1;
    const doorX = facesRight ? hangarX : hangarX + hangarW - 14;
    ctx.strokeRect(doorX, by - 14, 14, 14);
    // Count planes in hangar for this base
    const hangarCount = enemies.filter(en => en.alive && en.homeBase === eb && en.state === 'hangar').length;
    if (hangarCount > 0) {
      ctx.fillStyle = '#f55';
      ctx.font = '7px "Courier New", monospace';
      ctx.textAlign = 'center';
      ctx.fillText(hangarCount + 'x', hangarX + hangarW / 2, by - hangarH - 12);
    }
    // Label
    ctx.fillStyle = '#f55';
    ctx.font = '8px "Courier New", monospace';
    ctx.textAlign = 'center';
    ctx.fillText('ENEMY', eb.x + eb.width / 2, by - 8);
    clearGlow(ctx);

    // ‚îÄ‚îÄ Refueling progress bar for grounded enemies ‚îÄ‚îÄ
    for (const en of enemies) {
      if (!en.alive || en.homeBase !== eb || en.state !== 'grounded') continue;
      if (!en.takeoffTimerMax || en.takeoffTimerMax <= 0) continue;
      const progress = 1 - (en.takeoffTimer / en.takeoffTimerMax);
      const barW = 40;
      const barH = 4;
      const barX = eb.x + eb.width / 2 - barW / 2;
      const barY = by - 20;
      // Background
      ctx.fillStyle = 'rgba(80, 0, 0, 0.6)';
      ctx.fillRect(barX, barY, barW, barH);
      // Fill ‚Äî green when almost done, yellow mid, red starting
      const col = progress > 0.7 ? '#0f0' : progress > 0.35 ? '#ff0' : '#f44';
      ctx.fillStyle = col;
      ctx.fillRect(barX, barY, barW * Math.min(progress, 1), barH);
      // Border
      ctx.strokeStyle = '#f55';
      ctx.lineWidth = 0.5;
      ctx.strokeRect(barX, barY, barW, barH);
      // Label
      ctx.fillStyle = '#f88';
      ctx.font = '6px "Courier New", monospace';
      ctx.textAlign = 'center';
      ctx.fillText('REFUEL', eb.x + eb.width / 2, barY - 2);
    }
  }
}

function spawnEnemies() {
  enemies = [];
  spawnEnemyBases();
  const count = 3 + level + Math.floor(Math.random() * 2); // minimum 4 on level 1
  let zeppelinCount = 0;
  for (let i = 0; i < count; i++) {
    // Randomized type selection ‚Äî all types can appear from level 1
    let type = 'biplane';
    const r = Math.random();
    const theme = getLevelTheme(level);
    if (theme === 'cloud' && r < 0.35) { type = 'ace'; } // Cloud: more ace pilots
    else if (r < 0.06 && zeppelinCount < 1) { type = 'zeppelin'; zeppelinCount++; }
    else if (r < 0.20) type = 'bomber';
    else if (r < 0.45) type = 'jet';

    const spec = ENEMY_SPECS[type];
    // Assign to an enemy base ‚Äî alternate between bases
    const eb = enemyBases[i % enemyBases.length];
    const facesRight = eb.x < WORLD_W / 2;

    enemies.push({
      x: eb.x + BASE_WIDTH / 2, y: getTerrainY(eb.x + BASE_WIDTH / 2) - 8,
      vx: 0, vy: 0,
      angle: facesRight ? 0 : Math.PI,
      hp: spec.hp, alive: true,
      fireTimer: Math.random() * spec.fireInterval | 0,
      type,
      speed: spec.speed,
      stalled: false,
      stallTimer: 0,
      burning: false,
      burnTimer: 0,
      patrolDir: facesRight ? 1 : -1,
      parkSlot: i,
      // Airfield state
      fuel: ENEMY_MAX_FUEL,
      landed: true,
      homeBase: eb,
      takeoffTimer: 0,
      state: 'hangar' // hangar (hidden), grounded (on strip), flying, returning
    });
  }
  // Launch first wave ‚Äî two planes per base
  launchNextFromBases();
}

// Keep 2 active planes per base ‚Äî launch from hangar as needed
function launchNextFromBases() {
  const MAX_ACTIVE_PER_BASE = 2;
  for (const eb of enemyBases) {
    const activeCount = enemies.filter(en =>
      en.alive && en.homeBase === eb && (en.state === 'grounded' || en.state === 'flying' || en.state === 'returning')
    ).length;
    // Launch planes until we have 2 active (or run out of hangar planes)
    let toLaunch = MAX_ACTIVE_PER_BASE - activeCount;
    while (toLaunch > 0) {
      const next = enemies.find(en => en.alive && en.homeBase === eb && en.state === 'hangar');
      if (!next) break;
      next.state = 'grounded';
      // Bigger aircraft need longer refueling
      if (next.type === 'zeppelin') next.takeoffTimer = 6 + Math.random() * 3;
      else if (next.type === 'bomber') next.takeoffTimer = 4 + Math.random() * 2;
      else next.takeoffTimer = 1 + Math.random() * 2;
      next.takeoffTimerMax = next.takeoffTimer; // store for progress bar
      toLaunch--;
    }
  }
}

function spawnAnimals() {
  oxen = [];
  const count = 3 + level;
  for (let i = 0; i < count; i++) {
    const ax = 800 + Math.random() * (WORLD_W - 1000);
    const ty = getTerrainY(ax);
    // Pick animal type based on level
    let type = 'ox';
    const r = Math.random();
    if (level >= 3 && r < 0.15) type = 'camel';
    else if (level >= 2 && r < 0.35) type = 'horse';
    else if (r < 0.55) type = 'sheep';

    const sizeMap = { ox: [20, 10], sheep: [15, 7], horse: [22, 12], camel: [22, 11] };
    const speedMap = { ox: [15, 10], sheep: [25, 10], horse: [40, 10], camel: [12, 6] };
    const [w, h] = sizeMap[type];
    const [spd, spdR] = speedMap[type];

    if (type === 'sheep') {
      // Cluster sheep in groups of 3-4
      const groupSize = 3 + Math.floor(Math.random() * 2);
      for (let j = 0; j < groupSize; j++) {
        const sx = ax + j * 20 + Math.random() * 10;
        const sty = getTerrainY(sx);
        oxen.push({ x: sx, y: sty - h, w, h, alive: true, dir: Math.random() < 0.5 ? 1 : -1, speed: spd + Math.random() * spdR, type });
      }
    } else if (type === 'horse') {
      // Horses run in pairs
      for (let j = 0; j < 2; j++) {
        const hx = ax + j * 30;
        const hty = getTerrainY(hx);
        oxen.push({ x: hx, y: hty - h, w, h, alive: true, dir: Math.random() < 0.5 ? 1 : -1, speed: spd + Math.random() * spdR, type });
      }
    } else {
      oxen.push({ x: ax, y: ty - h, w, h, alive: true, dir: Math.random() < 0.5 ? 1 : -1, speed: spd + Math.random() * spdR, type: type || 'ox' });
    }
  }
}

function spawnBirds() {
  birds = [];
  const count = 2 + level;
  for (let i = 0; i < count; i++) {
    const bx = Math.random() * WORLD_W;
    // Type selection: 50% sparrows, 30% geese, 20% eagles
    const r = Math.random();
    let type = 'sparrow';
    if (r > 0.80) type = 'eagle';
    else if (r > 0.50) type = 'goose';

    const flock = [];
    if (type === 'eagle') {
      // Solitary, higher altitude, wider sinusoidal
      const by = 40 + Math.random() * 120;
      flock.push({ x: bx, y: by, alive: true });
      birds.push({ flock, vx: -25 - Math.random() * 15, vy: 0, type, sinAmp: 30 + Math.random() * 20, sinFreq: 0.002 });
    } else if (type === 'goose') {
      // V-formation
      const by = 80 + Math.random() * 150;
      for (let j = 0; j < 5; j++) {
        const offX = j * 14;
        const offY = Math.abs(j - 2) * 8; // V shape
        flock.push({ x: bx + offX, y: by + offY, alive: true });
      }
      birds.push({ flock, vx: -30 - Math.random() * 20, vy: Math.sin(bx) * 3, type, sinAmp: 5, sinFreq: 0.005 });
    } else {
      // Sparrows - small, fast
      const by = 60 + Math.random() * 200;
      for (let j = 0; j < 5; j++) {
        flock.push({ x: bx + j * 12 + Math.random() * 8, y: by + Math.sin(j) * 10, alive: true });
      }
      birds.push({ flock, vx: -40 - Math.random() * 30, vy: Math.sin(bx) * 5, type, sinAmp: 4, sinFreq: 0.01 });
    }
  }
}

function initLevel() {
  generateTerrain();
  initPlayer();
  bullets = [];
  bombs = [];
  depthCharges = [];
  shockwaves = [];
  particles = [];
  flakShots = [];
  fleeingPeople = [];
  dragons = [];
  submarines = [];
  parachutes = [];
  fuelTankers = [];
  bats = [];
  caveTurrets = [];
  tanks = [];
  barrageBalloons = [];
  aaGuns = [];
  trains = [];
  enemyAccuracyDebuff = 0;
  spawnBuildings();
  spawnEnemies();

  const theme = getLevelTheme(level);
  const tc = THEME_CONFIG[theme];

  // Animals only on ground-based themes without water
  if (theme === 'land' || theme === 'forest') {
    spawnAnimals();
  } else {
    oxen = [];
  }

  // Sea creatures on water themes
  if (tc.hasWater === true) {
    spawnSubmarines();
    spawnSpeedboats();
  } else if (tc.hasWater === 'partial') {
    // Normandy has partial water ‚Äî spawn some speedboats
    spawnSpeedboats();
    submarines = [];
  } else {
    speedboats = [];
    submarines = [];
  }

  // Theme-specific spawns
  if (theme === 'cloud') {
    spawnFuelTankers();
  } else if (theme === 'cave') {
    spawnBats();
    spawnCaveTurrets();
  } else if (theme === 'normandy') {
    spawnTanks();
    spawnBarrageBalloons();
  } else if (theme === 'forest') {
    spawnAAGuns();
    spawnTrains();
  }

  spawnBirds();
  spawnDragons();
}

// ‚îÄ‚îÄ Particle system ‚îÄ‚îÄ
function addParticle(x, y, vx, vy, life, color, size) {
  particles.push({ x, y, vx, vy, life, maxLife: life, color, size: size || 2 });
}

function addExplosion(x, y, count, big) {
  for (let i = 0; i < count; i++) {
    const a = Math.random() * Math.PI * 2;
    const sp = (big ? 150 : 80) * Math.random();
    const colors = ['#ff0','#fa0','#f60','#fff','#ff8'];
    addParticle(x, y, Math.cos(a) * sp, Math.sin(a) * sp - 20, 0.4 + Math.random() * 0.4, colors[Math.floor(Math.random() * colors.length)], 2 + Math.random() * (big ? 4 : 2));
  }
}

function addEngineTrail(x, y, vx, vy) {
  addParticle(x, y, vx * 0.1 + (Math.random() - 0.5) * 20, vy * 0.1 + (Math.random() - 0.5) * 20, 0.2 + Math.random() * 0.15, Math.random() < 0.5 ? '#0af' : '#08f', 1.5);
}

// ‚îÄ‚îÄ Dragon spawning ‚îÄ‚îÄ
function spawnDragons() {
  if (level >= 2 && Math.random() < 0.6) {
    const dx = 3000 + Math.random() * (WORLD_W - 4000);
    dragons.push({
      x: dx, y: 100 + Math.random() * 100,
      vx: 60, vy: 0,
      hp: 4, alive: true,
      phase: 'circling', // circling, diving, breathing
      breathTimer: 5 + Math.random() * 5,
      wingFrame: 0,
      diveTarget: null,
      breathParticles: []
    });
  }
}

// ‚îÄ‚îÄ Fleeing people spawning ‚îÄ‚îÄ
function spawnFleeingPeople(x, groundY) {
  const count = 2 + Math.floor(Math.random() * 3);
  const colors = ['#0ff', '#f0f', '#ff0', '#0f0', '#fa0', '#f55'];
  for (let i = 0; i < count; i++) {
    fleeingPeople.push({
      x: x + (Math.random() - 0.5) * 30,
      y: groundY,
      dir: Math.random() < 0.5 ? -1 : 1,
      speed: 40 + Math.random() * 20,
      life: 4 + Math.random(),
      maxLife: 5,
      frame: Math.random() * Math.PI * 2,
      color: colors[Math.floor(Math.random() * colors.length)]
    });
  }
}

// ‚îÄ‚îÄ Building destruction special effects ‚îÄ‚îÄ
function onBuildingDestroyed(bld) {
  addValourScore(buildingScores[bld.type] || 100, bld.x);

  // Spawn fleeing people (except bunker/heavyBunker, and not on sea/normandy ‚Äî military outposts)
  const theme = getLevelTheme(level);
  if (bld.type !== 'bunker' && bld.type !== 'heavyBunker' && theme !== 'sea' && theme !== 'normandy') {
    spawnFleeingPeople(bld.x + bld.w / 2, bld.y + bld.h);
  }

  // Type-specific effects
  if (bld.type === 'dam') {
    // Flood effect: blue particles rushing rightward
    for (let i = 0; i < 40; i++) {
      addParticle(bld.x + bld.w / 2 + Math.random() * 40, bld.y + bld.h,
        80 + Math.random() * 120, -20 + Math.random() * 40,
        1.0 + Math.random() * 0.5, Math.random() < 0.5 ? '#48f' : '#0af', 3 + Math.random() * 2);
    }
    // Lower terrain downstream ~300px (skip in base territory)
    for (let dx = 0; dx < 300; dx++) {
      const worldX = bld.x + bld.w + dx;
      if (isInBaseTerritory(worldX)) continue;
      const ix = Math.floor(((worldX % WORLD_W) + WORLD_W) % WORLD_W);
      if (ix >= 0 && ix < WORLD_W) {
        const factor = 1 - dx / 300;
        terrain[ix] += (5 + Math.random() * 10) * factor;
      }
    }
    playFlood();
  } else if (bld.type === 'fuel_depot') {
    // Chain explosion: massive explosion + damage nearby buildings
    addExplosion(bld.x + bld.w / 2, bld.y + bld.h / 2, 60, true);
    for (const other of buildings) {
      if (!other.alive || other === bld) continue;
      const dist = Math.abs((other.x + other.w / 2) - (bld.x + bld.w / 2));
      if (dist < 150) {
        other.hp -= 2;
        if (other.hp <= 0) {
          other.alive = false;
          addExplosion(other.x + other.w / 2, other.y + other.h / 2, 20, true);
          score += buildingScores[other.type] || 100;
          if (other.type !== 'bunker') spawnFleeingPeople(other.x + other.w / 2, other.y + other.h);
        }
      }
    }
  } else if (bld.type === 'radar_station') {
    enemyAccuracyDebuff = 15; // 15 seconds of doubled enemy fire intervals
  }
}

// ‚îÄ‚îÄ Drawing helpers ‚îÄ‚îÄ
function neonGlow(ctx, color, blur) {
  ctx.shadowColor = color;
  ctx.shadowBlur = blur;
}
function clearGlow(ctx) {
  ctx.shadowColor = 'transparent';
  ctx.shadowBlur = 0;
}

function drawBiplane(ctx, x, y, angle, facingLeft, color, scale, upsideDown) {
  scale = scale || 1;
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(angle);
  if (facingLeft) ctx.scale(-1, 1);
  if (upsideDown) ctx.scale(1, -1);
  ctx.scale(scale, scale);

  neonGlow(ctx, color, 8);
  ctx.strokeStyle = color;
  ctx.lineWidth = 1.5;

  // ‚îÄ‚îÄ Fuselage (centered on y=0, nose right) ‚îÄ‚îÄ
  // Rounded body shape, wider at cockpit
  ctx.beginPath();
  ctx.moveTo(-20, 1);         // tail bottom
  ctx.lineTo(-8, 2);          // rear bottom
  ctx.lineTo(12, 2);          // belly
  ctx.lineTo(20, 0);          // nose tip
  ctx.lineTo(12, -3);         // nose top
  ctx.lineTo(-8, -3);         // cockpit top
  ctx.lineTo(-20, -1);        // tail top
  ctx.closePath();
  ctx.stroke();

  // ‚îÄ‚îÄ Cockpit canopy ‚îÄ‚îÄ
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(0, -3);
  ctx.quadraticCurveTo(2, -6, 6, -3);
  ctx.stroke();

  // ‚îÄ‚îÄ Top wing (above fuselage) ‚îÄ‚îÄ
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(-10, -7);
  ctx.lineTo(12, -7);
  ctx.lineTo(14, -6);
  ctx.lineTo(-10, -6);
  ctx.closePath();
  ctx.stroke();

  // ‚îÄ‚îÄ Bottom wing (below fuselage) ‚îÄ‚îÄ
  ctx.beginPath();
  ctx.moveTo(-8, 4);
  ctx.lineTo(12, 4);
  ctx.lineTo(14, 5);
  ctx.lineTo(-8, 5);
  ctx.closePath();
  ctx.stroke();

  // ‚îÄ‚îÄ Wing struts ‚îÄ‚îÄ
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(-2, -7);
  ctx.lineTo(-2, 5);
  ctx.moveTo(8, -7);
  ctx.lineTo(8, 5);
  ctx.stroke();

  // ‚îÄ‚îÄ Tail fin (vertical stabilizer, points UP) ‚îÄ‚îÄ
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(-20, -1);
  ctx.lineTo(-24, -7);
  ctx.lineTo(-18, -7);
  ctx.lineTo(-16, -3);
  ctx.stroke();

  // ‚îÄ‚îÄ Tail plane (horizontal stabilizer) ‚îÄ‚îÄ
  ctx.beginPath();
  ctx.moveTo(-22, 0);
  ctx.lineTo(-26, -1);
  ctx.lineTo(-26, 1);
  ctx.lineTo(-22, 1);
  ctx.stroke();

  // ‚îÄ‚îÄ Landing gear (two small struts + wheels) ‚îÄ‚îÄ
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(0, 5);
  ctx.lineTo(-1, 9);
  ctx.moveTo(8, 5);
  ctx.lineTo(7, 9);
  // Axle
  ctx.moveTo(-2, 9);
  ctx.lineTo(8, 9);
  ctx.stroke();
  // Wheels
  ctx.beginPath();
  ctx.arc(-1, 10, 1.5, 0, Math.PI * 2);
  ctx.stroke();
  ctx.beginPath();
  ctx.arc(7, 10, 1.5, 0, Math.PI * 2);
  ctx.stroke();

  // ‚îÄ‚îÄ Propeller (spinning) ‚îÄ‚îÄ
  ctx.lineWidth = 2;
  ctx.strokeStyle = color;
  const pt = Date.now() * 0.03;
  const pLen = 7;
  ctx.beginPath();
  ctx.moveTo(20, -pLen * Math.sin(pt));
  ctx.lineTo(20, pLen * Math.sin(pt));
  ctx.stroke();

  // ‚îÄ‚îÄ Engine cowling (nose cap) ‚îÄ‚îÄ
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(18, -3);
  ctx.lineTo(18, 2);
  ctx.stroke();

  clearGlow(ctx);
  ctx.restore();
}

function drawJet(ctx, x, y, angle, facingLeft, color, scale) {
  scale = scale || 1;
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(angle);
  if (facingLeft) ctx.scale(-1, 1);
  ctx.scale(scale, scale);

  neonGlow(ctx, color, 8);
  ctx.strokeStyle = color;
  ctx.lineWidth = 1.5;

  // Pointed triangular fuselage
  ctx.beginPath();
  ctx.moveTo(22, 0);          // nose tip
  ctx.lineTo(-14, -4);        // top rear
  ctx.lineTo(-18, -3);        // tail notch top
  ctx.lineTo(-18, 3);         // tail notch bottom
  ctx.lineTo(-14, 4);         // bottom rear
  ctx.closePath();
  ctx.stroke();

  // Swept-back delta wings
  ctx.beginPath();
  ctx.moveTo(-2, -4);
  ctx.lineTo(-14, -14);
  ctx.lineTo(-10, -4);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(-2, 4);
  ctx.lineTo(-14, 14);
  ctx.lineTo(-10, 4);
  ctx.stroke();

  // Bubble canopy
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(8, -3);
  ctx.quadraticCurveTo(12, -6, 16, -3);
  ctx.stroke();

  // Vertical tail fin
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(-16, -3);
  ctx.lineTo(-20, -10);
  ctx.lineTo(-14, -8);
  ctx.stroke();

  // Afterburner glow (pulsing)
  const abPulse = 0.5 + 0.5 * Math.sin(Date.now() * 0.02);
  ctx.fillStyle = `rgba(255, ${Math.floor(160 * abPulse)}, 0, ${0.5 + abPulse * 0.5})`;
  ctx.beginPath();
  ctx.arc(-20, 0, 3 + abPulse * 2, 0, Math.PI * 2);
  ctx.fill();

  clearGlow(ctx);
  ctx.restore();
}

function drawBomber(ctx, x, y, angle, facingLeft, color, scale) {
  scale = scale || 1;
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(angle);
  if (facingLeft) ctx.scale(-1, 1);
  ctx.scale(scale, scale);

  neonGlow(ctx, color, 8);
  ctx.strokeStyle = color;
  ctx.lineWidth = 1.5;

  // Wider fuselage
  ctx.beginPath();
  ctx.moveTo(-22, 2);
  ctx.lineTo(-10, 4);
  ctx.lineTo(18, 3);
  ctx.lineTo(24, 0);
  ctx.lineTo(18, -4);
  ctx.lineTo(-10, -4);
  ctx.lineTo(-22, -2);
  ctx.closePath();
  ctx.stroke();

  // Long straight wings
  ctx.beginPath();
  ctx.moveTo(-12, -4);
  ctx.lineTo(14, -4);
  ctx.lineTo(16, -5);
  ctx.lineTo(-12, -5);
  ctx.closePath();
  ctx.stroke();
  // Wing extension (wider span)
  ctx.beginPath();
  ctx.moveTo(-8, -5); ctx.lineTo(-8, -16);
  ctx.moveTo(8, -5); ctx.lineTo(8, -16);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(-8, 4); ctx.lineTo(-8, 16);
  ctx.moveTo(8, 4); ctx.lineTo(8, 16);
  ctx.stroke();

  // Engine nacelles (rectangles under wings)
  ctx.strokeRect(-4, -18, 6, 4);
  ctx.strokeRect(-4, 14, 6, 4);

  // Twin tail fins
  ctx.beginPath();
  ctx.moveTo(-20, -2);
  ctx.lineTo(-24, -8);
  ctx.lineTo(-18, -6);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(-20, 2);
  ctx.lineTo(-24, 8);
  ctx.lineTo(-18, 6);
  ctx.stroke();

  // Bomb bay doors (dashed line underneath)
  ctx.lineWidth = 1;
  ctx.setLineDash([3, 3]);
  ctx.beginPath();
  ctx.moveTo(-6, 4);
  ctx.lineTo(10, 4);
  ctx.stroke();
  ctx.setLineDash([]);

  // ‚îÄ‚îÄ Defensive turret guns (top and bottom) ‚îÄ‚îÄ
  ctx.lineWidth = 1.5;
  // Top turret (dorsal) ‚Äî bubble + gun barrel
  ctx.strokeStyle = color;
  ctx.beginPath();
  ctx.arc(2, -6, 3, 0, Math.PI * 2);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(2, -6);
  ctx.lineTo(2 + 7, -6 - 4);
  ctx.stroke();
  // Bottom turret (ventral) ‚Äî bubble + gun barrel
  ctx.beginPath();
  ctx.arc(2, 6, 3, 0, Math.PI * 2);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(2, 6);
  ctx.lineTo(2 + 7, 6 + 4);
  ctx.stroke();

  // Two spinning propellers
  ctx.lineWidth = 2;
  const pt = Date.now() * 0.03;
  const pLen = 5;
  ctx.beginPath();
  ctx.moveTo(-1, -18 - pLen * Math.sin(pt));
  ctx.lineTo(-1, -18 + pLen * Math.sin(pt));
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(-1, 18 - pLen * Math.sin(pt + 1));
  ctx.lineTo(-1, 18 + pLen * Math.sin(pt + 1));
  ctx.stroke();

  clearGlow(ctx);
  ctx.restore();
}

function drawZeppelin(ctx, x, y, angle, facingLeft, color, scale) {
  scale = scale || 1;
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(angle);
  if (facingLeft) ctx.scale(-1, 1);
  ctx.scale(scale, scale);

  neonGlow(ctx, color, 8);
  ctx.strokeStyle = color;
  ctx.lineWidth = 1.5;

  // Large elongated ellipse (envelope)
  ctx.beginPath();
  ctx.ellipse(0, 0, 40, 10, 0, 0, Math.PI * 2);
  ctx.stroke();

  // Internal frame lines
  for (let fx = -20; fx <= 20; fx += 13) {
    ctx.beginPath();
    ctx.moveTo(fx, -9);
    ctx.lineTo(fx, 9);
    ctx.stroke();
  }

  // Gondola rectangle hanging below
  ctx.strokeRect(-8, 12, 16, 6);
  // Connection lines
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(-6, 10); ctx.lineTo(-8, 12);
  ctx.moveTo(6, 10); ctx.lineTo(8, 12);
  ctx.stroke();

  // Cross-shaped rear stabilizer fins
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(-38, 0); ctx.lineTo(-46, -8);
  ctx.moveTo(-38, 0); ctx.lineTo(-46, 8);
  ctx.moveTo(-38, -5); ctx.lineTo(-46, 0);
  ctx.moveTo(-38, 5); ctx.lineTo(-46, 0);
  ctx.stroke();

  clearGlow(ctx);
  ctx.restore();
}

function drawDragon(ctx, dragon) {
  const d = dragon;
  ctx.save();
  ctx.translate(d.x, d.y);

  const wingFlap = Math.sin(d.wingFrame) * 0.5;
  const bodyUndulate = Math.sin(d.wingFrame * 0.6) * 3;
  const facingLeft = d.vx < 0;
  if (facingLeft) ctx.scale(-1, 1);

  neonGlow(ctx, '#f40', 12);

  // Serpentine body (thick, muscular)
  ctx.strokeStyle = '#f40';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(-30, 0);
  ctx.bezierCurveTo(-18, -6 + bodyUndulate, -4, 6 - bodyUndulate, 12, 0);
  ctx.bezierCurveTo(20, -2 + bodyUndulate * 0.5, 30, 1, 38, 3);
  ctx.stroke();

  // Belly underside (lighter)
  ctx.strokeStyle = '#fa6';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(-28, 2);
  ctx.bezierCurveTo(-16, 5, -2, 4, 14, 2);
  ctx.stroke();

  // Scales along back
  ctx.strokeStyle = '#d30';
  ctx.lineWidth = 1;
  for (let s = -20; s < 15; s += 6) {
    const sy = -4 + Math.sin((s + d.wingFrame * 3) * 0.15) * 2;
    ctx.beginPath();
    ctx.moveTo(s, sy);
    ctx.lineTo(s + 3, sy - 3);
    ctx.lineTo(s + 6, sy);
    ctx.stroke();
  }

  // Head ‚Äî larger with horns, jaw, and crest
  ctx.strokeStyle = '#f40';
  ctx.lineWidth = 2.5;
  // Skull shape
  ctx.beginPath();
  ctx.moveTo(-30, 0);
  ctx.lineTo(-36, -4);
  ctx.lineTo(-40, -2);  // snout
  ctx.lineTo(-38, 1);
  ctx.lineTo(-34, 4);   // lower jaw
  ctx.lineTo(-30, 1);
  ctx.stroke();
  // Upper jaw teeth
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(-38, -1); ctx.lineTo(-37, 1);
  ctx.moveTo(-36, -2); ctx.lineTo(-35, 0);
  ctx.moveTo(-34, -2); ctx.lineTo(-33, 0);
  ctx.stroke();
  // Horns (two large curved)
  ctx.strokeStyle = '#fa0';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(-28, -3);
  ctx.quadraticCurveTo(-26, -12, -22, -14);
  ctx.moveTo(-24, -4);
  ctx.quadraticCurveTo(-22, -11, -18, -12);
  ctx.stroke();
  // Eye (glowing)
  ctx.fillStyle = '#ff0';
  neonGlow(ctx, '#ff0', 6);
  ctx.beginPath();
  ctx.arc(-33, -2, 2, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#f00';
  ctx.beginPath();
  ctx.arc(-33, -2, 0.8, 0, Math.PI * 2);
  ctx.fill();

  // Wings ‚Äî large bat-like with membrane and claws
  neonGlow(ctx, '#f40', 10);
  ctx.strokeStyle = '#f40';
  ctx.lineWidth = 2;
  const wUp = wingFlap * 25;
  // Main wing frame
  ctx.beginPath();
  ctx.moveTo(-8, -3);
  ctx.lineTo(-20, -25 + wUp);
  ctx.lineTo(-5, -18 + wUp * 0.7);
  ctx.lineTo(8, -28 + wUp);
  ctx.lineTo(15, -12 + wUp * 0.5);
  ctx.lineTo(12, -3);
  ctx.stroke();
  // Wing membrane
  ctx.strokeStyle = '#d30';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(-14, -3);
  ctx.lineTo(-18, -22 + wUp);
  ctx.moveTo(-2, -3);
  ctx.lineTo(-8, -20 + wUp * 0.8);
  ctx.moveTo(5, -3);
  ctx.lineTo(4, -22 + wUp * 0.7);
  ctx.moveTo(10, -3);
  ctx.lineTo(12, -16 + wUp * 0.5);
  ctx.stroke();
  // Wing claws
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(-20, -25 + wUp); ctx.lineTo(-22, -27 + wUp);
  ctx.moveTo(8, -28 + wUp); ctx.lineTo(9, -30 + wUp);
  ctx.stroke();

  // Tail ‚Äî long, spiked, sinuous
  ctx.strokeStyle = '#f40';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(38, 3);
  ctx.quadraticCurveTo(46, 8 + bodyUndulate, 52, 4 - bodyUndulate);
  ctx.quadraticCurveTo(58, 0 + bodyUndulate, 62, 3);
  ctx.stroke();
  // Tail spikes
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(48, 5); ctx.lineTo(50, -1);
  ctx.moveTo(54, 3); ctx.lineTo(56, -2);
  ctx.moveTo(60, 3); ctx.lineTo(63, -1);
  ctx.stroke();
  // Tail tip (arrow/spade)
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(62, 3);
  ctx.lineTo(68, 0);
  ctx.lineTo(65, 3);
  ctx.lineTo(68, 6);
  ctx.lineTo(62, 3);
  ctx.stroke();

  // Legs (small, tucked)
  ctx.strokeStyle = '#d30';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(-5, 3); ctx.lineTo(-8, 10); ctx.lineTo(-5, 10);
  ctx.moveTo(8, 3); ctx.lineTo(5, 10); ctx.lineTo(8, 10);
  ctx.stroke();

  // Fire breath when in breathing phase
  if (d.phase === 'breathing') {
    neonGlow(ctx, '#f80', 15);
    for (let i = 0; i < 8; i++) {
      const fx = -40 - i * 5 - Math.random() * 4;
      const fy = (Math.random() - 0.5) * (5 + i * 3);
      const r = 2 + Math.random() * 2;
      const colors = ['#ff0', '#f80', '#f40', '#f22'];
      ctx.fillStyle = colors[i % colors.length];
      ctx.globalAlpha = 0.8 - i * 0.08;
      ctx.beginPath();
      ctx.arc(fx, fy, r, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;
  }

  clearGlow(ctx);
  ctx.restore();
}

function drawPerson(person) {
  const p = person;
  const alpha = p.life < 1 ? p.life : 1;
  ctx.globalAlpha = alpha;
  neonGlow(ctx, p.color, 4);
  ctx.strokeStyle = p.color;
  ctx.lineWidth = 1;

  const legAnim = Math.sin(p.frame * 8) * 3;
  const armAnim = Math.sin(p.frame * 6) * 2;

  // Head
  ctx.beginPath();
  ctx.arc(p.x, p.y - 7, 1.5, 0, Math.PI * 2);
  ctx.stroke();
  // Body
  ctx.beginPath();
  ctx.moveTo(p.x, p.y - 5.5);
  ctx.lineTo(p.x, p.y - 2);
  ctx.stroke();
  // Arms (waving)
  ctx.beginPath();
  ctx.moveTo(p.x - 2 - armAnim, p.y - 5);
  ctx.lineTo(p.x, p.y - 4);
  ctx.lineTo(p.x + 2 + armAnim, p.y - 5);
  ctx.stroke();
  // Legs (running)
  ctx.beginPath();
  ctx.moveTo(p.x - 1.5 - legAnim, p.y);
  ctx.lineTo(p.x, p.y - 2);
  ctx.lineTo(p.x + 1.5 + legAnim, p.y);
  ctx.stroke();

  clearGlow(ctx);
  ctx.globalAlpha = 1;
}

function drawAnimal(animal) {
  const o = animal;
  const type = o.type || 'ox';
  if (type === 'ox') {
    drawOx(o);
    return;
  }

  if (type === 'sheep') {
    neonGlow(ctx, '#ddd', 6);
    ctx.strokeStyle = '#ddd';
    ctx.lineWidth = 1.5;
    // Fluffy body (rounded rect with wavy top)
    ctx.beginPath();
    ctx.moveTo(o.x + 2, o.y + 2);
    ctx.lineTo(o.x + 13, o.y + 2);
    ctx.lineTo(o.x + 13, o.y + 6);
    ctx.lineTo(o.x + 2, o.y + 6);
    ctx.closePath();
    ctx.stroke();
    // Wavy top (fluffy)
    ctx.beginPath();
    ctx.moveTo(o.x + 2, o.y + 2);
    for (let wx = 3; wx < 13; wx += 2) {
      ctx.lineTo(o.x + wx, o.y + 2 - Math.sin(wx) * 1.5);
    }
    ctx.stroke();
    // Legs
    ctx.beginPath();
    ctx.moveTo(o.x + 4, o.y + 6); ctx.lineTo(o.x + 4, o.y + 8);
    ctx.moveTo(o.x + 11, o.y + 6); ctx.lineTo(o.x + 11, o.y + 8);
    ctx.stroke();
    // Head
    const headX = o.dir > 0 ? o.x + 13 : o.x + 2;
    ctx.beginPath();
    ctx.arc(headX, o.y + 2, 2, 0, Math.PI * 2);
    ctx.stroke();
    clearGlow(ctx);
  } else if (type === 'horse') {
    neonGlow(ctx, '#a72', 6);
    ctx.strokeStyle = '#a72';
    ctx.lineWidth = 1.5;
    // Body
    ctx.strokeRect(o.x + 3, o.y + 2, 16, 6);
    // Taller legs
    ctx.beginPath();
    ctx.moveTo(o.x + 5, o.y + 8); ctx.lineTo(o.x + 5, o.y + 12);
    ctx.moveTo(o.x + 8, o.y + 8); ctx.lineTo(o.x + 8, o.y + 12);
    ctx.moveTo(o.x + 15, o.y + 8); ctx.lineTo(o.x + 15, o.y + 12);
    ctx.moveTo(o.x + 18, o.y + 8); ctx.lineTo(o.x + 18, o.y + 12);
    ctx.stroke();
    // Longer neck and head
    const headX = o.dir > 0 ? o.x + 19 : o.x + 3;
    const neckDir = o.dir > 0 ? 1 : -1;
    ctx.beginPath();
    ctx.moveTo(headX, o.y + 2);
    ctx.lineTo(headX + neckDir * 3, o.y - 3);
    ctx.lineTo(headX + neckDir * 7, o.y - 3);
    ctx.lineTo(headX + neckDir * 7, o.y);
    ctx.stroke();
    // Mane
    ctx.beginPath();
    ctx.moveTo(headX + neckDir * 1, o.y);
    ctx.lineTo(headX + neckDir * 4, o.y - 5);
    ctx.stroke();
    // Tail
    const tailX = o.dir > 0 ? o.x + 3 : o.x + 19;
    ctx.beginPath();
    ctx.moveTo(tailX, o.y + 2);
    ctx.quadraticCurveTo(tailX - neckDir * 5, o.y, tailX - neckDir * 4, o.y + 5);
    ctx.stroke();
    clearGlow(ctx);
  } else if (type === 'camel') {
    neonGlow(ctx, '#da8', 6);
    ctx.strokeStyle = '#da8';
    ctx.lineWidth = 1.5;
    // Body
    ctx.strokeRect(o.x + 3, o.y + 2, 16, 5);
    // Humps (1-2 arcs on back)
    ctx.beginPath();
    ctx.arc(o.x + 8, o.y + 2, 3, Math.PI, 0);
    ctx.arc(o.x + 15, o.y + 2, 2.5, Math.PI, 0);
    ctx.stroke();
    // Longer legs
    ctx.beginPath();
    ctx.moveTo(o.x + 5, o.y + 7); ctx.lineTo(o.x + 5, o.y + 12);
    ctx.moveTo(o.x + 8, o.y + 7); ctx.lineTo(o.x + 8, o.y + 12);
    ctx.moveTo(o.x + 15, o.y + 7); ctx.lineTo(o.x + 15, o.y + 12);
    ctx.moveTo(o.x + 18, o.y + 7); ctx.lineTo(o.x + 18, o.y + 12);
    ctx.stroke();
    // Long neck
    const headX = o.dir > 0 ? o.x + 19 : o.x + 3;
    const neckDir = o.dir > 0 ? 1 : -1;
    ctx.beginPath();
    ctx.moveTo(headX, o.y + 2);
    ctx.lineTo(headX + neckDir * 2, o.y - 5);
    ctx.lineTo(headX + neckDir * 5, o.y - 5);
    ctx.stroke();
    // Head
    ctx.beginPath();
    ctx.arc(headX + neckDir * 5, o.y - 5, 2, 0, Math.PI * 2);
    ctx.stroke();
    clearGlow(ctx);
  }
}

// ‚îÄ‚îÄ Camera ‚îÄ‚îÄ
let camX = 0, camY = 0;

function updateCamera() {
  const targetX = player.x - canvas.width * 0.35;
  const targetY = player.y - canvas.height * 0.45;
  camX += (targetX - camX) * 0.08;
  camY += (targetY - camY) * 0.06;
  // Clamp vertical
  camY = Math.max(-100, Math.min(camY, 400));
}

// ‚îÄ‚îÄ Update logic ‚îÄ‚îÄ
let lastTime = 0;
let frameCount = 0;

function update(dt) {
  frameCount++;
  if (state === ST.PLAYING) {
    if (enemyAccuracyDebuff > 0) enemyAccuracyDebuff -= dt;
    updatePlayer(dt);
    updateBullets(dt);
    updateBombs(dt);
    updateDepthCharges(dt);
    updateShockwaves(dt);
    updateEnemies(dt);
    updateFlak(dt);
    updateBirds(dt);
    updateOxen(dt);
    updateFleeingPeople(dt);
    updateDragons(dt);
    updateSubmarines(dt);
    updateSpeedboats(dt);
    // Theme-specific updates
    const curTheme = getLevelTheme(level);
    if (curTheme === 'cloud') updateFuelTankers(dt);
    if (curTheme === 'cave') { updateBats(dt); updateCaveTurrets(dt); }
    if (curTheme === 'normandy') { updateTanks(dt); updateBarrageBalloons(dt); }
    if (curTheme === 'forest') { updateAAGuns(dt); updateTrains(dt); }
    // Player crashes into tanks/trains
    if (!player.landed && !player.burning && player.invincible <= 0) {
      for (const tank of tanks) {
        if (!tank.alive) continue;
        if (Math.abs(player.x - tank.x) < 15 && Math.abs(player.y - tank.y) < 12) {
          tank.alive = false; addExplosion(tank.x, tank.y, 25, true); playBoom(true);
          score += 350; damagePlayer(2); break;
        }
      }
      for (const tr of trains) {
        if (!tr.alive) continue;
        const trainLen = tr.segments * (tr.segmentWidth + 3);
        if (player.x > tr.x - trainLen - 5 && player.x < tr.x + 15 && Math.abs(player.y - tr.y) < 15) {
          damagePlayer(2); addExplosion(player.x, player.y, 15, true); break;
        }
      }
    }
    // Player crashes into buildings ‚Äî both destroyed
    if (!player.landed && !player.burning && player.invincible <= 0) {
      for (const bld of buildings) {
        if (!bld.alive) continue;
        if (player.x > bld.x - 10 && player.x < bld.x + bld.w + 10 &&
            player.y > bld.y - 5 && player.y < bld.y + bld.h + 5) {
          bld.alive = false;
          addExplosion(bld.x + bld.w / 2, bld.y + bld.h / 2, 35, true);
          playBoom(true);
          score += buildingScores[bld.type] || 100;
          onBuildingDestroyed(bld);
          damagePlayer(3); // devastating crash
          break;
        }
      }
    }
    updateParachutes(dt);
    updateParticles(dt);
    updateCamera();
    checkLevelComplete();
    updateHUD();
  } else if (state === ST.DYING) {
    updateParachutes(dt);
    updateParticles(dt);
    deathTimer -= dt;
    if (deathTimer <= 0) {
      if (lives <= 0) {
        state = ST.GAME_OVER;
      } else {
        initPlayer();
        player.hp = PLAYER_MAX_HP; // explicit HP reset guarantee
        player.invincible = 3; // 3 seconds of invincibility after respawn
        // Clear hostile projectiles near spawn
        bullets = bullets.filter(b => b.friendly);
        bombs = bombs.filter(b => b.friendly !== false);
        flakShots = [];
        if (lives === 1) lastChanceMsg = 3; // show warning for 3 seconds
        state = ST.PLAYING;
      }
    }
  } else if (state === ST.LEVEL_COMPLETE) {
    updateParticles(dt);
    levelTimer -= dt;
    if (levelTimer <= 0) {
      level++;
      if (level > highestLevel) highestLevel = level;
      initLevel();
      state = ST.PLAYING;
    }
  }
}

// ‚îÄ‚îÄ Angle helpers ‚îÄ‚îÄ
// Angle indices: 0=right, 4=up, 8=left, 12=down (counterclockwise)
// "Nose up" = increment toward 4, "Nose down" = decrement toward 12 (via 0‚Üí15‚Üí14‚Üí13...)

function getEffectiveAngle(p) {
  // angleIdx directly determines direction via COS/SIN tables ‚Äî no mirroring needed
  return p.angleIdx;
}

// Radian angle for canvas rendering (canvas: 0=right, positive=clockwise=down)
function getPlaneRadians(p) {
  const effAngle = getEffectiveAngle(p);
  // effAngle goes counterclockwise, canvas goes clockwise, so negate
  return -effAngle * ANGLE_STEP;
}

function updatePlayer(dt) {
  const p = player;
  p.moveCount++;

  // ‚îÄ‚îÄ Autopilot: tractor beam guided landing ‚îÄ‚îÄ
  if (p.autopilot) {
    const homeX = baseX + BASE_WIDTH / 2;
    const homeY = getTerrainY(homeX) - 8;
    const dx = homeX - p.x;
    const dy = homeY - p.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const CAPTURE_RADIUS = 400; // matches searchlight range

    // Too far ‚Äî cancel autopilot so player retains control
    if (dist > CAPTURE_RADIUS) {
      p.autopilot = false;
    }
    // Within capture range: tractor beam pulls plane in
    else {
      p.orient = false;
      p.stalled = false;
      // Smoothly interpolate position toward the runway
      const lerpRate = 0.02 * (60 * dt);  // ~2% per frame at 60fps
      p.x += (homeX - p.x) * lerpRate;
      p.y += (homeY - p.y) * lerpRate;

      // Smoothly level the plane
      const targetAngle = dx > 0 ? 0 : 8;
      if (p.angleIdx !== targetAngle && p.moveCount % 3 === 0) {
        const diff = ((targetAngle - p.angleIdx) + NUM_ANGLES) % NUM_ANGLES;
        if (diff <= 8) p.angleIdx = (p.angleIdx + 1) % NUM_ANGLES;
        else p.angleIdx = ((p.angleIdx - 1) + NUM_ANGLES) % NUM_ANGLES;
      }

      // Reduce speed and zero velocity (beam controls position)
      p.speed = Math.max(0, p.speed - 0.5);
      p.accel = 0;
      p.vx = 0;
      p.vy = 0;

      // Timers still tick
      p.fireCooldown -= dt;
      p.bombCooldown -= dt;
      p.depthChargeCooldown -= dt;
      if (p.invincible > 0) p.invincible -= dt;
      p.fuel -= dt * 5; // minimal fuel use during beam approach
      if (p.fuel <= 0) p.fuel = 0;

      // Landing: close enough to runway
      const landDist = Math.sqrt((p.x - homeX) ** 2 + (p.y - homeY) ** 2);
      if (landDist < 15) {
        p.landed = true;
        p.autopilot = false;
        p.speed = 0; p.accel = 0; p.angleIdx = 0;
        p.vx = 0; p.vy = 0;
        p.x = homeX; p.y = homeY;
        p.fuel = MAX_FUEL; p.ammo = MAX_AMMO; p.bombCount = MAX_BOMBS;
        p.depthCharges = MAX_DEPTH_CHARGES;
        p.hp = PLAYER_MAX_HP; p.wounded = false; // Repair on landing
      }
      return; // Skip normal physics ‚Äî beam handles everything
    }
  }

  // ‚îÄ‚îÄ Burning plane ‚Äî uncontrollable dive to crash ‚îÄ‚îÄ
  if (p.burning) {
    p.burnTimer -= dt;
    p.hitFlash -= dt;
    // Nose drops slowly toward ground
    if (p.moveCount % 8 === 0) {
      const diff = ((12 - p.angleIdx) + NUM_ANGLES) % NUM_ANGLES;
      if (diff > 0 && diff <= 8) p.angleIdx = (p.angleIdx + 1) % NUM_ANGLES;
      else if (diff > 8) p.angleIdx = ((p.angleIdx - 1) + NUM_ANGLES) % NUM_ANGLES;
    }
    p.accel = 0;
    if (p.engineOut) {
      // Engine out: light smoke only, no fire
      if (Math.random() < 0.15) {
        const rad = getPlaneRadians(p);
        addParticle(p.x - Math.cos(rad) * 15, p.y - Math.sin(rad) * 15,
          (Math.random() - 0.5) * 10, -10 - Math.random() * 10, 0.5, '#555', 2);
      }
    } else {
      // Fire/smoke particles trailing from engine
      const rad = getPlaneRadians(p);
      addParticle(p.x - Math.cos(rad) * 15, p.y - Math.sin(rad) * 15,
        (Math.random() - 0.5) * 30, -20 - Math.random() * 20, 0.4,
        Math.random() < 0.5 ? '#f80' : '#f44', 2 + Math.random());
      if (Math.random() < 0.3) {
        addParticle(p.x + (Math.random() - 0.5) * 10, p.y + (Math.random() - 0.5) * 10,
          (Math.random() - 0.5) * 15, -10 - Math.random() * 15, 0.6, '#333', 3);
      }
    }
    // Timer expired: final explosion
    if (p.burnTimer <= 0) {
      killPlayer();
      return;
    }
    // Don't process manual controls ‚Äî plane is doomed
    // Fall through to physics below
  }

  // ‚îÄ‚îÄ Autopilot toggle (H) ‚Äî always available, not gated by autopilot state ‚îÄ‚îÄ
  if (!p.burning) {
    if (keys['KeyH']) {
      if (!p._autoHeld) { p.autopilot = !p.autopilot; p._autoHeld = true; }
    } else { p._autoHeld = false; }

    // Cancel autopilot on any manual input (pitch, throttle, fire, bomb)
    if (p.autopilot && (keys['Comma'] || keys['Slash'] || keys['ArrowUp'] || keys['ArrowDown']
        || keys['KeyX'] || keys['Backslash'] || keys['Backquote'] || keys['Space'] || keys['KeyB'])) {
      p.autopilot = false;
    }
  }

  // ‚îÄ‚îÄ Wounded smoke trail ‚îÄ‚îÄ
  if (p.wounded && !p.burning && !p.landed) {
    if (Math.random() < 0.25) {
      const rad = getPlaneRadians(p);
      addParticle(p.x - Math.cos(rad) * 12, p.y - Math.sin(rad) * 12,
        (Math.random() - 0.5) * 15, -8 - Math.random() * 8, 0.4, '#555', 2);
    }
  }

  // ‚îÄ‚îÄ Manual controls ‚îÄ‚îÄ
  // Wounded state: controls only respond every other frame (sluggish)
  const controlsActive = !p.wounded || (p.moveCount % 2 === 0);
  if (!p.autopilot && !p.burning && controlsActive) {
    // Accelerate (X or ArrowUp)
    if (keys['KeyX'] || keys['ArrowUp']) {
      if (p.accel < PLANE_MAX_ACCEL) p.accel++;
    }
    // Decelerate (Backslash)
    if (keys['Backslash'] || keys['Backquote']) {
      if (p.accel > 0) p.accel--;
    }

    // Pitch: when orient=false, nose-up increments angleIdx; when orient=true, it decrements (inverted)
    // This matches original Sopwith: if (ob->ob_orient) nangle -= update; else nangle += update;
    const pitchUp = p.orient ? -1 : 1;
    const pitchDown = p.orient ? 1 : -1;

    // Nose up (Comma or ArrowUp)
    if (keys['Comma'] || keys['ArrowUp']) {
      if (!p._turnHeld) {
        p.angleIdx = ((p.angleIdx + pitchUp) + NUM_ANGLES) % NUM_ANGLES;
        p._turnHeld = true;
        p._turnTimer = 0;
      } else {
        p._turnTimer++;
        if (p._turnTimer >= 10) {
          p.angleIdx = ((p.angleIdx + pitchUp) + NUM_ANGLES) % NUM_ANGLES;
          p._turnTimer = 0;
        }
      }
    }
    // Nose down (Slash or ArrowDown)
    else if (keys['Slash'] || keys['ArrowDown']) {
      if (!p._turnHeld) {
        p.angleIdx = ((p.angleIdx + pitchDown) + NUM_ANGLES) % NUM_ANGLES;
        p._turnHeld = true;
        p._turnTimer = 0;
      } else {
        p._turnTimer++;
        if (p._turnTimer >= 10) {
          p.angleIdx = ((p.angleIdx + pitchDown) + NUM_ANGLES) % NUM_ANGLES;
          p._turnTimer = 0;
        }
      }
    } else {
      p._turnHeld = false;
      p._turnTimer = 0;
    }

    // Fire
    if (keys['Space'] && p.fireCooldown <= 0 && p.ammo > 0) {
      const rad = getPlaneRadians(p);
      const bx = p.x + Math.cos(rad) * 25;
      const by = p.y + Math.sin(rad) * 25;
      const bvx = Math.cos(rad) * BULLET_SPEED + p.vx * 0.3;
      const bvy = Math.sin(rad) * BULLET_SPEED + p.vy * 0.3;
      bullets.push({ x: bx, y: by, vx: bvx, vy: bvy, life: 1.2, friendly: true });
      p.ammo--;
      p.fireCooldown = 0.08;
      playShoot();
    }

    // Bomb
    if (keys['KeyB'] && p.bombCooldown <= 0 && p.bombCount > 0) {
      bombs.push({ x: p.x, y: p.y + 5, vx: p.vx * BOMB_VXFRAC, vy: p.vy + 20, life: 5, friendly: true });
      p.bombCount--;
      p.bombCooldown = 0.4;
      playBombDrop();
    }

    // Depth charge (D key) ‚Äî sinks through water, damages submerged subs
    if (keys['KeyD'] && p.depthChargeCooldown <= 0 && p.depthCharges > 0 && waterLineY > 0) {
      depthCharges.push({ x: p.x, y: p.y + 5, vx: p.vx * 0.3, vy: 30, life: 6, sinking: false });
      p.depthCharges--;
      p.depthChargeCooldown = 0.6;
      playBombDrop();
    }
  }

  p.fireCooldown -= dt;
  p.bombCooldown -= dt;
  p.depthChargeCooldown -= dt;
  if (p.invincible > 0) p.invincible -= dt;
  if (p.hitFlash > 0) p.hitFlash -= dt;

  // ‚îÄ‚îÄ Sopwith-style physics ‚îÄ‚îÄ
  if (!p.landed) {
    const effAngle = getEffectiveAngle(p);

    // Speed update every 4 frames (gradual, prevents sudden speed loss)
    if (p.moveCount % 4 === 0) {
      const grav = GRAVITY_TABLE[effAngle];
      const targetSpeed = PLANE_MIN_SPEED + p.accel + grav;
      if (p.speed < targetSpeed) p.speed++;
      else if (p.speed > targetSpeed) p.speed--;
      if (p.speed > PLANE_MAX_SPEED) p.speed = PLANE_MAX_SPEED;
    }

    // With throttle applied, never drop below minimum flight speed (checked every frame)
    if (p.accel > 0 && p.speed < PLANE_MIN_SPEED) p.speed = PLANE_MIN_SPEED;

    // Stall: speed too low (only in normal flight, not when burning, not with throttle)
    if (p.speed <= STALL_SPEED && !p.stalled && !p.burning && p.accel === 0) {
      p.stalled = true;
    }

    if (p.stalled) {
      // Nose drops toward "down" (angleIdx 12 = straight down)
      if (p.moveCount % 8 === 0) {
        if (p.angleIdx !== 12) {
          const diff = ((12 - p.angleIdx) + NUM_ANGLES) % NUM_ANGLES;
          if (diff <= 8) p.angleIdx = (p.angleIdx + 1) % NUM_ANGLES;
          else p.angleIdx = ((p.angleIdx - 1) + NUM_ANGLES) % NUM_ANGLES;
        }
      }
      // Speed naturally increases during dive ‚Äî minimum floor of 1
      if (p.speed < 1) p.speed = 1;
      // Recover when speed adequate (relaxed angle requirement)
      if (p.speed >= PLANE_MIN_SPEED) {
        p.stalled = false;
      }
    }

    // Velocity from speed + angle
    // COS_TABLE/SIN_TABLE: index 0=right, 4=up in math coords
    // Canvas: Y-down, so negate SIN for vy
    p.vx = COS_TABLE[effAngle] * p.speed * PIXELS_PER_UNIT;
    p.vy = -SIN_TABLE[effAngle] * p.speed * PIXELS_PER_UNIT;

    // Stall gravity (only when actually stalling, not just slow with throttle)
    if (p.stalled || (p.speed < PLANE_MIN_SPEED && p.accel === 0)) {
      p.vy += 150 * dt;
    }

    // Move
    p.x += p.vx * dt;
    p.y += p.vy * dt;

    // Fuel
    p.fuel -= dt * (8 + p.accel * 5);
    if (p.fuel <= 0) {
      p.fuel = 0;
      p.accel = 0;
      // Out of fuel ‚Äî engine dead, plane glides down and crashes
      if (!p.burning && !p.stalled) {
        p.burning = true;
        p.engineOut = true;
        p.burnTimer = 5; // longer glide before crash
      }
    }

    // Engine trail
    if (p.accel > 0) {
      const rad = getPlaneRadians(p);
      const tx = p.x - Math.cos(rad) * 20;
      const ty = p.y - Math.sin(rad) * 20;
      addEngineTrail(tx, ty, -p.vx * 0.3, -p.vy * 0.3);
    }

    // Low fuel warning ‚Äî sputtering smoke from engine
    if (!p.landed && !p.burning && p.fuel > 0) {
      const fuelRatio = p.fuel / MAX_FUEL;
      if (fuelRatio < 0.25) {
        const rad = getPlaneRadians(p);
        const ex = p.x - Math.cos(rad) * 18;
        const ey = p.y - Math.sin(rad) * 18;
        // Sputtering dark smoke ‚Äî more frequent as fuel drops
        const smokeChance = fuelRatio < 0.10 ? 0.5 : 0.25;
        if (Math.random() < smokeChance) {
          addParticle(ex + (Math.random() - 0.5) * 6, ey + (Math.random() - 0.5) * 6,
            (Math.random() - 0.5) * 15, -15 - Math.random() * 10, 0.5,
            '#444', 2 + Math.random());
        }
        // Occasional orange sputter below 10%
        if (fuelRatio < 0.10 && Math.random() < 0.15) {
          addParticle(ex, ey, (Math.random() - 0.5) * 20, -10, 0.25, '#f80', 1.5);
        }
      }
    }

    // Auto-turn at world edges ‚Äî instant horizontal mirror
    // angleIdx: 0=right, 4=up, 8=left, 12=down
    // Horizontal mirror formula: (8 - idx + 16) % 16
    //   0(right)‚Üí8(left), 1‚Üí7, 4(up)‚Üí4(up), 8(left)‚Üí0(right), 12(down)‚Üí12(down)
    if (p.x < 10) {
      p.x = 10;
      p.angleIdx = (8 - p.angleIdx + NUM_ANGLES) % NUM_ANGLES;
      p.vx = Math.abs(p.vx) || 1;
    }
    if (p.x >= WORLD_W - 10) {
      p.x = WORLD_W - 10;
      p.angleIdx = (8 - p.angleIdx + NUM_ANGLES) % NUM_ANGLES;
      p.vx = -(Math.abs(p.vx) || 1);
    }

    // Ceiling ‚Äî bounce off, lose speed but don't kill it entirely
    if (p.y < -50) {
      p.y = -50;
      p.vy = Math.abs(p.vy) * 0.3; // push back down gently
      // Bleed speed but keep enough to recover
      p.speed = Math.max(PLANE_MIN_SPEED, Math.floor(p.speed * 0.5));
      // Nudge nose downward to help recovery
      if (p.angleIdx >= 2 && p.angleIdx <= 6) {
        // Pointing upward ‚Äî push toward level
        p.angleIdx = (p.angleIdx + 1) % NUM_ANGLES;
      }
    }

    // Ceiling collision (cave theme)
    if (ceilingTerrain) {
      const ceilY = getCeilingY(p.x);
      if (p.y <= ceilY + 8) {
        killPlayer();
        return;
      }
    }

    // Canopy collision (forest theme)
    if (canopyHeight) {
      const canY = getCanopyY(p.x);
      if (canY < 9999 && p.y >= canY - 5 && p.y < getTerrainY(p.x) - 15) {
        damagePlayer(1);
        p.y = canY - 8;
        p.vy = -Math.abs(p.vy) * 0.3;
      }
    }

    // Ground collision
    const groundY = getTerrainY(p.x);
    if (p.y >= groundY - 8) {
      const nearBase = p.x > baseX - 30 && p.x < baseX + BASE_WIDTH + 30;
      // Level = angleIdx near 0 (rightward: 0,1,15) or near 8 (leftward: 7,8,9)
      const levelEnough = (p.angleIdx <= 1 || p.angleIdx >= 15 || (p.angleIdx >= 7 && p.angleIdx <= 9));
      const slowEnough = p.speed <= PLANE_MIN_SPEED + 2;

      if (nearBase && levelEnough && slowEnough && !p.stalled && !p.orient && !p.burning) {
        p.y = groundY - 8;
        p.vy = 0; p.vx = 0; p.speed = 0; p.accel = 0; p.angleIdx = 0;
        p.orient = false;
        p.landed = true; p.stalled = false;
        p.fuel = MAX_FUEL; p.ammo = MAX_AMMO; p.bombCount = MAX_BOMBS;
        p.depthCharges = MAX_DEPTH_CHARGES;
        p.hp = PLAYER_MAX_HP; p.wounded = false; // Repair on landing
      } else {
        killPlayer();
        return;
      }
    }
  } else {
    // ‚îÄ‚îÄ On ground at base ‚îÄ‚îÄ
    if (keys['KeyX'] || keys['ArrowUp']) {
      // Award Purple Heart if survived wounded flight
      if (p.wounded) awardMedal('purple_heart');
      // Award Perfect Flight if completed previous flight undamaged
      if (flightStats.damageTaken === 0 && flightStats.kills > 0) awardMedal('perfect');
      // Award ace medals
      if (flightStats.kills >= 15) awardMedal('top_ace');
      else if (flightStats.kills >= 5) awardMedal('ace');
      if (flightStats.valour >= 500) awardMedal('valour');
      // Reset flight stats for new sortie
      flightStats = { kills: 0, damageTaken: 0, valour: 0 };
      p.landed = false;
      p.stalled = false;
      p.orient = false;
      p.accel = PLANE_MAX_ACCEL;
      p.speed = PLANE_MAX_SPEED - 1;
      p.angleIdx = 2; // Slight nose-up: index 2 = climbing right at ~45¬∞
    }
    p.y = getTerrainY(p.x) - 8;
  }
}

// ‚îÄ‚îÄ Parachute tracking ‚îÄ‚îÄ
let parachutes = [];

function damagePlayer(amount) {
  if (player.invincible > 0 || player.burning || state !== ST.PLAYING) return;
  amount = amount || 1;
  player.hp -= amount;
  player.hitFlash = 0.3;
  player.invincible = 0.5; // brief i-frames after hit
  flightStats.damageTaken += amount;
  addExplosion(player.x, player.y, 8, false);
  if (player.hp <= 0) {
    // Plane is destroyed ‚Äî start burning dive
    player.burning = true;
    player.burnTimer = 2.5; // seconds until final explosion
    player.autopilot = false;
    // Eject pilot parachute
    parachutes.push({
      x: player.x, y: player.y - 10,
      vx: (Math.random() - 0.5) * 30,
      vy: -40,
      deployed: false,
      deployTimer: 0.3,
      landed: false
    });
  } else if (player.hp === 1) {
    // Wounded state ‚Äî plane is damaged but flyable
    player.wounded = true;
  }
}

function startEnemyBurn(en) {
  if (en.burning) return;
  en.burning = true;
  en.burnTimer = 1.5;
  en.speed = en.speed * 0.4; // slow down
  score += ENEMY_SPECS[en.type].score;
  addValourScore(ENEMY_SPECS[en.type].score, en.x);
}

function killEnemy(en) {
  en.alive = false;
  en.burning = false;
  addExplosion(en.x, en.y, 25, true);
  playBoom(false);
  launchNextFromBases();
}

function killPlayer() {
  addExplosion(player.x, player.y, 40, true);
  playBoom(true);
  // Crater in terrain (skip if inside home base territory or water)
  const crashIsWater = waterLineY > 0 && getTerrainY(player.x) >= waterLineY - 5;
  if (!isInBaseTerritory(player.x) && !crashIsWater) {
    for (let dx = -30; dx <= 30; dx++) {
      const ix = Math.floor(((player.x + dx) % WORLD_W + WORLD_W) % WORLD_W);
      if (ix >= 0 && ix < WORLD_W) {
        terrain[ix] += (30 - Math.abs(dx)) * 0.5;
      }
    }
  }
  player.burning = false;
  player.engineOut = false;
  lives--;
  state = ST.DYING;
  deathTimer = 2.5;
}

function updateParachutes(dt) {
  for (let i = parachutes.length - 1; i >= 0; i--) {
    const p = parachutes[i];
    if (p.landed) {
      p.landTimer -= dt;
      if (p.landTimer <= 0) { parachutes.splice(i, 1); }
      continue;
    }
    p.deployTimer -= dt;
    if (p.deployTimer <= 0) p.deployed = true;
    if (p.deployed) {
      // Gentle drift down
      p.vy = 40; // slow descent
      p.vx *= 0.98; // slow horizontal drift
    } else {
      // Free-fall before chute opens
      p.vy += 200 * dt;
    }
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    // Ground landing
    const groundY = getTerrainY(p.x);
    if (p.y >= groundY - 5) {
      p.y = groundY - 5;
      p.landed = true;
      p.landTimer = 2; // stay visible on ground briefly
    }
  }
}

function updateBullets(dt) {
  for (let i = bullets.length - 1; i >= 0; i--) {
    const b = bullets[i];
    b.x += b.vx * dt;
    b.y += b.vy * dt;
    b.vy += PROJ_GRAVITY * 0.3 * dt;
    b.life -= dt;

    // Despawn at world edges
    if (b.x < 0 || b.x >= WORLD_W) { bullets.splice(i, 1); continue; }

    // Ceiling hit (cave theme)
    if (ceilingTerrain && b.y <= getCeilingY(b.x)) {
      addParticle(b.x, b.y, 0, 30, 0.2, '#f80', 2);
      bullets.splice(i, 1);
      continue;
    }

    // Ground hit
    if (b.y >= getTerrainY(b.x)) {
      addParticle(b.x, b.y, 0, -30, 0.2, '#ff0', 2);
      bullets.splice(i, 1);
      continue;
    }

    if (b.life <= 0 || b.y < -200) {
      bullets.splice(i, 1);
      continue;
    }

    // Hit buildings (friendly bullets only)
    if (b.friendly) {
      for (const bld of buildings) {
        if (!bld.alive) continue;
        if (b.x > bld.x && b.x < bld.x + bld.w && b.y > bld.y && b.y < bld.y + bld.h) {
          bld.hp--;
          if (bld.hp <= 0) {
            bld.alive = false;
            addExplosion(bld.x + bld.w / 2, bld.y + bld.h / 2, 25, true);
            playBoom(true);
            score += buildingScores[bld.type] || 100;
            // Terrain crater (skip in base territory and water)
            const bldIsWater = waterLineY > 0 && getTerrainY(bld.x + bld.w / 2) >= waterLineY - 5;
            if (!isInBaseTerritory(bld.x + bld.w / 2) && !bldIsWater) {
              for (let dx = -20; dx <= 20; dx++) {
                const ix = Math.floor(((bld.x + bld.w / 2 + dx) % WORLD_W + WORLD_W) % WORLD_W);
                if (ix >= 0 && ix < WORLD_W) terrain[ix] += (20 - Math.abs(dx)) * 0.3;
              }
            }
            onBuildingDestroyed(bld);
          } else {
            addExplosion(b.x, b.y, 5, false);
            // Dam hit: extra blue splash
            if (bld.type === 'dam') {
              for (let k = 0; k < 6; k++) {
                addParticle(b.x, b.y, (Math.random()-0.5)*60, -30-Math.random()*40, 0.4, '#48f', 2);
              }
            }
          }
          bullets.splice(i, 1);
          break;
        }
      }
    }

    // Friendly bullets hit enemies (type-aware hitbox)
    if (b.friendly) {
      for (const en of enemies) {
        if (!en.alive || en.burning || en.state === 'hangar') continue;
        const spec = ENEMY_SPECS[en.type] || ENEMY_SPECS.biplane;
        if (Math.abs(b.x - en.x) < spec.hitW && Math.abs(b.y - en.y) < spec.hitH) {
          en.hp--;
          if (en.hp <= 0) {
            startEnemyBurn(en);
          }
          bullets.splice(i, 1);
          break;
        }
      }
    }

    // Friendly bullets hit dragons
    if (b.friendly) {
      for (const d of dragons) {
        if (!d.alive) continue;
        if (Math.abs(b.x - d.x) < 25 && Math.abs(b.y - d.y) < 15) {
          d.hp--;
          if (d.hp <= 0) {
            d.alive = false;
            addExplosion(d.x, d.y, 40, true);
            playBoom(true);
            score += 1000;
          } else {
            addExplosion(b.x, b.y, 5, false);
          }
          bullets.splice(i, 1);
          break;
        }
      }
    }

    // Friendly bullets hit submarines (when not fully submerged)
    if (b.friendly) {
      for (const sub of submarines) {
        if (!sub.alive || sub.phase === 'submerged') continue;
        if (Math.abs(b.x - sub.x) < 55 && Math.abs(b.y - sub.y) < 18) {
          sub.hp--;
          if (sub.hp <= 0) {
            sub.alive = false;
            addExplosion(sub.x, sub.y, 30, true);
            playBoom(true);
            score += 400;
          } else {
            addExplosion(b.x, b.y, 5, false);
          }
          bullets.splice(i, 1);
          break;
        }
      }
    }

    // Friendly bullets hit speedboats
    if (b.friendly) {
      for (const sb of speedboats) {
        if (!sb.alive) continue;
        if (Math.abs(b.x - sb.x) < 20 && Math.abs(b.y - sb.y) < 12) {
          sb.hp--;
          if (sb.hp <= 0) {
            sb.alive = false;
            addExplosion(sb.x, sb.y, 20, true);
            playBoom(false);
            score += 250;
          } else {
            addExplosion(b.x, b.y, 5, false);
          }
          bullets.splice(i, 1);
          break;
        }
      }
    }

    // Friendly bullets hit theme-specific entities
    if (b.friendly) {
      // Fuel tankers (cloud)
      for (const ft of fuelTankers) {
        if (!ft.alive) continue;
        if (Math.abs(b.x - ft.x) < 30 && Math.abs(b.y - ft.y) < 15) {
          ft.hp--;
          if (ft.hp <= 0) { ft.alive = false; addExplosion(ft.x, ft.y, 30, true); playBoom(true); score += 200; }
          else addExplosion(b.x, b.y, 5, false);
          bullets.splice(i, 1); break;
        }
      }
      // Tanks (normandy)
      for (const tank of tanks) {
        if (!tank.alive) continue;
        if (Math.abs(b.x - tank.x) < 15 && Math.abs(b.y - tank.y) < 12) {
          tank.hp--;
          if (tank.hp <= 0) { tank.alive = false; addExplosion(tank.x, tank.y, 25, true); playBoom(true); score += 350; }
          else addExplosion(b.x, b.y, 5, false);
          bullets.splice(i, 1); break;
        }
      }
      // Barrage balloons (normandy)
      for (const bb of barrageBalloons) {
        if (!bb.alive) continue;
        const swayOff = Math.sin(bb.sway * 0.5) * 5;
        if (Math.abs(b.x - (bb.x + swayOff)) < 12 && Math.abs(b.y - bb.y) < 18) {
          bb.hp--;
          if (bb.hp <= 0) { bb.alive = false; addExplosion(bb.x, bb.y, 15, true); score += 150; }
          else addExplosion(b.x, b.y, 5, false);
          bullets.splice(i, 1); break;
        }
      }
      // AA guns (forest ‚Äî only hittable when visible)
      for (const aa of aaGuns) {
        if (!aa.alive || aa.hidden) continue;
        if (Math.abs(b.x - aa.x) < 12 && Math.abs(b.y - aa.y) < 12) {
          aa.hp--;
          if (aa.hp <= 0) { aa.alive = false; addExplosion(aa.x, aa.y, 20, true); playBoom(false); score += 300; }
          else addExplosion(b.x, b.y, 5, false);
          bullets.splice(i, 1); break;
        }
      }
      // Trains (forest)
      for (const tr of trains) {
        if (!tr.alive) continue;
        const trainLen = tr.segments * (tr.segmentWidth + 3);
        const dir = tr.vx > 0 ? 1 : -1;
        if (b.x > tr.x - dir * trainLen - 15 && b.x < tr.x + 15 && Math.abs(b.y - tr.y) < 15) {
          tr.hp--;
          addExplosion(b.x, b.y, 8, false);
          if (tr.hp <= 0) { tr.alive = false; addExplosion(tr.x, tr.y, 30, true); playBoom(true); score += 600; }
          bullets.splice(i, 1); break;
        }
      }
      // Bats (cave)
      for (const bat of bats) {
        if (!bat.alive) continue;
        if (Math.abs(b.x - bat.x) < 8 && Math.abs(b.y - bat.y) < 8) {
          bat.alive = false; addExplosion(bat.x, bat.y, 5, false); score += 50;
          bullets.splice(i, 1); break;
        }
      }
    }

    // Enemy bullets hit player
    if (!b.friendly && player.invincible <= 0 && !player.burning) {
      if (Math.abs(b.x - player.x) < 18 && Math.abs(b.y - player.y) < 10) {
        damagePlayer(1);
        bullets.splice(i, 1);
        break;
      }
    }
  }
}

function updateBombs(dt) {
  for (let i = bombs.length - 1; i >= 0; i--) {
    const b = bombs[i];
    b.x += b.vx * dt;
    b.y += b.vy * dt;
    // Torpedoes travel horizontally at water surface ‚Äî no gravity
    if (!b.isTorpedo) {
      b.vy += PROJ_GRAVITY * dt;
    }
    b.life -= dt;

    // Despawn at world edges
    if (b.x < 0 || b.x >= WORLD_W) { bombs.splice(i, 1); continue; }

    let hit = false;

    // Building hit FIRST (only player/friendly bombs damage buildings)
    // Must check before ground hit since buildings sit on terrain
    if (b.friendly !== false) {
      for (const bld of buildings) {
        if (!bld.alive) continue;
        if (b.x > bld.x - 5 && b.x < bld.x + bld.w + 5 && b.y > bld.y - 5 && b.y < bld.y + bld.h + 5) {
          bld.hp -= 2;
          if (bld.hp <= 0) {
            bld.alive = false;
            score += buildingScores[bld.type] || 100;
            onBuildingDestroyed(bld);
          }
          hit = true;
          break;
        }
      }
    }

    // Player bombs hit submarines (hittable when not fully submerged)
    if (b.friendly !== false) {
      for (const sub of submarines) {
        if (!sub.alive || sub.phase === 'submerged') continue;
        if (Math.abs(b.x - sub.x) < 55 && Math.abs(b.y - sub.y) < 18) {
          sub.hp--;
          addExplosion(b.x, b.y, 15, false);
          if (sub.hp <= 0) {
            sub.alive = false;
            addExplosion(sub.x, sub.y, 40, true);
            playBoom(true);
            score += 800;
          }
          hit = true;
          break;
        }
      }
    }

    // Player bombs hit speedboats
    if (!hit && b.friendly !== false) {
      for (const sb of speedboats) {
        if (!sb.alive) continue;
        if (Math.abs(b.x - sb.x) < 25 && Math.abs(b.y - sb.y) < 15) {
          sb.alive = false;
          addExplosion(sb.x, sb.y, 25, true);
          playBoom(false);
          score += 500;
          hit = true;
          break;
        }
      }
    }

    // Player bombs hit theme-specific ground targets
    if (!hit && b.friendly !== false) {
      for (const tank of tanks) {
        if (!tank.alive) continue;
        if (Math.abs(b.x - tank.x) < 18 && Math.abs(b.y - tank.y) < 12) {
          tank.hp -= 2;
          if (tank.hp <= 0) { tank.alive = false; score += 350; }
          addExplosion(b.x, b.y, 20, true); playBoom(true); hit = true; break;
        }
      }
      if (!hit) for (const tr of trains) {
        if (!tr.alive) continue;
        const trainLen = tr.segments * (tr.segmentWidth + 3);
        const dir = tr.vx > 0 ? 1 : -1;
        if (b.x > tr.x - dir * trainLen - 15 && b.x < tr.x + 15 && Math.abs(b.y - tr.y) < 18) {
          tr.hp -= 3;
          if (tr.hp <= 0) { tr.alive = false; score += 600; }
          addExplosion(b.x, b.y, 20, true); playBoom(true); hit = true; break;
        }
      }
    }

    // Ceiling hit (cave theme)
    if (!hit && ceilingTerrain && b.y <= getCeilingY(b.x)) {
      hit = true;
    }

    // Ground hit (checked after buildings so bombs can hit structures on terrain)
    if (!hit && b.y >= getTerrainY(b.x)) {
      hit = true;
    }

    // Enemy bombs hit player
    if (b.friendly === false && player.invincible <= 0 && !player.burning && state === ST.PLAYING) {
      if (Math.abs(b.x - player.x) < 20 && Math.abs(b.y - player.y) < 15) {
        damagePlayer(2);
        bombs.splice(i, 1);
        continue;
      }
    }

    if (hit || b.life <= 0) {
      const isWater = waterLineY > 0 && getTerrainY(b.x) >= waterLineY - 5;
      if (isWater) {
        // Water splash ‚Äî no crater, water particles instead
        for (let s = 0; s < 8; s++) {
          addParticle(b.x + (Math.random() - 0.5) * 10, b.y,
            (Math.random() - 0.5) * 60, -40 - Math.random() * 60, 0.5,
            '#4af', 2 + Math.random());
        }
        addExplosion(b.x, b.y, 10, false);
      } else {
        addExplosion(b.x, b.y, 30, true);
        // Crater (skip in base territory)
        if (!isInBaseTerritory(b.x)) {
          for (let dx = -40; dx <= 40; dx++) {
            const ix = Math.floor(((b.x + dx) % WORLD_W + WORLD_W) % WORLD_W);
            if (ix >= 0 && ix < WORLD_W) {
              terrain[ix] += (40 - Math.abs(dx)) * 0.4;
            }
          }
        }
      }
      playBoom(true);
      bombs.splice(i, 1);
    }
  }
}

function updateDepthCharges(dt) {
  for (let i = depthCharges.length - 1; i >= 0; i--) {
    const dc = depthCharges[i];
    dc.x += dc.vx * dt;
    dc.vy += PROJ_GRAVITY * dt * 0.5; // slower gravity than bombs
    dc.y += dc.vy * dt;
    dc.life -= dt;
    dc.vx *= 0.98; // water drag

    // Track if we've entered water
    if (!dc.sinking && waterLineY > 0 && dc.y >= waterLineY) {
      dc.sinking = true;
      dc.vy = 40; // slow sinking speed in water
      dc.vx *= 0.3;
      // Water entry splash
      for (let s = 0; s < 6; s++) {
        addParticle(dc.x + (Math.random() - 0.5) * 8, waterLineY,
          (Math.random() - 0.5) * 40, -30 - Math.random() * 40, 0.4,
          '#4af', 1.5 + Math.random());
      }
    }

    // Underwater: constant slow sink, heavy drag
    if (dc.sinking) {
      dc.vy = 50; // steady sink rate
      dc.vx *= 0.95;
    }

    // Detonate on terrain contact or when deep enough
    let hit = false;
    if (dc.y >= getTerrainY(dc.x)) {
      hit = true;
    }

    if (hit || dc.life <= 0) {
      if (dc.sinking) {
        // ‚îÄ‚îÄ Spawn expanding shockwave that does real damage ‚îÄ‚îÄ
        shockwaves.push({
          x: dc.x, y: dc.y,
          radius: 10,
          maxRadius: 300,
          speed: 250,       // px/s expansion
          life: 1.2,
          maxLife: 1.2,
          damage: 4,        // max damage at epicenter
          hasDamaged: new Set() // track what we've already hit
        });

        // Initial flash at detonation point
        addExplosion(dc.x, dc.y, 12, true);

        // Bubble column rising to surface
        for (let b = 0; b < 20; b++) {
          addParticle(dc.x + (Math.random() - 0.5) * 30, dc.y + (Math.random() - 0.5) * 15,
            (Math.random() - 0.5) * 15, -50 - Math.random() * 70,
            0.5 + Math.random() * 0.8,
            Math.random() < 0.3 ? '#fff' : '#4af',
            2 + Math.random() * 2);
        }
      } else {
        addExplosion(dc.x, dc.y, 20, true);
      }
      playBoom(true);
      depthCharges.splice(i, 1);
    }
  }
}

function updateShockwaves(dt) {
  for (let i = shockwaves.length - 1; i >= 0; i--) {
    const sw = shockwaves[i];
    sw.radius += sw.speed * dt;
    sw.life -= dt;

    // Damage falloff: full damage at center, zero at maxRadius
    const damageMult = Math.max(0, 1 - sw.radius / sw.maxRadius);

    // Damage submarines at any depth
    for (const sub of submarines) {
      if (!sub.alive || sw.hasDamaged.has(sub)) continue;
      const dist = Math.sqrt((sub.x - sw.x) ** 2 + (sub.y - sw.y) ** 2);
      if (dist < sw.radius + 30) {
        sw.hasDamaged.add(sub);
        const dmg = Math.max(1, Math.round(sw.damage * damageMult));
        sub.hp -= dmg;
        addExplosion(sub.x, sub.y, 8, false);
        if (sub.hp <= 0) {
          sub.alive = false;
          addExplosion(sub.x, sub.y, 35, true);
          playBoom(true);
          score += 800;
        }
      }
    }

    // Damage speedboats
    for (const sb of speedboats) {
      if (!sb.alive || sw.hasDamaged.has(sb)) continue;
      const dist = Math.abs(sb.x - sw.x);
      if (dist < sw.radius + 15 && Math.abs(sb.y - sw.y) < 40) {
        sw.hasDamaged.add(sb);
        sb.alive = false;
        addExplosion(sb.x, sb.y, 20, true);
        playBoom(false);
        score += 250;
      }
    }

    // Surface eruption ‚Äî when the shockwave reaches the water surface
    if (sw.y - sw.radius <= waterLineY && sw.radius < sw.maxRadius) {
      // Water column and spray proportional to how fresh the wave is
      if (Math.random() < 0.5 * damageMult) {
        const surfX = sw.x + (Math.random() - 0.5) * sw.radius * 1.5;
        addParticle(surfX, waterLineY,
          (Math.random() - 0.5) * 60 * damageMult, -60 - Math.random() * 80 * damageMult,
          0.4 + Math.random() * 0.3,
          Math.random() < 0.4 ? '#fff' : '#8cf',
          2 + Math.random() * 3);
      }
    }

    if (sw.life <= 0 || sw.radius >= sw.maxRadius) {
      shockwaves.splice(i, 1);
    }
  }
}

function updateChaserEnemy(en, dt, playerSafe, turnRate, bulletSpeedMult) {
  let dx, dy, dist, desiredAngle;
  if (playerSafe) {
    // Stable patrol point based on parking slot, not current position
    const patrolX = 2000 + ((en.parkSlot || 0) * 1700) % (WORLD_W - 4000);
    const patrolY = 100 + ((en.parkSlot || 0) * 50) % 150;
    dx = patrolX - en.x;
    dy = patrolY - en.y;
    dist = Math.sqrt(dx * dx + dy * dy);
    desiredAngle = Math.atan2(dy, dx);
  } else {
    dx = player.x - en.x;
    dy = player.y - en.y;
    dist = Math.sqrt(dx * dx + dy * dy);
    desiredAngle = Math.atan2(dy, dx);
  }

  // Handle bird-strike stall for jets
  if (en.stalled && en.stallTimer > 0) {
    en.stallTimer -= dt;
    en.speed = 40; // drastically reduced
    en.angle += 0.3 * dt; // nose drops
    if (en.stallTimer <= 0) { en.stalled = false; en.speed = ENEMY_SPECS[en.type].speed; }
  }

  // ‚îÄ‚îÄ Terrain avoidance: override target if ground is close ‚îÄ‚îÄ
  const groundHere = getTerrainY(en.x);
  const lookAheadX = en.x + Math.cos(en.angle) * 80;
  const groundAhead = getTerrainY(((lookAheadX % WORLD_W) + WORLD_W) % WORLD_W);
  const terrainClearance = Math.min(groundHere - en.y, groundAhead - en.y);
  if (terrainClearance < 60) {
    // Pull up hard ‚Äî override desired angle to climb
    desiredAngle = -Math.PI / 2; // straight up
    if (terrainClearance < 30) {
      // Emergency: force upward immediately with boosted turn rate
      en.angle += (desiredAngle - en.angle > 0 ? 1 : -1) * turnRate * 3 * dt;
    }
  }

  let angleDiff = desiredAngle - en.angle;
  while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
  while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
  en.angle += Math.sign(angleDiff) * Math.min(Math.abs(angleDiff), turnRate * dt);

  const spd = en.stalled ? 40 : en.speed;
  en.vx = Math.cos(en.angle) * spd;
  en.vy = Math.sin(en.angle) * spd;
  en.x += en.vx * dt;
  en.y += en.vy * dt;

  const groundY = getTerrainY(en.x);
  if (en.y > groundY - 12) {
    // Crash into terrain ‚Äî enemy dies
    killEnemy(en);
    return 9999;
  }
  if (en.y < 30) en.y = 30;

  // Fire at player ‚Äî with accuracy spread
  const fireIntervalMult = enemyAccuracyDebuff > 0 ? 2 : 1;
  en.fireTimer--;
  if (en.fireTimer <= 0 && dist < 600 && !playerSafe) {
    const spread = (Math.random() - 0.5) * 0.25; // ¬±~7 degrees
    const fireAngle = en.angle + spread;
    const bvx = Math.cos(fireAngle) * BULLET_SPEED * bulletSpeedMult;
    const bvy = Math.sin(fireAngle) * BULLET_SPEED * bulletSpeedMult;
    bullets.push({ x: en.x + Math.cos(en.angle) * 20, y: en.y + Math.sin(en.angle) * 20, vx: bvx, vy: bvy, life: 1.0, friendly: false });
    en.fireTimer = (ENEMY_SPECS[en.type].fireInterval + Math.random() * 50 | 0) * fireIntervalMult;
  }

  return dist;
}

function updateBomberEnemy(en, dt, playerSafe) {
  // Flies toward player's base area at high altitude, drops bombs
  const targetX = playerSafe ? 6000 : baseX + BASE_WIDTH / 2;
  let targetY = 80 + Math.sin(Date.now() * 0.001 + en.x * 0.01) * 40;

  // Terrain avoidance for bombers
  const bGroundHere = getTerrainY(en.x);
  const bLookAhead = en.x + Math.cos(en.angle) * 100;
  const bGroundAhead = getTerrainY(((bLookAhead % WORLD_W) + WORLD_W) % WORLD_W);
  const bClearance = Math.min(bGroundHere - en.y, bGroundAhead - en.y);
  if (bClearance < 80) {
    targetY = Math.min(targetY, en.y - 40); // force climb
  }

  let dx = targetX - en.x;
  let dy = targetY - en.y;
  const dist = Math.sqrt(dx * dx + dy * dy);
  const desiredAngle = Math.atan2(dy, dx);

  let angleDiff = desiredAngle - en.angle;
  while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
  while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
  en.angle += Math.sign(angleDiff) * Math.min(Math.abs(angleDiff), 1.0 * dt); // Slower turn

  en.vx = Math.cos(en.angle) * en.speed;
  en.vy = Math.sin(en.angle) * en.speed;
  en.x += en.vx * dt;
  en.y += en.vy * dt;

  const groundY = getTerrainY(en.x);
  if (en.y > groundY - 12) {
    killEnemy(en);
    return 9999;
  }
  if (en.y < 50) en.y = 50;

  // Drop bombs when above base area or near player
  const fireIntervalMult = enemyAccuracyDebuff > 0 ? 2 : 1;
  en.fireTimer--;
  if (en.fireTimer <= 0 && !playerSafe) {
    const nearBase = Math.abs(en.x - baseX - BASE_WIDTH / 2) < 300;
    const nearPlayer = Math.abs(en.x - player.x) < 200;
    if (nearBase || nearPlayer) {
      bombs.push({ x: en.x, y: en.y + 10, vx: en.vx * 0.3, vy: 20, life: 5, friendly: false });
      en.fireTimer = (BOMBER_BOMB_INTERVAL + Math.random() * 40 | 0) * fireIntervalMult;
    }
  }

  // ‚îÄ‚îÄ Defensive turret guns (both sides) ‚Äî limited firing arc ‚îÄ‚îÄ
  if (!en.turretTimer) en.turretTimer = 0;
  en.turretTimer -= dt;
  if (en.turretTimer <= 0 && !playerSafe) {
    const tdx = player.x - en.x;
    const tdy = player.y - en.y;
    const tdist = Math.sqrt(tdx * tdx + tdy * tdy);
    if (tdist < 500) {
      const aimAngle = Math.atan2(tdy, tdx);
      // Relative angle from bomber's heading ‚Äî turrets can't fire forward or backward
      let relAngle = aimAngle - en.angle;
      while (relAngle > Math.PI) relAngle -= Math.PI * 2;
      while (relAngle < -Math.PI) relAngle += Math.PI * 2;
      const absRel = Math.abs(relAngle);
      // Turrets cover broadside arcs: ~30¬∞ to ~150¬∞ off the nose (no forward/rear fire)
      if (absRel > 0.5 && absRel < 2.6) {
        // Top turret fires when player is above or level
        if (relAngle < 0 || Math.abs(relAngle) > Math.PI * 0.5) {
          const spread1 = (Math.random() - 0.5) * 0.35;
          bullets.push({
            x: en.x + Math.sin(en.angle) * 12, y: en.y - Math.cos(en.angle) * 12,
            vx: Math.cos(aimAngle + spread1) * BULLET_SPEED * 0.6,
            vy: Math.sin(aimAngle + spread1) * BULLET_SPEED * 0.6,
            life: 0.7, friendly: false
          });
        }
        // Bottom turret fires when player is below or level
        if (relAngle > 0 || Math.abs(relAngle) > Math.PI * 0.5) {
          const spread2 = (Math.random() - 0.5) * 0.35;
          bullets.push({
            x: en.x - Math.sin(en.angle) * 12, y: en.y + Math.cos(en.angle) * 12,
            vx: Math.cos(aimAngle + spread2) * BULLET_SPEED * 0.6,
            vy: Math.sin(aimAngle + spread2) * BULLET_SPEED * 0.6,
            life: 0.7, friendly: false
          });
        }
        en.turretTimer = (0.45 + Math.random() * 0.3) * fireIntervalMult;
      }
    }
  }
  // Store turret aim angle for drawing
  if (!playerSafe && dist < 500) {
    en.turretAngle = Math.atan2(player.y - en.y, player.x - en.x);
  }

  return dist;
}

function updateZeppelinEnemy(en, dt) {
  // Patrols left-right slowly, drops bombs periodically
  en.x += en.patrolDir * en.speed * dt;
  // Cruise altitude ‚Äî rise gradually if below it (e.g. after takeoff)
  const cruiseY = 50 + Math.sin(Date.now() * 0.0005 + en.x * 0.001) * 30;
  if (en.y > cruiseY + 5) {
    en.y -= 30 * dt; // gentle ascent
  } else {
    en.y = cruiseY;
  }

  // Reverse at world edges
  if (en.x > WORLD_W - 500) en.patrolDir = -1;
  if (en.x < 500) en.patrolDir = 1;

  en.vx = en.patrolDir * en.speed;
  en.vy = 0;
  en.angle = en.patrolDir > 0 ? 0 : Math.PI;

  const groundY = getTerrainY(en.x);
  if (en.y > groundY - 80) en.y = groundY - 80;

  // Drop 3 bombs only when player is below or near player's home base
  const playerBelow = player.y > en.y && Math.abs(player.x - en.x) < 200;
  const nearPlayerBase = Math.abs(en.x - baseX - BASE_WIDTH / 2) < 300;
  const fireIntervalMult = enemyAccuracyDebuff > 0 ? 2 : 1;
  en.fireTimer--;
  if (en.fireTimer <= 0 && (playerBelow || nearPlayerBase)) {
    for (let k = -1; k <= 1; k++) {
      bombs.push({ x: en.x + k * 15, y: en.y + 20, vx: en.vx * 0.2 + k * 10, vy: 15, life: 6, friendly: false });
    }
    en.fireTimer = (ZEPPELIN_BOMB_INTERVAL + Math.random() * 30 | 0) * fireIntervalMult;
  }

  return Math.sqrt((player.x - en.x) ** 2 + (player.y - en.y) ** 2);
}

function updateEnemies(dt) {
  for (const en of enemies) {
    if (!en.alive) continue;

    // ‚îÄ‚îÄ Burning state: uncontrollable dive with fire/smoke ‚îÄ‚îÄ
    if (en.burning) {
      en.burnTimer -= dt;
      // Nose drops toward ground
      en.angle += (Math.PI * 0.3) * dt; // spiral down
      en.vy += 120 * dt; // gravity pull
      en.vx *= 0.98; // drag
      en.x += en.vx * dt;
      en.y += en.vy * dt;
      // Fire/smoke trail
      if (Math.random() < 0.6) {
        addParticle(en.x + (Math.random() - 0.5) * 10, en.y + (Math.random() - 0.5) * 10,
          (Math.random() - 0.5) * 30, -20 - Math.random() * 20, 0.4,
          Math.random() < 0.5 ? '#f80' : '#f44', 2 + Math.random());
      }
      if (Math.random() < 0.3) {
        addParticle(en.x + (Math.random() - 0.5) * 10, en.y,
          (Math.random() - 0.5) * 15, -10 - Math.random() * 15, 0.6, '#333', 3);
      }
      // Hit terrain/ceiling or timer expired: final explosion
      const burnGroundY = getTerrainY(en.x);
      const burnCeilY = ceilingTerrain ? getCeilingY(en.x) : -9999;
      if (en.y > burnGroundY - 8 || en.y < burnCeilY + 8 || en.burnTimer <= 0) {
        killEnemy(en);
      }
      continue;
    }

    // ‚îÄ‚îÄ Hangar state: hidden, waiting for launch ‚îÄ‚îÄ
    if (en.state === 'hangar') continue;

    // ‚îÄ‚îÄ Grounded state: on the strip, about to take off ‚îÄ‚îÄ
    if (en.state === 'grounded') {
      en.takeoffTimer -= dt;
      // Stay at airfield center ‚Äî enforce position and facing angle
      if (en.homeBase) {
        const stripX = en.homeBase.x + BASE_WIDTH / 2;
        const groundY = getTerrainY(stripX);
        en.y = groundY - 8;
        en.x = stripX;
        en.vx = 0; en.vy = 0;
        const facesRight = en.homeBase.x < WORLD_W / 2;
        en.angle = facesRight ? 0 : Math.PI;
      }
      if (en.takeoffTimer <= 0) {
        en.state = 'flying';
        en.landed = false;
        en.fuel = ENEMY_MAX_FUEL;
        // Launch upward and toward player base ‚Äî must clear terrain crash zone
        const towardPlayer = en.x < baseX ? -0.3 : (Math.PI + 0.3);
        en.angle = towardPlayer;
        en.y -= 40; // launch well above ground to clear crash threshold
        en.vx = Math.cos(en.angle) * en.speed;
        en.vy = -60; // strong upward launch
      }
      // Grounded enemies can still be hit ‚Äî fall through to collision checks
    }

    // ‚îÄ‚îÄ Flying or returning ‚îÄ‚îÄ
    if (en.state === 'flying' || en.state === 'returning') {
      const playerSafe = player.invincible > 0 || player.landed;
      let dist;

      // Consume fuel
      en.fuel -= dt * 20;

      // Switch to returning when fuel low
      if (en.fuel < 150 && en.state === 'flying') {
        en.state = 'returning';
      }

      // Returning enemies re-engage if player gets close
      if (en.state === 'returning' && en.fuel > 30) {
        const reEngageDist = Math.sqrt((player.x - en.x) ** 2 + (player.y - en.y) ** 2);
        if (reEngageDist < 400 && !player.landed && !player.invincible) {
          en.state = 'flying';
        }
      }

      if (en.state === 'returning' && en.homeBase) {
        // Fly back to home base
        const homeX = en.homeBase.x + en.homeBase.width / 2;
        const homeGroundY = getTerrainY(homeX);
        const horizDist = Math.abs(en.x - homeX);

        if (horizDist > 120) {
          // ‚îÄ‚îÄ Phase 1: Cruise toward base at safe altitude ‚îÄ‚îÄ
          const cruiseY = homeGroundY - 60;
          const dx = homeX - en.x;
          const dy = cruiseY - en.y;
          dist = Math.sqrt(dx * dx + dy * dy);
          const desiredAngle = Math.atan2(dy, dx);
          let angleDiff = desiredAngle - en.angle;
          while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
          while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
          en.angle += Math.sign(angleDiff) * Math.min(Math.abs(angleDiff), 2.5 * dt);
          en.vx = Math.cos(en.angle) * en.speed;
          en.vy = Math.sin(en.angle) * en.speed;
          en.x += en.vx * dt;
          en.y += en.vy * dt;
        } else {
          // ‚îÄ‚îÄ Phase 2: Final approach ‚Äî descend directly onto runway ‚îÄ‚îÄ
          const landingY = homeGroundY - 8;
          en.x += (homeX - en.x) * 2.0 * dt; // drift toward center
          en.y += (landingY - en.y) * 1.5 * dt; // descend to landing altitude
          en.vx = 0;
          en.vy = 0;
          const facesRight = en.homeBase.x < WORLD_W / 2;
          en.angle = facesRight ? 0 : Math.PI;
          dist = Math.abs(en.y - landingY);
        }

        // Terrain clamping ‚Äî away from base, crash on terrain contact
        const retGroundY = getTerrainY(en.x);
        if (horizDist > 120) {
          if (en.y > retGroundY - 12) {
            killEnemy(en);
            continue;
          }
        } else {
          if (en.y > retGroundY - 6) en.y = retGroundY - 6;
        }

        // Landing check ‚Äî close to runway and low enough
        const nearBase = horizDist < 30;
        if (nearBase && en.y >= homeGroundY - 12) {
          // Landed ‚Äî return to hangar and launch next plane
          en.state = 'hangar';
          en.landed = true;
          en.vx = 0; en.vy = 0;
          en.fuel = ENEMY_MAX_FUEL;
          en.hp = ENEMY_SPECS[en.type].hp; // repair in hangar
          launchNextFromBases();
          continue;
        }
      } else {
        // Normal combat behavior
        if (en.type === 'zeppelin') {
          dist = updateZeppelinEnemy(en, dt);
        } else if (en.type === 'bomber') {
          dist = updateBomberEnemy(en, dt, playerSafe);
        } else if (en.type === 'ace') {
          dist = updateChaserEnemy(en, dt, playerSafe, 2.0, 0.95);
        } else if (en.type === 'jet') {
          dist = updateChaserEnemy(en, dt, playerSafe, 1.6, 0.85);
        } else {
          dist = updateChaserEnemy(en, dt, playerSafe, 1.0, 0.7);
        }
      }

      // Clamp at world edges
      if (en.x < 50) { en.x = 50; en.vx = Math.abs(en.vx); en.angle = 0; }
      if (en.x >= WORLD_W - 50) { en.x = WORLD_W - 50; en.vx = -Math.abs(en.vx); en.angle = Math.PI; }

      // Engine trail (color per type)
      const trailColor = ENEMY_SPECS[en.type].color;
      addParticle(en.x - Math.cos(en.angle) * 18, en.y - Math.sin(en.angle) * 18, -en.vx * 0.05, -en.vy * 0.05, 0.15, trailColor, 1.5);

      // Bird strike check for jet enemies
      if (en.type === 'jet' && !en.stalled) {
        for (const bg of birds) {
          for (const bird of bg.flock) {
            if (!bird.alive) continue;
            if (Math.abs(bird.x - en.x) < 15 && Math.abs(bird.y - en.y) < 10) {
              bird.alive = false;
              addExplosion(bird.x, bird.y, 6, false);
              en.stalled = true;
              en.stallTimer = 3;
              en.speed = 40;
            }
          }
        }
      }
    }

    // Cave ceiling collision for enemies
    if (ceilingTerrain && (en.state === 'flying' || en.state === 'returning')) {
      const ceilY = getCeilingY(en.x);
      if (en.y < ceilY + 10) {
        startEnemyBurn(en);
      }
    }

    // Collision with player (both grounded and flying enemies)
    // Use velocity-compensated hitbox to prevent tunneling at high speeds
    if (!en.burning && player.invincible <= 0 && !player.burning && state === ST.PLAYING && !en.landed) {
      const spec = ENEMY_SPECS[en.type];
      const relVx = Math.abs(en.vx - player.vx);
      const relVy = Math.abs(en.vy - player.vy);
      const extraW = relVx * dt * 0.5;
      const extraH = relVy * dt * 0.5;
      if (Math.abs(en.x - player.x) < spec.hitW + 10 + extraW && Math.abs(en.y - player.y) < spec.hitH + 8 + extraH) {
        startEnemyBurn(en);
        damagePlayer(3); // Collision is devastating
      }
    }

    // Enemy planes crash into buildings
    if (en.alive && (en.state === 'flying' || en.state === 'returning')) {
      for (const bld of buildings) {
        if (!bld.alive) continue;
        if (en.x > bld.x - 10 && en.x < bld.x + bld.w + 10 &&
            en.y > bld.y - 5 && en.y < bld.y + bld.h + 5) {
          startEnemyBurn(en);
          bld.alive = false;
          addExplosion(bld.x + bld.w / 2, bld.y + bld.h / 2, 25, true);
          playBoom(true);
          onBuildingDestroyed(bld);
          break;
        }
      }
    }
  }
}

function updateFlak(dt) {
  // Buildings shoot flak
  for (const bld of buildings) {
    if (!bld.alive || (bld.type !== 'flak' && bld.type !== 'heavyBunker' && bld.type !== 'observation_tower')) continue;
    bld.flakTimer--;
    if (bld.flakTimer <= 0) {
      const dx = player.x - (bld.x + bld.w / 2);
      const dy = player.y - (bld.y);
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < 500) {
        // Large spread ‚Äî flak is inaccurate area suppression
        const spread = (Math.random() - 0.5) * 0.5; // ¬±~14 degrees
        const a = Math.atan2(dy, dx) + spread;
        flakShots.push({
          x: bld.x + bld.w / 2, y: bld.y,
          vx: Math.cos(a) * FLAK_SPEED, vy: Math.sin(a) * FLAK_SPEED,
          life: 1.5
        });
      }
      const interval = bld.type === 'heavyBunker' ? FLAK_INTERVAL * 0.6 : FLAK_INTERVAL;
      bld.flakTimer = interval + Math.random() * 40 | 0; // More random timing
    }
  }

  // Update flak shots
  for (let i = flakShots.length - 1; i >= 0; i--) {
    const f = flakShots[i];
    f.x += f.vx * dt;
    f.y += f.vy * dt;
    f.life -= dt;

    // Trail
    addParticle(f.x, f.y, 0, 0, 0.1, '#f80', 1);

    if (f.life <= 0) {
      // Burst
      addExplosion(f.x, f.y, 8, false);
      flakShots.splice(i, 1);
      continue;
    }

    // Hit player
    if (player.invincible <= 0 && !player.burning && state === ST.PLAYING) {
      if (Math.abs(f.x - player.x) < 20 && Math.abs(f.y - player.y) < 15) {
        damagePlayer(1);
        flakShots.splice(i, 1);
      }
    }
  }
}

function updateBirds(dt) {
  for (const bg of birds) {
    for (const b of bg.flock) {
      if (!b.alive) continue;
      b.x += bg.vx * dt;
      const sinAmp = bg.sinAmp || 4;
      const sinFreq = bg.sinFreq || 0.005;
      b.y += bg.vy * dt + Math.sin(Date.now() * sinFreq + b.x * 0.1) * (sinAmp * 0.1);

      // Keep birds above terrain
      const groundY = getTerrainY(b.x);
      if (b.y > groundY - 30) {
        b.y = groundY - 30;
        bg.vy = -8 - Math.random() * 5; // fixed gentle upward bounce
      }
      // Keep above top of screen
      if (b.y < 20) { b.y = 20; bg.vy = 3 + Math.random() * 3; }

      // Reverse direction at world edges
      if (b.x < 50) { b.x = 50; bg.vx = Math.abs(bg.vx); }
      if (b.x >= WORLD_W - 50) { b.x = WORLD_W - 50; bg.vx = -Math.abs(bg.vx); }

      // Collision with player
      if (player.invincible <= 0 && !player.burning && state === ST.PLAYING) {
        const hitRange = bg.type === 'eagle' ? 18 : bg.type === 'goose' ? 16 : 12;
        if (Math.abs(b.x - player.x) < hitRange && Math.abs(b.y - player.y) < 10) {
          b.alive = false;
          if (bg.type === 'sparrow') {
            // Sparrows: harmless ‚Äî big comedic feather explosion!
            const featherColors = ['#fff', '#eee', '#ddd', '#ccc', '#aaf', '#bbf', '#ffd', '#fec'];
            for (let k = 0; k < 35; k++) {
              const angle = Math.random() * Math.PI * 2;
              const speed = 20 + Math.random() * 80;
              const vx = Math.cos(angle) * speed + (player.vx || 0) * 0.3;
              const vy = Math.sin(angle) * speed - 15; // bias upward for poof effect
              const col = featherColors[Math.floor(Math.random() * featherColors.length)];
              addParticle(b.x + (Math.random()-0.5)*8, b.y + (Math.random()-0.5)*6, vx, vy, 0.8 + Math.random() * 0.6, col, 1.5 + Math.random() * 2);
            }
            // A few bigger slow-floating feathers
            for (let k = 0; k < 6; k++) {
              const col = Math.random() < 0.5 ? '#fff' : '#aaf';
              addParticle(b.x + (Math.random()-0.5)*12, b.y, (Math.random()-0.5)*30, -10 + Math.random()*20, 1.5 + Math.random(), col, 3 + Math.random() * 2);
            }
          } else {
            // Geese and eagles: damage, not instant kill
            addExplosion(b.x, b.y, 8, false);
            damagePlayer(1);
          }
        }
      }
    }
  }
}

function updateOxen(dt) {
  for (const o of oxen) {
    if (!o.alive) continue;
    o.x += o.dir * o.speed * dt;
    const ty = getTerrainY(o.x);
    o.y = ty - o.h;

    // Reverse at edges or randomly
    if (Math.random() < 0.005) o.dir *= -1;

    // Collision with player
    if (player.invincible <= 0 && !player.burning && state === ST.PLAYING) {
      if (player.x > o.x - 5 && player.x < o.x + o.w + 5 && player.y > o.y - 10 && player.y < o.y + o.h + 5) {
        o.alive = false;
        addExplosion(o.x + o.w / 2, o.y, 10, false);
        damagePlayer(2);
      }
    }
  }
}

function updateParticles(dt) {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.vy += 40 * dt;
    p.life -= dt;
    if (p.life <= 0) particles.splice(i, 1);
  }
}

function updateFleeingPeople(dt) {
  for (let i = fleeingPeople.length - 1; i >= 0; i--) {
    const p = fleeingPeople[i];
    p.x += p.dir * p.speed * dt;
    p.y = getTerrainY(p.x);
    p.frame += dt;
    p.life -= dt;
    if (p.life <= 0) fleeingPeople.splice(i, 1);
  }
}

function updateDragons(dt) {
  for (const d of dragons) {
    if (!d.alive) continue;
    d.wingFrame += dt * 5;

    if (d.phase === 'circling') {
      // Circle in the sky at mid-altitude
      d.x += d.vx * dt;
      d.y = 120 + Math.sin(Date.now() * 0.001 + d.x * 0.002) * 60;
      d.vx = 60 * Math.sign(d.vx);

      // Reverse at world edges
      if (d.x > WORLD_W - 400) d.vx = -60;
      if (d.x < 400) d.vx = 60;

      d.breathTimer -= dt;
      if (d.breathTimer <= 0) {
        d.phase = 'diving';
        d.diveTarget = { x: player.x, y: player.y };
      }
    } else if (d.phase === 'diving') {
      // Dive toward ground
      const dx = d.diveTarget.x - d.x;
      const dy = (getTerrainY(d.diveTarget.x) - 50) - d.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      d.vx = (dx / (dist || 1)) * 120;
      d.vy = (dy / (dist || 1)) * 120;
      d.x += d.vx * dt;
      d.y += d.vy * dt;

      if (dist < 80 || d.y > getTerrainY(d.x) - 40) {
        d.phase = 'breathing';
        d.breathTimer = 1.5;
      }
    } else if (d.phase === 'breathing') {
      // Fire breath: spawn fire particles
      d.vx *= 0.95;
      d.vy *= 0.95;
      d.x += d.vx * dt;
      d.y += d.vy * dt;

      // Spawn fire particles in a cone
      if (Math.random() < 0.4) {
        const facingLeft = d.vx < 0;
        const dir = facingLeft ? -1 : 1;
        const fx = d.x + dir * 30;
        const fy = d.y;
        addParticle(fx, fy, dir * (80 + Math.random() * 60), (Math.random() - 0.5) * 40, 0.5, Math.random() < 0.5 ? '#f80' : '#ff0', 3);
        // Check fire particle collision with player
        if (player.invincible <= 0 && !player.burning && state === ST.PLAYING) {
          if (Math.abs(fx - player.x) < 25 && Math.abs(fy - player.y) < 20) {
            damagePlayer(1);
          }
        }
      }

      d.breathTimer -= dt;
      if (d.breathTimer <= 0) {
        d.phase = 'circling';
        d.breathTimer = 5 + Math.random() * 5;
        d.vx = (Math.random() < 0.5 ? 1 : -1) * 60;
        d.vy = 0;
      }
    }

    // Keep above ground
    const groundY = getTerrainY(d.x);
    if (d.y > groundY - 30) d.y = groundY - 30;

    // Clamp at world edges
    if (d.x < 100) { d.x = 100; d.vx = Math.abs(d.vx); }
    if (d.x >= WORLD_W - 100) { d.x = WORLD_W - 100; d.vx = -Math.abs(d.vx); }

    // Collision with player (body)
    if (player.invincible <= 0 && !player.burning && state === ST.PLAYING) {
      if (Math.abs(d.x - player.x) < 25 && Math.abs(d.y - player.y) < 15) {
        damagePlayer(2);
      }
    }
  }
}

function checkLevelComplete() {
  const targets = buildings.filter(b => b.isTarget && b.alive);
  // Theme-specific targets
  const themeTgts = tanks.filter(t => t.alive).length +
    trains.filter(t => t.alive).length +
    aaGuns.filter(a => a.alive).length;
  if (targets.length === 0 && themeTgts === 0) {
    state = ST.LEVEL_COMPLETE;
    levelTimer = 3;
    score += 1000 * level;
    // Bonus life (max 9)
    if (lives < 9) {
      lives++;
      extraLifeMsg = 2.5; // show message timer
    }
  }
}

// ‚îÄ‚îÄ HUD update ‚îÄ‚îÄ
function getBarColor(pct) {
  if (pct > 50) return '#0f0';
  if (pct > 25) return '#ff0';
  return '#f22';
}
function updateHUD() {
  const p = player;

  // HP display
  const hpEl = document.getElementById('h-hp');
  let hpStr = '';
  for (let i = 0; i < PLAYER_MAX_HP; i++) hpStr += i < p.hp ? '\u25A0' : '\u25A1';
  hpEl.textContent = hpStr;
  hpEl.className = 'hud-val ' + (p.hp <= 1 ? 'red' : 'green');

  let livesStr = '';
  const maxDots = Math.max(5, lives);
  for (let i = 0; i < maxDots; i++) livesStr += i < lives ? '‚óè' : '‚óã';
  document.getElementById('h-lives').textContent = livesStr;

  // Fuel bar with color transitions and warning
  const fuelPct = Math.round(p.fuel / MAX_FUEL * 100);
  const fuelFill = document.getElementById('h-fuel');
  fuelFill.style.width = fuelPct + '%';
  fuelFill.style.background = `linear-gradient(90deg, ${getBarColor(fuelPct)}, ${fuelPct > 50 ? '#0ff' : getBarColor(fuelPct)})`;
  document.getElementById('h-fuel-pct').textContent = fuelPct + '%';
  const fuelBar = document.getElementById('fuel-bar-wrap');
  if (fuelPct < 20) fuelBar.classList.add('warning');
  else fuelBar.classList.remove('warning');

  // Ammo bar with color transitions and warning
  const ammoPct = Math.round(p.ammo / MAX_AMMO * 100);
  const ammoFill = document.getElementById('h-ammo');
  ammoFill.style.width = ammoPct + '%';
  ammoFill.style.background = `linear-gradient(90deg, ${getBarColor(ammoPct)}, ${ammoPct > 50 ? '#fa0' : getBarColor(ammoPct)})`;
  document.getElementById('h-ammo-pct').textContent = ammoPct + '%';
  const ammoBar = document.getElementById('ammo-bar-wrap');
  if (ammoPct < 15) ammoBar.classList.add('warning');
  else ammoBar.classList.remove('warning');

  // Bomb count with EMPTY indicator
  const bombEl = document.getElementById('h-bombs');
  if (p.bombCount <= 0) {
    bombEl.textContent = 'EMPTY';
    bombEl.classList.add('red');
    bombEl.classList.remove('green');
  } else {
    bombEl.textContent = p.bombCount;
    bombEl.classList.remove('red');
  }

  // Depth charge count ‚Äî only show on sea levels
  const dcWrap = document.getElementById('h-dc-wrap');
  const dcEl = document.getElementById('h-dc');
  if (waterLineY > 0) {
    dcWrap.style.display = '';
    if (p.depthCharges <= 0) {
      dcEl.textContent = 'EMPTY';
      dcEl.classList.add('red');
      dcEl.classList.remove('green');
    } else {
      dcEl.textContent = p.depthCharges;
      dcEl.classList.remove('red');
    }
  } else {
    dcWrap.style.display = 'none';
  }

  document.getElementById('h-score').textContent = String(score).padStart(6, '0');
  document.getElementById('h-level').textContent = level;
}

// ‚îÄ‚îÄ Draw ‚îÄ‚îÄ
function draw() {
  const W = canvas.width;
  const H = canvas.height;

  // Clear
  ctx.fillStyle = '#0a0a0f';
  ctx.fillRect(0, 0, W, H);

  if (state === ST.TITLE) {
    drawTitle(W, H);
    drawRadarEmpty();
    return;
  }

  // Stars
  ctx.fillStyle = '#fff';
  for (const s of stars) {
    const sx = ((s.x - camX * 0.3) % W + W) % W;
    const sy = s.y - camY * 0.1;
    if (sy < 0 || sy > H) continue;
    const flicker = s.b + Math.sin(Date.now() * 0.003 + s.x) * 0.1;
    ctx.globalAlpha = flicker;
    ctx.fillRect(sx, sy, s.s, s.s);
  }
  ctx.globalAlpha = 1;

  // ‚îÄ‚îÄ World drawing (offset by camera) ‚îÄ‚îÄ
  ctx.save();
  ctx.translate(-camX, -camY);

  // Terrain
  drawTerrain(W, H);

  // Home base
  drawBase();
  drawSearchlights();

  // Enemy airfields
  drawEnemyBases();

  // Buildings
  for (const bld of buildings) {
    if (!bld.alive) continue;
    const screenX = bld.x - camX;
    if (screenX < -100 || screenX > W + 100) continue;
    drawBuilding(bld);
  }

  // Animals (oxen, sheep, horses, camels)
  for (const o of oxen) {
    if (!o.alive) continue;
    const screenX = o.x - camX;
    if (screenX < -50 || screenX > W + 50) continue;
    drawAnimal(o);
  }

  // Fleeing people
  for (const p of fleeingPeople) {
    const screenX = p.x - camX;
    if (screenX < -50 || screenX > W + 50) continue;
    drawPerson(p);
  }

  // Birds (per-type rendering)
  for (const bg of birds) {
    for (const b of bg.flock) {
      if (!b.alive) continue;
      const screenX = b.x - camX;
      if (screenX < -50 || screenX > W + 50) continue;

      if (bg.type === 'eagle') {
        // Majestic eagle with visible body, tail feathers, hooked beak
        const col = '#c84';
        const t = Date.now() * 0.003 + b.x;
        const wing = Math.sin(t) * 6;
        const soar = Math.cos(t * 0.7) * 2; // gentle body bob
        // Danger aura ‚Äî pulsing red glow
        const dangerPulse = 0.25 + Math.sin(Date.now() * 0.006) * 0.15;
        ctx.fillStyle = `rgba(255, 40, 40, ${dangerPulse})`;
        ctx.beginPath();
        ctx.arc(b.x, b.y + soar, 14, 0, Math.PI * 2);
        ctx.fill();
        neonGlow(ctx, col, 6);
        ctx.strokeStyle = col;
        ctx.lineWidth = 2;
        // Wings with feathered tips
        ctx.beginPath();
        ctx.moveTo(b.x - 18, b.y + wing);
        ctx.lineTo(b.x - 12, b.y + wing * 0.6);
        ctx.lineTo(b.x - 5, b.y + wing * 0.2);
        ctx.lineTo(b.x, b.y + soar);
        ctx.lineTo(b.x + 5, b.y + wing * 0.2);
        ctx.lineTo(b.x + 12, b.y + wing * 0.6);
        ctx.lineTo(b.x + 18, b.y + wing);
        ctx.stroke();
        // Wingtip feathers
        ctx.lineWidth = 1;
        for (let f = -1; f <= 1; f += 2) {
          ctx.beginPath();
          ctx.moveTo(b.x + f * 16, b.y + wing * 0.8);
          ctx.lineTo(b.x + f * 19, b.y + wing + 2);
          ctx.moveTo(b.x + f * 17, b.y + wing * 0.9);
          ctx.lineTo(b.x + f * 20, b.y + wing + 1);
          ctx.stroke();
        }
        // Body
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.ellipse(b.x, b.y + soar, 5, 2.5, 0, 0, Math.PI * 2);
        ctx.stroke();
        // Head with hooked beak
        ctx.fillStyle = '#fa8';
        ctx.beginPath();
        ctx.arc(b.x - 7, b.y + soar - 1, 2.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#ff0';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(b.x - 9, b.y + soar - 1);
        ctx.lineTo(b.x - 12, b.y + soar);
        ctx.lineTo(b.x - 11, b.y + soar + 1);
        ctx.stroke();
        // Eye
        ctx.fillStyle = '#ff0';
        ctx.beginPath();
        ctx.arc(b.x - 7, b.y + soar - 1.5, 0.8, 0, Math.PI * 2);
        ctx.fill();
        // Tail feathers
        ctx.strokeStyle = col;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(b.x + 5, b.y + soar);
        ctx.lineTo(b.x + 10, b.y + soar + 2);
        ctx.moveTo(b.x + 5, b.y + soar + 1);
        ctx.lineTo(b.x + 11, b.y + soar + 3);
        ctx.moveTo(b.x + 5, b.y + soar - 1);
        ctx.lineTo(b.x + 10, b.y + soar);
        ctx.stroke();
        clearGlow(ctx);
      } else if (bg.type === 'goose') {
        // Goose with stretched neck and rounded body
        const col = '#dda';
        const t = Date.now() * 0.007 + b.x * 0.5;
        const wing = Math.sin(t) * 6;
        // Danger aura ‚Äî pulsing red glow
        const dangerPulse = 0.2 + Math.sin(Date.now() * 0.006 + 1) * 0.12;
        ctx.fillStyle = `rgba(255, 40, 40, ${dangerPulse})`;
        ctx.beginPath();
        ctx.arc(b.x, b.y, 10, 0, Math.PI * 2);
        ctx.fill();
        neonGlow(ctx, col, 4);
        ctx.strokeStyle = col;
        ctx.lineWidth = 1.5;
        // Wings
        ctx.beginPath();
        ctx.moveTo(b.x - 10, b.y + wing);
        ctx.quadraticCurveTo(b.x - 5, b.y + wing * 0.3, b.x, b.y);
        ctx.quadraticCurveTo(b.x + 5, b.y + wing * 0.3, b.x + 10, b.y + wing);
        ctx.stroke();
        // Body (oval)
        ctx.beginPath();
        ctx.ellipse(b.x, b.y + 1, 4, 2, 0, 0, Math.PI * 2);
        ctx.stroke();
        // Long neck stretching forward
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(b.x - 3, b.y);
        ctx.quadraticCurveTo(b.x - 6, b.y - 3, b.x - 9, b.y - 2);
        ctx.stroke();
        // Head
        ctx.fillStyle = '#333';
        ctx.beginPath();
        ctx.arc(b.x - 9, b.y - 2, 1.5, 0, Math.PI * 2);
        ctx.fill();
        // Beak
        ctx.strokeStyle = '#fa0';
        ctx.beginPath();
        ctx.moveTo(b.x - 10.5, b.y - 2);
        ctx.lineTo(b.x - 13, b.y - 1.5);
        ctx.stroke();
        clearGlow(ctx);
      } else {
        // Sparrows: small, chirpy with visible body and quick wingbeats
        const col = '#aaf';
        const t = Date.now() * 0.015 + b.x;
        const wing = Math.sin(t) * 4;
        neonGlow(ctx, col, 3);
        ctx.strokeStyle = col;
        ctx.lineWidth = 1;
        // Quick fluttering wings
        ctx.beginPath();
        ctx.moveTo(b.x - 6, b.y + wing);
        ctx.lineTo(b.x - 2, b.y);
        ctx.lineTo(b.x + 2, b.y);
        ctx.lineTo(b.x + 6, b.y + wing);
        ctx.stroke();
        // Round little body
        ctx.fillStyle = col;
        ctx.globalAlpha = 0.5;
        ctx.beginPath();
        ctx.arc(b.x, b.y + 0.5, 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
        // Tail
        ctx.beginPath();
        ctx.moveTo(b.x + 2, b.y + 1);
        ctx.lineTo(b.x + 5, b.y + 2);
        ctx.stroke();
        clearGlow(ctx);
      }
    }
  }

  // Dragons
  for (const d of dragons) {
    if (!d.alive) continue;
    const screenX = d.x - camX;
    if (screenX < -100 || screenX > W + 100) continue;
    drawDragon(ctx, d);
  }

  // Submarines
  for (const sub of submarines) {
    if (!sub.alive) continue;
    const screenX = sub.x - camX;
    if (screenX < -80 || screenX > W + 80) continue;
    drawSubmarine(sub);
  }

  // Speedboats
  for (const sb of speedboats) {
    if (!sb.alive) continue;
    const screenX = sb.x - camX;
    if (screenX < -60 || screenX > W + 60) continue;
    drawSpeedboat(sb);
  }

  // Theme-specific entities
  const drawTheme = getLevelTheme(level);
  if (drawTheme === 'cloud') drawFuelTankers();
  if (drawTheme === 'cave') { drawBats(); drawCaveTurrets(); }
  if (drawTheme === 'normandy') { drawTanks(); drawBarrageBalloons(); }
  if (drawTheme === 'forest') { drawAAGuns(); drawTrains(); }

  // Bombs & Torpedoes
  for (const b of bombs) {
    const screenX = b.x - camX;
    if (screenX < -50 || screenX > W + 50) continue;
    if (b.isTorpedo) {
      // Torpedo: elongated shape traveling horizontally at water surface
      neonGlow(ctx, '#f55', 6);
      ctx.strokeStyle = '#f55';
      ctx.lineWidth = 1.5;
      const dir = b.vx > 0 ? 1 : -1;
      ctx.beginPath();
      ctx.moveTo(b.x - dir * 8, b.y);
      ctx.lineTo(b.x + dir * 8, b.y);
      ctx.lineTo(b.x + dir * 10, b.y - 1);
      ctx.stroke();
      // Wake trail
      addParticle(b.x - dir * 10, b.y, -dir * 15, (Math.random() - 0.5) * 5, 0.2, '#fff', 1);
      clearGlow(ctx);
    } else {
      const bombCol = b.friendly === false ? '#f55' : '#fa0';
      neonGlow(ctx, bombCol, 6);
      ctx.fillStyle = bombCol;
      ctx.beginPath();
      ctx.arc(b.x, b.y, 4, 0, Math.PI * 2);
      ctx.fill();
      clearGlow(ctx);
      addParticle(b.x, b.y - 2, 0, -10, 0.15, b.friendly === false ? '#f55' : '#f80', 1);
    }
  }

  // Depth charges
  for (const dc of depthCharges) {
    const screenX = dc.x - camX;
    if (screenX < -50 || screenX > W + 50) continue;
    const dcCol = dc.sinking ? '#48f' : '#aaf';
    neonGlow(ctx, dcCol, 5);
    ctx.fillStyle = dcCol;
    ctx.beginPath();
    // Barrel shape ‚Äî rounded rectangle
    ctx.arc(dc.x, dc.y, 5, 0, Math.PI * 2);
    ctx.fill();
    // Ring detail
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(dc.x - 5, dc.y);
    ctx.lineTo(dc.x + 5, dc.y);
    ctx.stroke();
    clearGlow(ctx);
    // Bubble trail when sinking
    if (dc.sinking && Math.random() < 0.3) {
      addParticle(dc.x + (Math.random() - 0.5) * 6, dc.y - 5,
        (Math.random() - 0.5) * 5, -15 - Math.random() * 10, 0.3, '#4af', 1.5);
    }
  }

  // Underwater shockwaves ‚Äî visible expanding pressure rings
  for (const sw of shockwaves) {
    const screenX = sw.x - camX;
    if (screenX < -sw.radius - 50 || screenX > W + sw.radius + 50) continue;
    const progress = 1 - sw.life / sw.maxLife; // 0 ‚Üí 1
    const alpha = Math.max(0, 0.7 * (1 - progress));

    ctx.save();

    // Clip to below water surface so rings don't show above water
    ctx.beginPath();
    ctx.rect(camX > 0 ? 0 : -camX, waterLineY, W + 200, 600);
    ctx.clip();

    // Outer shockwave ring ‚Äî bright, visible pressure front
    ctx.strokeStyle = `rgba(120, 200, 255, ${alpha})`;
    ctx.lineWidth = 3 + (1 - progress) * 4; // thicker when fresh
    ctx.beginPath();
    ctx.arc(sw.x, sw.y, sw.radius, 0, Math.PI * 2);
    ctx.stroke();

    // Secondary inner ring ‚Äî slightly behind
    if (sw.radius > 30) {
      ctx.strokeStyle = `rgba(180, 220, 255, ${alpha * 0.6})`;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(sw.x, sw.y, sw.radius * 0.7, 0, Math.PI * 2);
      ctx.stroke();
    }

    // Third faint ring
    if (sw.radius > 60) {
      ctx.strokeStyle = `rgba(80, 150, 220, ${alpha * 0.3})`;
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.arc(sw.x, sw.y, sw.radius * 0.4, 0, Math.PI * 2);
      ctx.stroke();
    }

    // Glow fill inside the wavefront ‚Äî fading disturbance
    const grad = ctx.createRadialGradient(sw.x, sw.y, 0, sw.x, sw.y, sw.radius);
    grad.addColorStop(0, `rgba(150, 210, 255, ${alpha * 0.15})`);
    grad.addColorStop(0.6, `rgba(80, 160, 230, ${alpha * 0.08})`);
    grad.addColorStop(1, 'rgba(80, 160, 230, 0)');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(sw.x, sw.y, sw.radius, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();

    // Disturbance at the water surface where the ring intersects
    if (sw.radius > Math.abs(sw.y - waterLineY)) {
      // Calculate where the ring circle intersects the waterline
      const dy = waterLineY - sw.y;
      const intersectHalf = Math.sqrt(Math.max(0, sw.radius * sw.radius - dy * dy));
      const surfAlpha = alpha * 0.8;

      // Churning water line at intersection points
      for (let side = -1; side <= 1; side += 2) {
        const ix = sw.x + side * intersectHalf;
        ctx.strokeStyle = `rgba(200, 235, 255, ${surfAlpha})`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(ix - 8, waterLineY);
        ctx.quadraticCurveTo(ix, waterLineY - 6 * (1 - progress), ix + 8, waterLineY);
        ctx.stroke();
      }

      // Foam/spray along the surface between intersection points
      if (Math.random() < 0.4 * (1 - progress)) {
        const sprayX = sw.x + (Math.random() - 0.5) * intersectHalf * 2;
        addParticle(sprayX, waterLineY,
          (Math.random() - 0.5) * 40, -20 - Math.random() * 50 * (1 - progress),
          0.3 + Math.random() * 0.2,
          Math.random() < 0.3 ? '#fff' : '#8cf',
          2 + Math.random() * 2);
      }
    }
  }

  // Flak shots
  for (const f of flakShots) {
    neonGlow(ctx, '#f80', 6);
    ctx.fillStyle = '#ff0';
    ctx.beginPath();
    ctx.arc(f.x, f.y, 3, 0, Math.PI * 2);
    ctx.fill();
    clearGlow(ctx);
  }

  // Bullets
  for (const b of bullets) {
    const screenX = b.x - camX;
    if (screenX < -50 || screenX > W + 50) continue;
    const col = b.friendly ? '#0ff' : '#f55';
    neonGlow(ctx, col, 4);
    ctx.fillStyle = col;
    ctx.beginPath();
    ctx.arc(b.x, b.y, 2, 0, Math.PI * 2);
    ctx.fill();
    clearGlow(ctx);
  }

  // Enemies (dispatch by type)
  // Enemies ‚Äî compute facingLeft from angle to prevent upside-down rendering
  for (const en of enemies) {
    if (!en.alive || en.state === 'hangar') continue;
    const screenX = en.x - camX;
    const margin = en.type === 'zeppelin' ? 150 : 100;
    if (screenX < -margin || screenX > W + margin) continue;
    const spec = ENEMY_SPECS[en.type];
    // Normalize angle to [-PI, PI]
    let a = en.angle;
    while (a > Math.PI) a -= Math.PI * 2;
    while (a < -Math.PI) a += Math.PI * 2;
    // If flying left (angle > 90¬∞ or < -90¬∞), flip horizontally and mirror the rotation
    const flyingLeft = Math.abs(a) > Math.PI / 2;
    const drawAngle = flyingLeft ? (a > 0 ? a - Math.PI : a + Math.PI) : a;
    const drawColor = en.burning ? '#f44' : spec.color;
    if (en.type === 'jet') {
      drawJet(ctx, en.x, en.y, drawAngle, flyingLeft, drawColor);
    } else if (en.type === 'bomber') {
      drawBomber(ctx, en.x, en.y, drawAngle, flyingLeft, drawColor);
    } else if (en.type === 'zeppelin') {
      drawZeppelin(ctx, en.x, en.y, drawAngle, flyingLeft, drawColor);
    } else {
      drawBiplane(ctx, en.x, en.y, drawAngle, flyingLeft, drawColor, undefined, false);
    }
  }

  // Player
  if (state === ST.PLAYING) {
    if (player.invincible <= 0 || Math.sin(Date.now() * 0.02) > 0) {
      // Same approach as enemies: extract facingLeft from radian angle, mirror rotation
      let pRad = getPlaneRadians(player);
      while (pRad > Math.PI) pRad -= Math.PI * 2;
      while (pRad < -Math.PI) pRad += Math.PI * 2;
      const pFacingLeft = Math.abs(pRad) > Math.PI / 2;
      const pDrawAngle = pFacingLeft ? (pRad > 0 ? pRad - Math.PI : pRad + Math.PI) : pRad;
      // Color changes with damage: cyan ‚Üí yellow ‚Üí red ‚Üí burning
      let pColor = '#0ff';
      if (player.burning && player.engineOut) pColor = '#888';
      else if (player.burning) pColor = '#f44';
      else if (player.hp === 2) pColor = '#ff0';
      else if (player.hp <= 1) pColor = '#f80';
      // Low fuel flashing ‚Äî red pulse when below 15%
      const fuelRatio = player.fuel / MAX_FUEL;
      if (!player.burning && fuelRatio < 0.15 && fuelRatio > 0) {
        if (Math.sin(Date.now() * 0.01) > 0) pColor = '#f22';
      }
      // Hit flash override
      if (player.hitFlash > 0) pColor = '#fff';
      drawBiplane(ctx, player.x, player.y, pDrawAngle, pFacingLeft, pColor, undefined, player.orient);
    }
  }

  // Parachutes
  for (const chute of parachutes) {
    const screenX = chute.x - camX;
    if (screenX < -50 || screenX > W + 50) continue;
    if (chute.deployed && !chute.landed) {
      // Draw parachute canopy
      neonGlow(ctx, '#fff', 6);
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(chute.x, chute.y - 12, 8, Math.PI, 0);
      ctx.stroke();
      // Suspension lines
      ctx.beginPath();
      ctx.moveTo(chute.x - 7, chute.y - 10);
      ctx.lineTo(chute.x, chute.y);
      ctx.moveTo(chute.x + 7, chute.y - 10);
      ctx.lineTo(chute.x, chute.y);
      ctx.stroke();
      clearGlow(ctx);
    }
    // Pilot figure (tiny stick person)
    neonGlow(ctx, '#0ff', 4);
    ctx.strokeStyle = '#0ff';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(chute.x, chute.y - 3, 2, 0, Math.PI * 2); // head
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(chute.x, chute.y - 1);
    ctx.lineTo(chute.x, chute.y + 4); // body
    ctx.moveTo(chute.x - 3, chute.y + 1);
    ctx.lineTo(chute.x + 3, chute.y + 1); // arms
    if (chute.landed) {
      ctx.moveTo(chute.x, chute.y + 4);
      ctx.lineTo(chute.x - 2, chute.y + 7); // legs standing
      ctx.moveTo(chute.x, chute.y + 4);
      ctx.lineTo(chute.x + 2, chute.y + 7);
    } else {
      ctx.moveTo(chute.x, chute.y + 4);
      ctx.lineTo(chute.x - 3, chute.y + 7); // legs dangling
      ctx.moveTo(chute.x, chute.y + 4);
      ctx.lineTo(chute.x + 3, chute.y + 7);
    }
    ctx.stroke();
    clearGlow(ctx);
  }

  // Particles
  for (const p of particles) {
    const alpha = p.life / p.maxLife;
    ctx.globalAlpha = alpha;
    ctx.fillStyle = p.color;
    neonGlow(ctx, p.color, 4);
    ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
    clearGlow(ctx);
  }
  ctx.globalAlpha = 1;

  ctx.restore();

  // ‚îÄ‚îÄ Overlays ‚îÄ‚îÄ
  if (state === ST.DYING) {
    ctx.fillStyle = `rgba(255, 50, 0, ${0.3 * (deathTimer / 2)})`;
    ctx.fillRect(0, 0, W, H);
    ctx.fillStyle = '#fff';
    ctx.font = '24px "Courier New", monospace';
    ctx.textAlign = 'center';
    ctx.fillText(lives > 0 ? 'PLANE DESTROYED' : 'GAME OVER', W / 2, H / 2);
  }

  if (state === ST.GAME_OVER) {
    ctx.fillStyle = 'rgba(0,0,0,0.7)';
    ctx.fillRect(0, 0, W, H);
    neonGlow(ctx, '#f55', 12);
    ctx.fillStyle = '#f55';
    ctx.font = 'bold 36px "Courier New", monospace';
    ctx.textAlign = 'center';
    ctx.fillText('GAME OVER', W / 2, H / 2 - 50);
    clearGlow(ctx);
    ctx.fillStyle = '#888';
    ctx.font = '16px "Courier New", monospace';
    ctx.fillText(`FINAL SCORE: ${score}`, W / 2, H / 2 - 20);

    // Medals earned this game
    if (earnedMedals.size > 0) {
      ctx.font = '11px "Courier New", monospace';
      ctx.fillStyle = '#aa8';
      ctx.fillText('MEDALS EARNED:', W / 2, H / 2 + 10);
      let mx = 0;
      for (const key of earnedMedals) {
        const m = MEDALS[key];
        neonGlow(ctx, m.color, 6);
        ctx.fillStyle = m.color;
        ctx.font = '10px "Courier New", monospace';
        ctx.fillText(`${m.icon} ${m.name}`, W / 2, H / 2 + 28 + mx * 15);
        mx++;
      }
      clearGlow(ctx);
    }

    const btnY = earnedMedals.size > 0 ? H / 2 + 35 + earnedMedals.size * 15 : H / 2 + 20;
    ctx.fillStyle = '#888';
    ctx.font = '16px "Courier New", monospace';
    ctx.fillText('Press ENTER to restart from Level 1', W / 2, btnY);
    if (highestLevel > 1) {
      neonGlow(ctx, '#0ff', 6);
      ctx.fillStyle = '#0ff';
      ctx.fillText(`Press C to continue from Level ${highestLevel}`, W / 2, btnY + 25);
      clearGlow(ctx);
    }
  }

  if (state === ST.LEVEL_COMPLETE) {
    neonGlow(ctx, '#0f0', 12);
    ctx.fillStyle = '#0f0';
    ctx.font = 'bold 30px "Courier New", monospace';
    ctx.textAlign = 'center';
    ctx.fillText(`LEVEL ${level} COMPLETE!`, W / 2, H / 2 - 10);
    clearGlow(ctx);
    ctx.fillStyle = '#0ff';
    ctx.font = '16px "Courier New", monospace';
    ctx.fillText(`+${1000 * level} bonus points`, W / 2, H / 2 + 20);
  }

  // ‚îÄ‚îÄ Extra life / last chance messages ‚îÄ‚îÄ
  if (extraLifeMsg > 0) {
    extraLifeMsg -= 0.016;
    const alpha = Math.min(1, extraLifeMsg / 0.5);
    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    neonGlow(ctx, '#0f0', 10);
    ctx.fillStyle = `rgba(0, 255, 0, ${alpha})`;
    ctx.font = 'bold 22px "Courier New", monospace';
    ctx.textAlign = 'center';
    ctx.fillText('+1 LIFE!', W / 2, H / 2 + 50);
    clearGlow(ctx);
    ctx.restore();
  }
  if (lastChanceMsg > 0) {
    lastChanceMsg -= 0.016;
    const alpha = Math.min(1, lastChanceMsg / 0.5);
    const flash = Math.sin(Date.now() * 0.01) > 0 ? 1 : 0.4;
    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    neonGlow(ctx, '#f22', 14);
    ctx.fillStyle = `rgba(255, 40, 40, ${alpha * flash})`;
    ctx.font = 'bold 28px "Courier New", monospace';
    ctx.textAlign = 'center';
    ctx.fillText('LAST CHANCE', W / 2, H / 2);
    clearGlow(ctx);
    ctx.restore();
  }

  // Medal popup
  if (medalPopup) {
    medalPopup.timer -= 0.016;
    if (medalPopup.timer <= 0) { medalPopup = null; }
    else {
      const m = MEDALS[medalPopup.medal];
      const alpha = Math.min(1, medalPopup.timer / 0.5);
      ctx.save();
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      neonGlow(ctx, m.color, 10);
      ctx.fillStyle = m.color;
      ctx.globalAlpha = alpha;
      ctx.font = 'bold 14px "Courier New", monospace';
      ctx.textAlign = 'center';
      ctx.fillText(`${m.icon} ${m.name} ${m.icon}`, W / 2, 40);
      ctx.font = '10px "Courier New", monospace';
      ctx.fillText(m.desc, W / 2, 55);
      ctx.globalAlpha = 1;
      clearGlow(ctx);
      ctx.restore();
    }
  }

  // Wounded HUD indicator
  if (player.wounded && !player.burning && state === ST.PLAYING) {
    const flash = Math.sin(Date.now() * 0.008) > 0 ? 0.8 : 0.4;
    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.fillStyle = `rgba(255, 100, 0, ${flash})`;
    ctx.font = 'bold 11px "Courier New", monospace';
    ctx.textAlign = 'center';
    ctx.fillText('WOUNDED', W / 2, H - 50);
    ctx.restore();
  }

  // Docking HUD for fuel tankers
  if (fuelTankers.some(ft => ft.alive && ft.docking)) {
    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    const ft = fuelTankers.find(ft => ft.alive && ft.docking);
    if (ft) {
      const barW = 120, barH = 10;
      const bx = W / 2 - barW / 2, by = 60;
      neonGlow(ctx, '#0af', 6);
      ctx.strokeStyle = '#0af';
      ctx.lineWidth = 1;
      ctx.strokeRect(bx, by, barW, barH);
      ctx.fillStyle = ft.dockingProgress >= 1 ? '#0f0' : '#0af';
      ctx.fillRect(bx, by, barW * ft.dockingProgress, barH);
      ctx.fillStyle = '#fff';
      ctx.font = '10px "Courier New", monospace';
      ctx.textAlign = 'center';
      ctx.fillText(ft.dockingProgress >= 1 ? 'REFUELING...' : 'DOCKING ' + Math.floor(ft.dockingProgress * 100) + '%', W / 2, by - 4);
      clearGlow(ctx);
    }
    ctx.restore();
  }

  // Top strip radar
  drawRadar();

  // Circular radar scope (HUD overlay)
  if (state === ST.PLAYING || state === ST.LEVEL_COMPLETE) {
    drawRadarScope(W, H);
    drawCockpitGauges(W, H);
  }

  // Version tag ‚Äî bottom left
  ctx.save();
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.fillStyle = 'rgba(0, 255, 255, 0.5)';
  ctx.font = '12px "Courier New", monospace';
  ctx.textAlign = 'left';
  ctx.fillText('v' + GAME_VERSION, 8, canvas.height - 8);
  ctx.restore();
}

function drawTerrain(W, H) {
  const startX = Math.max(0, Math.floor(camX) - 2);
  const endX = Math.min(WORLD_W - 1, Math.floor(camX + W) + 2);
  const terrainBottom = camY + H + 50;
  const theme = getLevelTheme(level);
  const tc = THEME_CONFIG[theme];
  const hasWater = tc.hasWater === true || tc.hasWater === 'partial';

  // Filled terrain
  ctx.fillStyle = tc.bg;
  ctx.beginPath();
  ctx.moveTo(startX, terrainBottom);
  for (let x = startX; x <= endX; x += 2) {
    let ty = terrain[x];
    if (hasWater && ty >= waterLineY - 5) {
      ty += Math.sin(Date.now() * 0.003 + x * 0.02) * 2 + Math.sin(Date.now() * 0.005 + x * 0.04) * 1;
    }
    ctx.lineTo(x, ty);
  }
  ctx.lineTo(endX, terrainBottom);
  ctx.closePath();
  ctx.fill();

  // Theme-specific terrain rendering
  if (hasWater) {
    drawWaterTerrain(startX, endX, tc);
  } else if (theme === 'cloud') {
    drawCloudTerrainLine(startX, endX, tc);
  } else if (theme === 'cave') {
    drawCaveTerrainLine(startX, endX, terrainBottom, tc);
  } else if (theme === 'forest') {
    drawForestTerrainLine(startX, endX, tc);
  } else {
    drawStandardTerrainLine(startX, endX, tc);
  }
}

function drawWaterTerrain(startX, endX, tc) {
  const waterColor = tc.terrainColor === '#aa8' ? '#68a' : '#0af';
  const landColor = tc.terrainColor === '#aa8' ? '#aa8' : '#0fa';
  const landGlow = tc.terrainColor === '#aa8' ? '#cc9' : '#0f8';

  // Water areas
  neonGlow(ctx, waterColor, 8);
  ctx.strokeStyle = waterColor;
  ctx.lineWidth = 2;
  ctx.beginPath();
  let inWater = true;
  for (let x = startX; x <= endX; x += 2) {
    let ty = terrain[x];
    const isWaterHere = ty >= waterLineY - 10;
    if (isWaterHere) {
      ty += Math.sin(Date.now() * 0.003 + x * 0.02) * 2 + Math.sin(Date.now() * 0.005 + x * 0.04) * 1;
    }
    if (x === startX || (isWaterHere !== inWater)) {
      ctx.moveTo(x, ty);
      inWater = isWaterHere;
    } else if (isWaterHere) {
      ctx.lineTo(x, ty);
    }
  }
  ctx.stroke();
  clearGlow(ctx);

  // Island/land terrain
  neonGlow(ctx, landGlow, 8);
  ctx.strokeStyle = landColor;
  ctx.lineWidth = 2;
  ctx.beginPath();
  let onIsland = false;
  for (let x = startX; x <= endX; x += 2) {
    const ty = terrain[x];
    const isIslandHere = ty < waterLineY - 10;
    if (x === startX || (isIslandHere !== onIsland)) {
      ctx.moveTo(x, ty);
      onIsland = isIslandHere;
    } else if (isIslandHere) {
      ctx.lineTo(x, ty);
    }
  }
  ctx.stroke();
  clearGlow(ctx);

  // Water surface highlight
  ctx.strokeStyle = 'rgba(100, 200, 255, 0.3)';
  ctx.lineWidth = 0.5;
  ctx.beginPath();
  for (let x = startX; x <= endX; x += 4) {
    if (terrain[x] >= waterLineY - 5) {
      const wy = terrain[x] + Math.sin(Date.now() * 0.003 + x * 0.02) * 2;
      if (x === startX) ctx.moveTo(x, wy);
      else ctx.lineTo(x, wy);
    }
  }
  ctx.stroke();
}

function drawStandardTerrainLine(startX, endX, tc) {
  neonGlow(ctx, tc.glow, 8);
  ctx.strokeStyle = tc.terrainColor;
  ctx.lineWidth = 2;
  ctx.beginPath();
  for (let x = startX; x <= endX; x += 2) {
    if (x === startX) ctx.moveTo(x, terrain[x]);
    else ctx.lineTo(x, terrain[x]);
  }
  ctx.stroke();

  ctx.strokeStyle = '#5ff';
  ctx.lineWidth = 0.5;
  ctx.beginPath();
  for (let x = startX; x <= endX; x += 2) {
    if (x === startX) ctx.moveTo(x, terrain[x]);
    else ctx.lineTo(x, terrain[x]);
  }
  ctx.stroke();
  clearGlow(ctx);
}

function drawCloudTerrainLine(startX, endX, tc) {
  // Draw mountain peaks above clouds
  neonGlow(ctx, tc.glow, 8);
  ctx.strokeStyle = tc.terrainColor;
  ctx.lineWidth = 2;
  ctx.beginPath();
  for (let x = startX; x <= endX; x += 2) {
    if (x === startX) ctx.moveTo(x, terrain[x]);
    else ctx.lineTo(x, terrain[x]);
  }
  ctx.stroke();
  clearGlow(ctx);

  // Cloud layer ‚Äî fluffy semi-transparent
  const cloudY = canvas.height * 0.75;
  ctx.fillStyle = 'rgba(200, 210, 230, 0.12)';
  ctx.beginPath();
  ctx.moveTo(startX, cloudY + 60);
  for (let x = startX; x <= endX; x += 4) {
    const cy = cloudY + Math.sin(x * 0.008 + Date.now() * 0.0005) * 15 + Math.sin(x * 0.02) * 8;
    ctx.lineTo(x, cy);
  }
  ctx.lineTo(endX, cloudY + 60);
  ctx.closePath();
  ctx.fill();

  // Cloud top edge glow
  ctx.strokeStyle = 'rgba(180, 190, 220, 0.4)';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  for (let x = startX; x <= endX; x += 4) {
    const cy = cloudY + Math.sin(x * 0.008 + Date.now() * 0.0005) * 15 + Math.sin(x * 0.02) * 8;
    if (x === startX) ctx.moveTo(x, cy);
    else ctx.lineTo(x, cy);
  }
  ctx.stroke();
}

function drawCaveTerrainLine(startX, endX, terrainBottom, tc) {
  // Floor
  neonGlow(ctx, tc.glow, 8);
  ctx.strokeStyle = tc.terrainColor;
  ctx.lineWidth = 2;
  ctx.beginPath();
  for (let x = startX; x <= endX; x += 2) {
    if (x === startX) ctx.moveTo(x, terrain[x]);
    else ctx.lineTo(x, terrain[x]);
  }
  ctx.stroke();
  clearGlow(ctx);

  // Ceiling
  if (ceilingTerrain) {
    // Ceiling fill (dark area above)
    ctx.fillStyle = tc.bg;
    ctx.beginPath();
    ctx.moveTo(startX, camY - 50);
    for (let x = startX; x <= endX; x += 2) {
      ctx.lineTo(x, ceilingTerrain[x] || 0);
    }
    ctx.lineTo(endX, camY - 50);
    ctx.closePath();
    ctx.fill();

    // Ceiling line
    neonGlow(ctx, tc.glow, 8);
    ctx.strokeStyle = tc.terrainColor;
    ctx.lineWidth = 2;
    ctx.beginPath();
    for (let x = startX; x <= endX; x += 2) {
      const cy = ceilingTerrain[x] || 0;
      if (x === startX) ctx.moveTo(x, cy);
      else ctx.lineTo(x, cy);
    }
    ctx.stroke();
    clearGlow(ctx);

    // Stalactites/crystals decoration
    neonGlow(ctx, '#fa0', 4);
    ctx.fillStyle = 'rgba(255, 160, 0, 0.3)';
    for (let x = startX; x <= endX; x += 80) {
      const cy = ceilingTerrain[x] || 0;
      if (Math.sin(x * 0.1) > 0.6) {
        const crystalLen = 8 + Math.sin(x * 0.3) * 6;
        ctx.beginPath();
        ctx.moveTo(x - 3, cy);
        ctx.lineTo(x, cy + crystalLen);
        ctx.lineTo(x + 3, cy);
        ctx.closePath();
        ctx.fill();
      }
    }
    clearGlow(ctx);
  }
}

function drawForestTerrainLine(startX, endX, tc) {
  // Ground
  neonGlow(ctx, tc.glow, 8);
  ctx.strokeStyle = '#062';
  ctx.lineWidth = 2;
  ctx.beginPath();
  for (let x = startX; x <= endX; x += 2) {
    if (x === startX) ctx.moveTo(x, terrain[x]);
    else ctx.lineTo(x, terrain[x]);
  }
  ctx.stroke();
  clearGlow(ctx);

  // Tree canopy
  if (canopyHeight) {
    const isAutumn = (Math.floor((level - 1) / 6) % 2 === 1);
    const canopyColor = isAutumn ? 'rgba(180, 80, 20, 0.25)' : 'rgba(0, 160, 0, 0.2)';
    const canopyStroke = isAutumn ? '#a50' : tc.terrainColor;
    const canopyGlow = isAutumn ? '#f80' : tc.glow;

    ctx.fillStyle = canopyColor;
    ctx.beginPath();
    let inCanopy = false;
    for (let x = startX; x <= endX; x += 2) {
      const ch = canopyHeight[x];
      if (ch > 0) {
        const canopyY = terrain[x] - ch;
        if (!inCanopy) { ctx.moveTo(x, terrain[x]); inCanopy = true; }
        ctx.lineTo(x, canopyY);
      } else if (inCanopy) {
        ctx.lineTo(x, terrain[x]);
        inCanopy = false;
      }
    }
    if (inCanopy) ctx.lineTo(endX, terrain[endX]);
    ctx.closePath();
    ctx.fill();

    // Canopy top line
    neonGlow(ctx, canopyGlow, 6);
    ctx.strokeStyle = canopyStroke;
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    let started = false;
    for (let x = startX; x <= endX; x += 2) {
      const ch = canopyHeight[x];
      if (ch > 0) {
        const canopyY = terrain[x] - ch;
        if (!started) { ctx.moveTo(x, canopyY); started = true; }
        else ctx.lineTo(x, canopyY);
      } else {
        started = false;
      }
    }
    ctx.stroke();
    clearGlow(ctx);
  }
}

// ‚îÄ‚îÄ Ground crew state ‚îÄ‚îÄ
let groundCrewTimer = 0;
let refuelStage = 0; // 0=refueling, 1=ready

function drawBase() {
  const theme = getLevelTheme(level);
  if (theme === 'sea' || theme === 'normandy') {
    drawCarrier();
    return;
  }
  drawLandBase();
}

function drawLandBase() {
  const by = getTerrainY(baseX + BASE_WIDTH / 2);

  // ‚îÄ‚îÄ Runway ‚îÄ‚îÄ
  neonGlow(ctx, '#0af', 6);
  ctx.strokeStyle = '#0af';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(baseX, by);
  ctx.lineTo(baseX + BASE_WIDTH, by);
  ctx.stroke();

  // Dashes
  ctx.strokeStyle = '#05a';
  ctx.lineWidth = 1;
  ctx.setLineDash([8, 8]);
  ctx.beginPath();
  ctx.moveTo(baseX + 10, by - 3);
  ctx.lineTo(baseX + BASE_WIDTH - 10, by - 3);
  ctx.stroke();
  ctx.setLineDash([]);

  const dimCyan = 'rgba(0, 170, 255, 0.35)';
  const dimCyanStroke = 'rgba(0, 170, 255, 0.5)';

  // ‚îÄ‚îÄ Hangar (left of runway) ‚îÄ‚îÄ
  const hangarX = baseX - 55;
  neonGlow(ctx, '#0af', 3);
  ctx.strokeStyle = dimCyanStroke;
  ctx.lineWidth = 1;
  // Rectangle base
  ctx.strokeRect(hangarX, by - 22, 40, 22);
  // Peaked roof
  ctx.beginPath();
  ctx.moveTo(hangarX, by - 22);
  ctx.lineTo(hangarX + 20, by - 32);
  ctx.lineTo(hangarX + 40, by - 22);
  ctx.stroke();
  // Door opening
  ctx.beginPath();
  ctx.arc(hangarX + 20, by, 12, Math.PI, 0);
  ctx.stroke();

  // ‚îÄ‚îÄ Fuel storage (near runway, right-ish) ‚îÄ‚îÄ
  const fuelX = baseX + BASE_WIDTH + 15;
  ctx.strokeStyle = dimCyanStroke;
  // Cylindrical tank
  ctx.beginPath();
  ctx.arc(fuelX + 10, by, 10, Math.PI, 0);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(fuelX, by);
  ctx.lineTo(fuelX + 20, by);
  ctx.stroke();
  // Small pipe toward runway
  ctx.beginPath();
  ctx.moveTo(fuelX, by - 2);
  ctx.lineTo(baseX + BASE_WIDTH, by - 2);
  ctx.stroke();

  // ‚îÄ‚îÄ Control tower (right side) ‚îÄ‚îÄ
  const towerX = baseX + BASE_WIDTH + 45;
  ctx.strokeStyle = dimCyanStroke;
  // Tower body
  ctx.strokeRect(towerX, by - 40, 12, 40);
  // Observation room (wider top)
  ctx.strokeRect(towerX - 4, by - 48, 20, 8);
  // Antenna
  ctx.beginPath();
  ctx.moveTo(towerX + 6, by - 48);
  ctx.lineTo(towerX + 6, by - 56);
  ctx.stroke();
  // Antenna cross-piece
  ctx.beginPath();
  ctx.moveTo(towerX + 2, by - 54);
  ctx.lineTo(towerX + 10, by - 54);
  ctx.stroke();

  // ‚îÄ‚îÄ Barracks (far right) ‚îÄ‚îÄ
  const barracksX = baseX + BASE_WIDTH + 70;
  ctx.strokeStyle = dimCyanStroke;
  ctx.strokeRect(barracksX, by - 14, 25, 14);
  ctx.strokeRect(barracksX + 30, by - 12, 20, 12);
  // Windows (small dots)
  ctx.fillStyle = dimCyan;
  for (let wx = barracksX + 5; wx < barracksX + 25; wx += 7) {
    ctx.fillRect(wx, by - 10, 3, 3);
  }

  // ‚îÄ‚îÄ Windsock (animated, on a pole) ‚îÄ‚îÄ
  const sockX = baseX - 15;
  ctx.strokeStyle = dimCyanStroke;
  ctx.beginPath();
  ctx.moveTo(sockX, by);
  ctx.lineTo(sockX, by - 20);
  ctx.stroke();
  // Sock flag (sin-based flutter)
  const sockFlutter = Math.sin(Date.now() * 0.005) * 3;
  const sockFlutter2 = Math.sin(Date.now() * 0.007 + 1) * 2;
  ctx.strokeStyle = 'rgba(255, 150, 0, 0.5)';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(sockX, by - 20);
  ctx.quadraticCurveTo(sockX + 8 + sockFlutter, by - 19 + sockFlutter2, sockX + 14 + sockFlutter, by - 18);
  ctx.stroke();

  clearGlow(ctx);

  // ‚îÄ‚îÄ Label ‚îÄ‚îÄ
  neonGlow(ctx, '#0af', 6);
  ctx.fillStyle = '#0af';
  ctx.font = '10px "Courier New", monospace';
  ctx.textAlign = 'center';
  ctx.fillText('HOME BASE', baseX + BASE_WIDTH / 2, by - 10);
  clearGlow(ctx);

  // ‚îÄ‚îÄ Ground crew when landed ‚îÄ‚îÄ
  if (player.landed && state === ST.PLAYING) {
    groundCrewTimer += 0.016; // approximate dt
    drawGroundCrew(by);
  } else {
    groundCrewTimer = 0;
    refuelStage = 0;
  }
}

// ‚îÄ‚îÄ Searchlights from home base ‚îÄ‚îÄ
function drawSearchlights() {
  const homeX = baseX + BASE_WIDTH / 2;
  const homeY = getTerrainY(homeX);
  const t = Date.now() * 0.001;
  const p = player;

  const playerDist = Math.sqrt((p.x - homeX) ** 2 + (p.y - homeY) ** 2);
  if (p.autopilot && state === ST.PLAYING && playerDist <= 400) {
    // Tractor beam mode: two beams lock onto the player (only within capture range)
    const dx = p.x - homeX;
    const dy = p.y - homeY;
    const angle = Math.atan2(dy, dx);

    // Draw two converging beams from base to player
    for (let beam = -1; beam <= 1; beam += 2) {
      const beamOriginX = homeX + beam * 30;
      const beamOriginY = homeY - 5;
      const dist = Math.sqrt((p.x - beamOriginX) ** 2 + (p.y - beamOriginY) ** 2);

      ctx.save();
      // Beam cone with gradient
      const grad = ctx.createLinearGradient(beamOriginX, beamOriginY, p.x, p.y);
      grad.addColorStop(0, 'rgba(0, 255, 255, 0.25)');
      grad.addColorStop(0.6, 'rgba(0, 200, 255, 0.08)');
      grad.addColorStop(1, 'rgba(0, 255, 255, 0.02)');

      const coneAngle = Math.atan2(p.y - beamOriginY, p.x - beamOriginX);
      const spread = 0.06; // narrow beam

      ctx.beginPath();
      ctx.moveTo(beamOriginX, beamOriginY);
      ctx.lineTo(p.x + Math.cos(coneAngle + spread) * 20, p.y + Math.sin(coneAngle + spread) * 20);
      ctx.lineTo(p.x + Math.cos(coneAngle - spread) * 20, p.y + Math.sin(coneAngle - spread) * 20);
      ctx.closePath();
      ctx.fillStyle = grad;
      ctx.fill();

      // Bright center line
      ctx.strokeStyle = 'rgba(0, 255, 255, 0.15)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(beamOriginX, beamOriginY);
      ctx.lineTo(p.x, p.y);
      ctx.stroke();
      ctx.restore();
    }

    // Glow circle around player when captured
    const captureRadius = Math.sqrt((p.x - homeX) ** 2 + (p.y - homeY) ** 2);
    if (captureRadius < 400) {
      const glowAlpha = 0.15 * (1 - captureRadius / 400);
      ctx.beginPath();
      ctx.arc(p.x, p.y, 20 + Math.sin(t * 5) * 3, 0, Math.PI * 2);
      ctx.strokeStyle = `rgba(0, 255, 255, ${glowAlpha + 0.1})`;
      ctx.lineWidth = 2;
      neonGlow(ctx, '#0ff', 8);
      ctx.stroke();
      clearGlow(ctx);
    }
  } else if (state === ST.PLAYING && !p.landed) {
    // Idle sweep mode: two searchlights slowly sweep the sky
    for (let beam = -1; beam <= 1; beam += 2) {
      const beamOriginX = homeX + beam * 25;
      const beamOriginY = homeY - 5;
      // Sweep angle: oscillates back and forth
      const sweepAngle = -Math.PI / 2 + Math.sin(t * 0.4 + beam * 1.5) * 0.8;
      const beamLen = 400;
      const endX = beamOriginX + Math.cos(sweepAngle) * beamLen;
      const endY = beamOriginY + Math.sin(sweepAngle) * beamLen;
      const spread = 0.08;

      ctx.save();
      const grad = ctx.createLinearGradient(beamOriginX, beamOriginY, endX, endY);
      grad.addColorStop(0, 'rgba(0, 200, 255, 0.12)');
      grad.addColorStop(0.5, 'rgba(0, 200, 255, 0.04)');
      grad.addColorStop(1, 'rgba(0, 200, 255, 0)');

      ctx.beginPath();
      ctx.moveTo(beamOriginX, beamOriginY);
      ctx.lineTo(endX + Math.cos(sweepAngle + spread) * 40, endY + Math.sin(sweepAngle + spread) * 40);
      ctx.lineTo(endX + Math.cos(sweepAngle - spread) * 40, endY + Math.sin(sweepAngle - spread) * 40);
      ctx.closePath();
      ctx.fillStyle = grad;
      ctx.fill();
      ctx.restore();
    }
  }
}

function drawGroundCrew(groundY) {
  const crewColor = '#0af';
  const px = player.x;
  const py = player.y;

  // Crew member 1: near nose (fueling)
  const c1x = px + 22;
  const c1y = groundY;
  const armAnim1 = Math.sin(groundCrewTimer * 6) * 2;
  drawCrewPerson(c1x, c1y, crewColor, armAnim1, Math.sin(groundCrewTimer * 4) * 1.5);

  // Crew member 2: near wing (loading bombs)
  const c2x = px - 15;
  const c2y = groundY;
  const armAnim2 = Math.sin(groundCrewTimer * 5 + 1) * 2;
  drawCrewPerson(c2x, c2y, crewColor, armAnim2, Math.sin(groundCrewTimer * 3 + 2) * 1.5);
  // Small bomb box being carried
  ctx.fillStyle = 'rgba(255, 170, 0, 0.4)';
  ctx.fillRect(c2x - 3 + armAnim2, c2y - 5 + Math.abs(armAnim2) * 0.3, 3, 3);

  // Crew member 3: at tail (inspection)
  const c3x = px - 28;
  const c3y = groundY;
  const armAnim3 = Math.sin(groundCrewTimer * 3 + 3) * 1.5;
  drawCrewPerson(c3x, c3y, crewColor, armAnim3, Math.sin(groundCrewTimer * 2 + 1));

  // Fuel pump animation (pulsing line from fuel tank to plane)
  const fuelX = baseX + BASE_WIDTH + 15;
  if (groundCrewTimer < 1.5) {
    const pulseAlpha = 0.3 + 0.3 * Math.sin(groundCrewTimer * 8);
    ctx.strokeStyle = `rgba(0, 170, 255, ${pulseAlpha})`;
    ctx.lineWidth = 1;
    ctx.setLineDash([4, 4]);
    ctx.beginPath();
    ctx.moveTo(fuelX, groundY - 3);
    ctx.lineTo(px + 10, py + 5);
    ctx.stroke();
    ctx.setLineDash([]);
  }

  // Status text
  neonGlow(ctx, '#0af', 4);
  ctx.font = '9px "Courier New", monospace';
  ctx.textAlign = 'center';
  if (groundCrewTimer < 1.2) {
    const alpha = 0.5 + 0.3 * Math.sin(groundCrewTimer * 6);
    ctx.globalAlpha = alpha;
    ctx.fillStyle = '#0af';
    ctx.fillText('REFUELING...', baseX + BASE_WIDTH / 2, groundY - 22);
    ctx.globalAlpha = 1;
  } else {
    ctx.fillStyle = '#0f0';
    ctx.fillText('READY', baseX + BASE_WIDTH / 2, groundY - 22);
  }
  clearGlow(ctx);
}

function drawCrewPerson(x, y, color, armAnim, legAnim) {
  neonGlow(ctx, color, 3);
  ctx.strokeStyle = color;
  ctx.lineWidth = 1;
  // Head
  ctx.beginPath();
  ctx.arc(x, y - 7, 1.5, 0, Math.PI * 2);
  ctx.stroke();
  // Body
  ctx.beginPath();
  ctx.moveTo(x, y - 5.5);
  ctx.lineTo(x, y - 2);
  ctx.stroke();
  // Arms
  ctx.beginPath();
  ctx.moveTo(x - 2 - armAnim, y - 5);
  ctx.lineTo(x, y - 4);
  ctx.lineTo(x + 2 + armAnim, y - 5);
  ctx.stroke();
  // Legs
  ctx.beginPath();
  ctx.moveTo(x - 1.5 - legAnim, y);
  ctx.lineTo(x, y - 2);
  ctx.lineTo(x + 1.5 + legAnim, y);
  ctx.stroke();
  clearGlow(ctx);
}

function drawCarrier() {
  const deckY = getTerrainY(baseX + BASE_WIDTH / 2);
  const carrierLeft = baseX - 60;
  const carrierRight = baseX + BASE_WIDTH + 60;
  const carrierW = carrierRight - carrierLeft;

  neonGlow(ctx, '#0af', 6);
  ctx.strokeStyle = '#0af';
  ctx.lineWidth = 2;

  // ‚îÄ‚îÄ Hull shape: angled bow, flat deck, stern ‚îÄ‚îÄ
  ctx.beginPath();
  // Bow (left side, pointed)
  ctx.moveTo(carrierLeft - 20, deckY + 8);
  ctx.lineTo(carrierLeft, deckY);
  // Flat deck
  ctx.lineTo(carrierRight, deckY);
  // Stern (right side, squared)
  ctx.lineTo(carrierRight + 5, deckY + 4);
  ctx.lineTo(carrierRight + 5, deckY + 12);
  // Hull bottom
  ctx.lineTo(carrierLeft - 15, deckY + 12);
  ctx.closePath();
  ctx.stroke();

  // Hull waterline
  ctx.strokeStyle = 'rgba(0, 170, 255, 0.3)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(carrierLeft - 15, deckY + 8);
  ctx.lineTo(carrierRight + 5, deckY + 8);
  ctx.stroke();

  // ‚îÄ‚îÄ Deck markings: landing stripes ‚îÄ‚îÄ
  ctx.strokeStyle = '#05a';
  ctx.lineWidth = 1;
  ctx.setLineDash([10, 10]);
  ctx.beginPath();
  ctx.moveTo(baseX + 10, deckY - 2);
  ctx.lineTo(baseX + BASE_WIDTH - 10, deckY - 2);
  ctx.stroke();
  ctx.setLineDash([]);

  // Runway center line
  ctx.strokeStyle = '#0af';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(baseX, deckY);
  ctx.lineTo(baseX + BASE_WIDTH, deckY);
  ctx.stroke();

  // Deck edge markings (short perpendicular lines)
  ctx.strokeStyle = 'rgba(0, 170, 255, 0.4)';
  ctx.lineWidth = 1;
  for (let mx = carrierLeft + 15; mx < carrierRight - 10; mx += 25) {
    ctx.beginPath();
    ctx.moveTo(mx, deckY);
    ctx.lineTo(mx, deckY - 3);
    ctx.stroke();
  }

  // ‚îÄ‚îÄ Control tower / island superstructure (right side) ‚îÄ‚îÄ
  const islandX = carrierRight - 30;
  ctx.strokeStyle = 'rgba(0, 170, 255, 0.5)';
  ctx.lineWidth = 1;
  // Main tower body
  ctx.strokeRect(islandX, deckY - 35, 20, 35);
  // Bridge windows (top row)
  ctx.fillStyle = 'rgba(0, 255, 255, 0.4)';
  ctx.fillRect(islandX + 3, deckY - 32, 4, 3);
  ctx.fillRect(islandX + 9, deckY - 32, 4, 3);
  // Lower windows
  ctx.fillStyle = 'rgba(0, 255, 255, 0.2)';
  ctx.fillRect(islandX + 3, deckY - 22, 4, 3);
  ctx.fillRect(islandX + 9, deckY - 22, 4, 3);
  // Mast/antenna
  ctx.strokeStyle = 'rgba(0, 170, 255, 0.6)';
  ctx.beginPath();
  ctx.moveTo(islandX + 10, deckY - 35);
  ctx.lineTo(islandX + 10, deckY - 52);
  ctx.stroke();
  // Radar dish (rotating)
  const dishAng = (Date.now() * 0.003) % (Math.PI * 2);
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.arc(islandX + 10, deckY - 52, 6, dishAng, dishAng + Math.PI * 0.5);
  ctx.stroke();
  // Blinking light on top
  const blink = Math.sin(Date.now() * 0.005) > 0;
  if (blink) {
    ctx.fillStyle = '#f00';
    ctx.beginPath();
    ctx.arc(islandX + 10, deckY - 53, 1.5, 0, Math.PI * 2);
    ctx.fill();
  }

  // ‚îÄ‚îÄ Machine gun turrets (fore and aft) ‚îÄ‚îÄ
  ctx.strokeStyle = 'rgba(0, 170, 255, 0.6)';
  ctx.lineWidth = 1;
  // Forward gun (left/bow)
  const gunY = deckY - 5;
  const fGunX = carrierLeft + 10;
  // Gun base (small circle)
  ctx.beginPath();
  ctx.arc(fGunX, gunY, 3, 0, Math.PI * 2);
  ctx.stroke();
  // Gun barrel (sweeps slowly)
  const fGunAng = -Math.PI / 2 + Math.sin(Date.now() * 0.001) * 0.6;
  ctx.beginPath();
  ctx.moveTo(fGunX, gunY);
  ctx.lineTo(fGunX + Math.cos(fGunAng) * 8, gunY + Math.sin(fGunAng) * 8);
  ctx.stroke();
  // Aft gun (right/stern)
  const aGunX = carrierRight - 40;
  ctx.beginPath();
  ctx.arc(aGunX, gunY, 3, 0, Math.PI * 2);
  ctx.stroke();
  const aGunAng = -Math.PI / 2 + Math.sin(Date.now() * 0.0012 + 2) * 0.6;
  ctx.beginPath();
  ctx.moveTo(aGunX, gunY);
  ctx.lineTo(aGunX + Math.cos(aGunAng) * 8, gunY + Math.sin(aGunAng) * 8);
  ctx.stroke();

  // ‚îÄ‚îÄ Windsock on control tower ‚îÄ‚îÄ
  const wsX = islandX + 18;
  const wsY = deckY - 38;
  ctx.strokeStyle = 'rgba(255, 100, 0, 0.5)';
  ctx.lineWidth = 1;
  // Pole
  ctx.beginPath();
  ctx.moveTo(wsX, deckY);
  ctx.lineTo(wsX, wsY);
  ctx.stroke();
  // Sock (flutters in wind)
  const wsFlutter = Math.sin(Date.now() * 0.008) * 2;
  ctx.strokeStyle = 'rgba(255, 120, 0, 0.6)';
  ctx.beginPath();
  ctx.moveTo(wsX, wsY);
  ctx.quadraticCurveTo(wsX + 6, wsY + wsFlutter, wsX + 12, wsY + 1 + wsFlutter);
  ctx.stroke();

  // ‚îÄ‚îÄ Fuel lines on deck ‚îÄ‚îÄ
  ctx.strokeStyle = 'rgba(0, 200, 100, 0.2)';
  ctx.lineWidth = 1;
  ctx.setLineDash([3, 5]);
  ctx.beginPath();
  ctx.moveTo(islandX, deckY - 2);
  ctx.lineTo(baseX + BASE_WIDTH / 2, deckY - 2);
  ctx.stroke();
  ctx.setLineDash([]);

  // ‚îÄ‚îÄ Wake: animated white particles trailing behind carrier ‚îÄ‚îÄ
  if (Math.random() < 0.3) {
    const wakeX = carrierRight + 5 + Math.random() * 30;
    const wakeY = deckY + 10 + Math.random() * 4;
    addParticle(wakeX, wakeY, 15 + Math.random() * 10, (Math.random() - 0.5) * 5, 0.4 + Math.random() * 0.3, '#fff', 1.5);
  }

  clearGlow(ctx);

  // ‚îÄ‚îÄ Label ‚îÄ‚îÄ
  neonGlow(ctx, '#0af', 6);
  ctx.fillStyle = '#0af';
  ctx.font = '10px "Courier New", monospace';
  ctx.textAlign = 'center';
  ctx.fillText('CARRIER', baseX + BASE_WIDTH / 2, deckY - 10);
  clearGlow(ctx);

  // ‚îÄ‚îÄ Ground crew when landed (reuse same crew on carrier deck) ‚îÄ‚îÄ
  if (player.landed && state === ST.PLAYING) {
    groundCrewTimer += 0.016;
    drawGroundCrew(deckY);
  } else {
    groundCrewTimer = 0;
    refuelStage = 0;
  }
}

// ‚îÄ‚îÄ Submarine spawning & logic ‚îÄ‚îÄ
function spawnSubmarines() {
  submarines = [];
  if (THEME_CONFIG[getLevelTheme(level)].hasWater !== true) return;
  const count = 1 + Math.floor(level / 2);
  for (let i = 0; i < count; i++) {
    // Spawn in water areas (away from islands and carrier)
    let sx;
    let attempts = 0;
    do {
      sx = 500 + Math.random() * (WORLD_W - 1000);
      attempts++;
    } while (attempts < 20 && (
      Math.abs(sx - baseX - BASE_WIDTH / 2) < 600 ||
      islandPeaks.some(ip => Math.abs(sx - ip.cx) < ip.w / 2 + 100)
    ));

    submarines.push({
      x: sx,
      y: waterLineY - 4,
      vx: (Math.random() < 0.5 ? 1 : -1) * (15 + Math.random() * 10),
      alive: true,
      hp: 6,
      surfaced: true,
      surfaceTimer: 5 + Math.random() * 5,
      gunTimer: 0,
      submergeDepth: 0, // 0 = surfaced, 1 = fully submerged
      phase: 'surfaced' // surfaced, submerging, submerged, surfacing
    });
  }
}

function updateSubmarines(dt) {
  for (const sub of submarines) {
    if (!sub.alive) continue;

    // Movement
    sub.x += sub.vx * dt;
    if (sub.x < 200) { sub.x = 200; sub.vx = Math.abs(sub.vx); }
    if (sub.x >= WORLD_W - 200) { sub.x = WORLD_W - 200; sub.vx = -Math.abs(sub.vx); }

    // Surface/submerge cycle with smooth animation
    sub.surfaceTimer -= dt;
    if (sub.surfaceTimer <= 0) {
      if (sub.phase === 'surfaced') {
        sub.phase = 'submerging';
        sub.surfaceTimer = 2; // time to submerge
      } else if (sub.phase === 'submerging') {
        sub.phase = 'submerged';
        sub.surfaced = false;
        sub.surfaceTimer = 4 + Math.random() * 5; // time underwater
      } else if (sub.phase === 'submerged') {
        sub.phase = 'surfacing';
        sub.surfaceTimer = 2; // time to surface
      } else if (sub.phase === 'surfacing') {
        sub.phase = 'surfaced';
        sub.surfaced = true;
        sub.surfaceTimer = 5 + Math.random() * 5; // time on surface
      }
    }

    // Smooth submerge depth
    if (sub.phase === 'submerging') {
      sub.submergeDepth = Math.min(1, sub.submergeDepth + dt * 0.5);
    } else if (sub.phase === 'surfacing') {
      sub.submergeDepth = Math.max(0, sub.submergeDepth - dt * 0.5);
    } else if (sub.phase === 'submerged') {
      sub.submergeDepth = 1;
    } else {
      sub.submergeDepth = 0;
    }

    // Position: sink below water when submerging
    sub.y = waterLineY - 4 + sub.submergeDepth * 30;

    // Machine gun tower ‚Äî fire bullets when surfaced or surfacing
    if (sub.surfaced || sub.phase === 'surfacing') {
      sub.gunTimer -= dt;
      if (sub.gunTimer <= 0) {
        const dx = player.x - sub.x;
        const dy = player.y - sub.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < 700 && player.y < sub.y) {
          // Fire toward player with spread
          const aimAngle = Math.atan2(dy, dx) + (Math.random() - 0.5) * 0.3;
          bullets.push({
            x: sub.x, y: sub.y - 18 - (1 - sub.submergeDepth) * 10,
            vx: Math.cos(aimAngle) * 300,
            vy: Math.sin(aimAngle) * 300,
            life: 2, friendly: false
          });
          sub.gunTimer = 0.4 + Math.random() * 0.3;
        } else {
          sub.gunTimer = 0.5;
        }
      }
    }
  }
}

function drawSubmarine(sub) {
  const depth = sub.submergeDepth || 0;
  const alpha = 1.0 - depth * 0.7;
  ctx.globalAlpha = alpha;

  neonGlow(ctx, '#48f', 6);
  ctx.strokeStyle = '#48f';
  ctx.lineWidth = 1.5;

  const sx = sub.x;
  const sy = sub.y;
  const dir = sub.vx >= 0 ? 1 : -1;

  // Hull (large elongated oval)
  ctx.beginPath();
  ctx.ellipse(sx, sy + 5, 50, 12, 0, 0, Math.PI * 2);
  ctx.stroke();

  // Deck line
  ctx.beginPath();
  ctx.moveTo(sx - 45, sy);
  ctx.lineTo(sx + 45, sy);
  ctx.stroke();

  // Bow and stern detail
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(sx + dir * 48, sy);
  ctx.lineTo(sx + dir * 55, sy + 3);
  ctx.stroke();

  // Conning tower (larger)
  ctx.lineWidth = 1.5;
  ctx.strokeRect(sx - 8, sy - 16, 16, 16);

  // Periscope
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(sx + 4, sy - 16);
  ctx.lineTo(sx + 4, sy - 24);
  ctx.lineTo(sx + 8, sy - 24);
  ctx.stroke();

  // Machine gun turret on conning tower
  if (depth < 0.5) {
    ctx.lineWidth = 1.5;
    // Turret base (circle)
    ctx.beginPath();
    ctx.arc(sx - 2, sy - 16, 4, 0, Math.PI * 2);
    ctx.stroke();
    // Gun barrel pointing toward player
    const dx = player.x - sx;
    const dy = player.y - (sy - 16);
    const gunAngle = Math.atan2(dy, dx);
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(sx - 2, sy - 16);
    ctx.lineTo(sx - 2 + Math.cos(gunAngle) * 12, sy - 16 + Math.sin(gunAngle) * 12);
    ctx.stroke();
  }

  // Propeller wake
  if (depth < 0.8) {
    ctx.strokeStyle = 'rgba(100, 200, 255, 0.3)';
    ctx.lineWidth = 1;
    const wakeX = sx - dir * 50;
    for (let w = 0; w < 3; w++) {
      ctx.beginPath();
      ctx.arc(wakeX - dir * w * 8, sy + 5, 3 + w * 2, 0, Math.PI);
      ctx.stroke();
    }
  }

  // HP indicator (pips below hull)
  ctx.fillStyle = '#48f';
  for (let h = 0; h < sub.hp; h++) {
    ctx.fillRect(sx - 15 + h * 6, sy + 20, 4, 2);
  }

  clearGlow(ctx);
  ctx.globalAlpha = 1;
}

// ‚îÄ‚îÄ Speedboats ‚îÄ‚îÄ

function spawnSpeedboats() {
  speedboats = [];
  const tc = THEME_CONFIG[getLevelTheme(level)];
  if (!tc.hasWater) return;
  const count = 2 + Math.floor(level / 3);
  for (let i = 0; i < count; i++) {
    let sx;
    let attempts = 0;
    do {
      sx = 500 + Math.random() * (WORLD_W - 1000);
      attempts++;
    } while (attempts < 20 && (
      Math.abs(sx - baseX - BASE_WIDTH / 2) < 600 ||
      islandPeaks.some(ip => Math.abs(sx - ip.cx) < ip.w / 2 + 80)
    ));
    speedboats.push({
      x: sx,
      y: waterLineY - 2,
      vx: (Math.random() < 0.5 ? 1 : -1) * (80 + Math.random() * 40),
      alive: true,
      hp: 2,
      gunTimer: 0,
      burstCount: 0,
      frame: Math.random() * Math.PI * 2
    });
  }
}

function updateSpeedboats(dt) {
  for (const sb of speedboats) {
    if (!sb.alive) continue;

    sb.frame += dt;

    // Movement
    sb.x += sb.vx * dt;
    sb.y = waterLineY - 2;

    // Bounce off world edges
    if (sb.x < 200) { sb.x = 200; sb.vx = Math.abs(sb.vx); }
    if (sb.x >= WORLD_W - 200) { sb.x = WORLD_W - 200; sb.vx = -Math.abs(sb.vx); }

    // Avoid islands ‚Äî reverse if terrain rises above water
    const terrainHere = getTerrainY(sb.x);
    const lookAhead = sb.x + Math.sign(sb.vx) * 60;
    const terrainAhead = getTerrainY(((lookAhead % WORLD_W) + WORLD_W) % WORLD_W);
    if (terrainAhead < waterLineY - 10) {
      sb.vx = -sb.vx; // turn around
    }

    // Chase player when nearby
    const dx = player.x - sb.x;
    const dist = Math.sqrt(dx * dx + (player.y - sb.y) * (player.y - sb.y));
    if (dist < 500 && !player.landed) {
      const chase = Math.sign(dx) * (90 + Math.random() * 30);
      sb.vx += (chase - sb.vx) * 0.02;
    }

    // Clamp speed
    const maxSpd = 120;
    if (Math.abs(sb.vx) > maxSpd) sb.vx = Math.sign(sb.vx) * maxSpd;

    // Wake particles
    if (Math.random() < 0.4) {
      addParticle(sb.x - Math.sign(sb.vx) * 15, sb.y + 2,
        -sb.vx * 0.1 + (Math.random() - 0.5) * 10, -5 - Math.random() * 5,
        0.3, '#8cf', 1.5);
    }

    // Machine gun burst ‚Äî fires rapid short bursts toward player
    if (!player.landed && !player.burning && state === ST.PLAYING) {
      sb.gunTimer -= dt;
      if (sb.gunTimer <= 0 && dist < 500 && player.y < sb.y) {
        const aimDx = player.x - sb.x;
        const aimDy = player.y - (sb.y - 8);
        const aimAngle = Math.atan2(aimDy, aimDx) + (Math.random() - 0.5) * 0.25;
        bullets.push({
          x: sb.x, y: sb.y - 8,
          vx: Math.cos(aimAngle) * 280,
          vy: Math.sin(aimAngle) * 280,
          life: 1.5, friendly: false
        });
        sb.burstCount++;
        if (sb.burstCount >= 3) {
          sb.gunTimer = 1.2 + Math.random() * 0.8; // pause between bursts
          sb.burstCount = 0;
        } else {
          sb.gunTimer = 0.1; // rapid fire within burst
        }
      }
    }

    // Player collision
    if (player.invincible <= 0 && !player.burning && state === ST.PLAYING) {
      if (Math.abs(player.x - sb.x) < 20 && Math.abs(player.y - sb.y) < 12) {
        sb.alive = false;
        addExplosion(sb.x, sb.y, 20, true);
        playBoom(false);
        score += 250;
        damagePlayer(2);
      }
    }
  }
}

function drawSpeedboat(sb) {
  const facingRight = sb.vx >= 0;
  const dir = facingRight ? 1 : -1;
  const sx = sb.x;
  const sy = sb.y;
  const bob = Math.sin(sb.frame * 4) * 1.5; // gentle bobbing

  // Hull ‚Äî pointed speedboat shape
  neonGlow(ctx, '#0f0', 6);
  ctx.fillStyle = '#0f0';
  ctx.beginPath();
  ctx.moveTo(sx + dir * 18, sy + bob);           // bow tip
  ctx.lineTo(sx + dir * 8, sy - 4 + bob);        // bow top
  ctx.lineTo(sx - dir * 14, sy - 3 + bob);       // stern top
  ctx.lineTo(sx - dir * 14, sy + 2 + bob);       // stern bottom
  ctx.lineTo(sx + dir * 8, sy + 3 + bob);        // bow bottom
  ctx.closePath();
  ctx.fill();

  // Windshield
  ctx.fillStyle = '#aff';
  ctx.fillRect(sx + dir * 2 - 2, sy - 6 + bob, 4, 3);

  // Crew member 1 ‚Äî gunner standing with weapon
  const armAnim = Math.sin(sb.frame * 6) * 1;
  ctx.strokeStyle = '#ff0';
  ctx.lineWidth = 1.5;
  // Body
  ctx.beginPath();
  ctx.moveTo(sx - dir * 2, sy - 5 + bob);   // feet
  ctx.lineTo(sx - dir * 2, sy - 11 + bob);  // torso
  ctx.stroke();
  // Head
  ctx.beginPath();
  ctx.arc(sx - dir * 2, sy - 13 + bob, 2, 0, Math.PI * 2);
  ctx.stroke();
  // Arms holding gun up
  ctx.beginPath();
  ctx.moveTo(sx - dir * 2, sy - 9 + bob);
  ctx.lineTo(sx - dir * 2 + dir * 4, sy - 12 + bob + armAnim);
  ctx.stroke();
  // Gun
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(sx - dir * 2 + dir * 4, sy - 12 + bob + armAnim);
  ctx.lineTo(sx - dir * 2 + dir * 4, sy - 16 + bob + armAnim);
  ctx.stroke();

  // Crew member 2 ‚Äî at stern
  ctx.strokeStyle = '#ff0';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(sx - dir * 8, sy - 4 + bob);
  ctx.lineTo(sx - dir * 8, sy - 10 + bob);
  ctx.stroke();
  ctx.beginPath();
  ctx.arc(sx - dir * 8, sy - 12 + bob, 2, 0, Math.PI * 2);
  ctx.stroke();

  clearGlow(ctx);
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  CLOUD THEME ‚Äî Fuel tankers, ace pilots
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

function spawnFuelTankers() {
  fuelTankers = [];
  const tankerX = baseX + 2000 + Math.random() * (WORLD_W - 4000);
  fuelTankers.push({
    x: tankerX, y: canvas.height * 0.35,
    vx: 40, alive: true, hp: 5,
    dockingProgress: 0, // 0-1, player needs to stay close
    docking: false
  });
}

function updateFuelTankers(dt) {
  for (const ft of fuelTankers) {
    if (!ft.alive) continue;
    ft.x += ft.vx * dt;
    if (ft.x < 200 || ft.x > WORLD_W - 200) ft.vx *= -1;

    // Check if player is docking (within 50px, same direction)
    const dx = player.x - ft.x;
    const dy = player.y - ft.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const sameDir = (player.vx > 0 && ft.vx > 0) || (player.vx < 0 && ft.vx < 0);

    if (dist < 60 && sameDir && !player.landed && !player.burning && state === ST.PLAYING) {
      ft.docking = true;
      ft.dockingProgress += dt * 0.25; // ~4 seconds to fully dock
      if (ft.dockingProgress >= 1) {
        ft.dockingProgress = 1;
        // Refuel/rearm player
        player.fuel = Math.min(MAX_FUEL, player.fuel + dt * 500);
        player.ammo = Math.min(MAX_AMMO, player.ammo + dt * 50);
      }
    } else {
      ft.docking = false;
      ft.dockingProgress = Math.max(0, ft.dockingProgress - dt * 0.5);
    }
  }
}

function drawFuelTankers() {
  for (const ft of fuelTankers) {
    if (!ft.alive) continue;
    const sx = ft.x, sy = ft.y;
    const dir = ft.vx > 0 ? 1 : -1;

    neonGlow(ctx, '#0af', 6);
    ctx.strokeStyle = '#0af';
    ctx.lineWidth = 1.5;

    // Fuselage (large transport plane)
    ctx.beginPath();
    ctx.ellipse(sx, sy, 30, 8, 0, 0, Math.PI * 2);
    ctx.stroke();

    // Wings
    ctx.beginPath();
    ctx.moveTo(sx - 8, sy);
    ctx.lineTo(sx - 8, sy - 20);
    ctx.lineTo(sx + 8, sy - 20);
    ctx.lineTo(sx + 8, sy);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(sx - 8, sy);
    ctx.lineTo(sx - 8, sy + 20);
    ctx.lineTo(sx + 8, sy + 20);
    ctx.lineTo(sx + 8, sy);
    ctx.stroke();

    // Tail
    ctx.beginPath();
    ctx.moveTo(sx - dir * 25, sy);
    ctx.lineTo(sx - dir * 30, sy - 10);
    ctx.stroke();

    // FUEL label
    ctx.fillStyle = '#0af';
    ctx.font = '7px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('FUEL', sx, sy + 3);

    // Docking progress bar
    if (ft.dockingProgress > 0) {
      const barW = 40;
      const barH = 4;
      ctx.strokeStyle = '#0ff';
      ctx.lineWidth = 1;
      ctx.strokeRect(sx - barW / 2, sy - 18, barW, barH);
      ctx.fillStyle = ft.dockingProgress >= 1 ? '#0f0' : '#0ff';
      ctx.fillRect(sx - barW / 2, sy - 18, barW * ft.dockingProgress, barH);
    }

    clearGlow(ctx);
  }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  CAVE THEME ‚Äî Bats, cave turrets
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

function spawnBats() {
  bats = [];
  const numSwarms = 2 + Math.floor(Math.random() * 2);
  for (let s = 0; s < numSwarms; s++) {
    const cx = 800 + Math.random() * (WORLD_W - 1600);
    if (Math.abs(cx - baseX - BASE_WIDTH / 2) < 500) continue;
    const cy = ceilingTerrain ? (ceilingTerrain[Math.floor(cx)] + terrain[Math.floor(cx)]) / 2 : canvas.height * 0.4;
    const count = 5 + Math.floor(Math.random() * 4);
    for (let i = 0; i < count; i++) {
      bats.push({
        x: cx + (Math.random() - 0.5) * 60,
        y: cy + (Math.random() - 0.5) * 40,
        centerX: cx, centerY: cy,
        angle: Math.random() * Math.PI * 2,
        orbitSpeed: 1.5 + Math.random(),
        orbitRadius: 20 + Math.random() * 30,
        alive: true, hp: 1,
        rushing: false, rushTimer: 0
      });
    }
  }
}

function updateBats(dt) {
  for (const bat of bats) {
    if (!bat.alive) continue;

    const dxP = player.x - bat.x;
    const dyP = player.y - bat.y;
    const distP = Math.sqrt(dxP * dxP + dyP * dyP);

    // Rush toward player if close
    if (distP < 200 && !bat.rushing && Math.random() < 0.02) {
      bat.rushing = true;
      bat.rushTimer = 1.5;
    }

    if (bat.rushing) {
      bat.rushTimer -= dt;
      bat.x += (dxP / distP) * 180 * dt;
      bat.y += (dyP / distP) * 180 * dt;
      if (bat.rushTimer <= 0) {
        bat.rushing = false;
        bat.centerX = bat.x;
        bat.centerY = bat.y;
      }
    } else {
      // Orbit center point
      bat.angle += bat.orbitSpeed * dt;
      bat.x = bat.centerX + Math.cos(bat.angle) * bat.orbitRadius;
      bat.y = bat.centerY + Math.sin(bat.angle) * bat.orbitRadius * 0.6;
    }

    // Collision with player
    if (distP < 15 && !player.burning && player.invincible <= 0 && state === ST.PLAYING) {
      bat.alive = false;
      addExplosion(bat.x, bat.y, 5, false);
      damagePlayer(1);
    }
  }
}

function drawBats() {
  for (const bat of bats) {
    if (!bat.alive) continue;
    neonGlow(ctx, '#f80', 4);
    ctx.strokeStyle = '#fa0';
    ctx.lineWidth = 1;
    // Body
    ctx.fillStyle = '#f80';
    ctx.fillRect(bat.x - 1, bat.y - 1, 3, 3);
    // Wings (animated)
    const wingAngle = Math.sin(Date.now() * 0.02 + bat.angle) * 0.5;
    ctx.beginPath();
    ctx.moveTo(bat.x, bat.y);
    ctx.lineTo(bat.x - 6, bat.y - 4 * wingAngle);
    ctx.lineTo(bat.x - 8, bat.y + 2 * wingAngle);
    ctx.moveTo(bat.x, bat.y);
    ctx.lineTo(bat.x + 6, bat.y - 4 * wingAngle);
    ctx.lineTo(bat.x + 8, bat.y + 2 * wingAngle);
    ctx.stroke();
    clearGlow(ctx);
  }
}

function spawnCaveTurrets() {
  caveTurrets = [];
  const count = 4 + Math.floor(level / 2);
  for (let i = 0; i < count; i++) {
    const tx = 500 + Math.random() * (WORLD_W - 1000);
    if (Math.abs(tx - baseX - BASE_WIDTH / 2) < 400) continue;
    const onCeiling = Math.random() < 0.4 && ceilingTerrain;
    const ty = onCeiling ? getCeilingY(tx) : getTerrainY(tx);
    caveTurrets.push({
      x: tx, y: ty,
      alive: true, hp: 2,
      onCeiling,
      fireTimer: Math.random() * 90,
      isTarget: true
    });
    // Register as target building for level completion
    buildings.push({
      x: tx - 15, y: onCeiling ? ty : ty - 20, w: 30, h: 20,
      type: 'flak', hp: 2, alive: true,
      flakTimer: Math.random() * FLAK_INTERVAL | 0,
      isTarget: true,
      _caveTurret: caveTurrets[caveTurrets.length - 1]
    });
  }
}

function updateCaveTurrets(dt) {
  for (const ct of caveTurrets) {
    if (!ct.alive) continue;
    ct.fireTimer -= 1;
    if (ct.fireTimer <= 0) {
      ct.fireTimer = 70 + Math.random() * 30;
      // Shoot toward player
      const dx = player.x - ct.x;
      const dy = player.y - ct.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < 500 && dist > 30) {
        const speed = FLAK_SPEED * 0.8;
        flakShots.push({
          x: ct.x, y: ct.y + (ct.onCeiling ? 10 : -10),
          vx: (dx / dist) * speed,
          vy: (dy / dist) * speed,
          life: 2
        });
      }
    }
  }
}

function drawCaveTurrets() {
  for (const ct of caveTurrets) {
    if (!ct.alive) continue;
    neonGlow(ctx, '#f80', 6);
    ctx.strokeStyle = '#f80';
    ctx.lineWidth = 1.5;
    const dir = ct.onCeiling ? 1 : -1;
    // Base
    ctx.strokeRect(ct.x - 8, ct.y - (ct.onCeiling ? 0 : 12), 16, 12);
    // Barrel pointing toward player
    const angle = Math.atan2(player.y - ct.y, player.x - ct.x);
    ctx.beginPath();
    ctx.moveTo(ct.x, ct.y + dir * 6);
    ctx.lineTo(ct.x + Math.cos(angle) * 15, ct.y + dir * 6 + Math.sin(angle) * 15);
    ctx.stroke();
    clearGlow(ctx);
  }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  NORMANDY THEME ‚Äî Tanks, barrage balloons
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

function spawnTanks() {
  tanks = [];
  const count = 3 + Math.floor(level / 3);
  const beachStart = Math.floor(WORLD_W * 0.3);
  const beachEnd = Math.floor(WORLD_W * 0.75);
  for (let i = 0; i < count; i++) {
    const tx = beachStart + Math.random() * (beachEnd - beachStart);
    const ty = getTerrainY(tx);
    if (ty >= waterLineY - 5) continue; // skip water
    tanks.push({
      x: tx, y: ty,
      vx: (Math.random() < 0.5 ? 1 : -1) * (15 + Math.random() * 10),
      alive: true, hp: 3,
      fireTimer: Math.random() * 60,
      isTarget: true
    });
  }
}

function updateTanks(dt) {
  for (const tank of tanks) {
    if (!tank.alive) continue;
    tank.x += tank.vx * dt;
    tank.y = getTerrainY(tank.x);

    // Stay on land
    if (tank.y >= waterLineY - 5) tank.vx *= -1;
    if (tank.x < 200 || tank.x > WORLD_W - 200) tank.vx *= -1;

    // Fire flak upward at player
    tank.fireTimer -= 1;
    if (tank.fireTimer <= 0) {
      tank.fireTimer = 50 + Math.random() * 30;
      const dx = player.x - tank.x;
      const dy = player.y - tank.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < 600 && dist > 30 && player.y < tank.y) {
        const speed = FLAK_SPEED;
        flakShots.push({
          x: tank.x, y: tank.y - 10,
          vx: (dx / dist) * speed + (Math.random() - 0.5) * 30,
          vy: (dy / dist) * speed,
          life: 2
        });
      }
    }
  }
}

function drawTanks() {
  for (const tank of tanks) {
    if (!tank.alive) continue;
    const sx = tank.x, sy = tank.y;
    neonGlow(ctx, '#8a4', 6);
    ctx.strokeStyle = '#8a4';
    ctx.lineWidth = 1.5;

    // Treads
    ctx.strokeRect(sx - 12, sy - 4, 24, 6);
    // Hull
    ctx.strokeRect(sx - 8, sy - 8, 16, 5);
    // Turret
    ctx.beginPath();
    ctx.arc(sx, sy - 10, 5, Math.PI, 0);
    ctx.stroke();
    // Barrel
    const angle = Math.atan2(player.y - sy, player.x - sx);
    ctx.beginPath();
    ctx.moveTo(sx, sy - 12);
    ctx.lineTo(sx + Math.cos(angle) * 14, sy - 12 + Math.sin(angle) * 14);
    ctx.stroke();

    // HP dots
    if (tank.hp > 1) {
      ctx.fillStyle = '#8a4';
      ctx.font = '7px monospace';
      ctx.textAlign = 'center';
      ctx.fillText('‚óè'.repeat(tank.hp), sx, sy - 18);
    }
    clearGlow(ctx);
  }
}

function spawnBarrageBalloons() {
  barrageBalloons = [];
  const count = 3 + Math.floor(level / 4);
  const beachStart = Math.floor(WORLD_W * 0.25);
  const beachEnd = Math.floor(WORLD_W * 0.8);
  for (let i = 0; i < count; i++) {
    const bx = beachStart + (beachEnd - beachStart) * ((i + 0.5) / count);
    const groundY = getTerrainY(bx);
    if (groundY >= waterLineY - 5) continue;
    barrageBalloons.push({
      x: bx, y: groundY - 150 - Math.random() * 100,
      groundY,
      alive: true, hp: 2,
      sway: Math.random() * Math.PI * 2
    });
  }
}

function updateBarrageBalloons(dt) {
  for (const bb of barrageBalloons) {
    if (!bb.alive) continue;
    bb.sway += dt;
    bb.x += Math.sin(bb.sway * 0.5) * 0.3;

    // Cable collision with player
    if (!player.burning && player.invincible <= 0 && state === ST.PLAYING) {
      const cableX = bb.x + Math.sin(bb.sway * 0.5) * 5;
      if (Math.abs(player.x - cableX) < 8 && player.y > bb.y && player.y < bb.groundY) {
        damagePlayer(2);
        addExplosion(player.x, player.y, 10, false);
      }
    }

    // Balloon collision with bullets
    // (handled in bullet update loop)
  }
}

function drawBarrageBalloons() {
  for (const bb of barrageBalloons) {
    if (!bb.alive) continue;
    const sx = bb.x, sy = bb.y;
    const swayOff = Math.sin(bb.sway * 0.5) * 5;

    neonGlow(ctx, '#cc9', 6);
    ctx.strokeStyle = '#aa8';
    ctx.lineWidth = 1;

    // Cable from ground to balloon
    ctx.beginPath();
    ctx.moveTo(sx + swayOff * 0.3, bb.groundY);
    ctx.lineTo(sx + swayOff, sy + 12);
    ctx.stroke();

    // Balloon body
    ctx.strokeStyle = '#cc9';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.ellipse(sx + swayOff, sy, 10, 15, 0, 0, Math.PI * 2);
    ctx.stroke();

    // Fins
    ctx.beginPath();
    ctx.moveTo(sx + swayOff - 6, sy + 12);
    ctx.lineTo(sx + swayOff - 10, sy + 18);
    ctx.moveTo(sx + swayOff + 6, sy + 12);
    ctx.lineTo(sx + swayOff + 10, sy + 18);
    ctx.stroke();

    clearGlow(ctx);
  }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
//  FOREST THEME ‚Äî AA guns, trains
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

function spawnAAGuns() {
  aaGuns = [];
  const count = 4 + Math.floor(level / 3);
  for (let i = 0; i < count; i++) {
    const ax = 500 + Math.random() * (WORLD_W - 1000);
    if (Math.abs(ax - baseX - BASE_WIDTH / 2) < 400) continue;
    const ty = getTerrainY(ax);
    aaGuns.push({
      x: ax, y: ty,
      alive: true, hp: 2,
      hidden: true,
      revealTimer: 0,
      fireTimer: Math.random() * 80,
      isTarget: true
    });
  }
}

function updateAAGuns(dt) {
  for (const aa of aaGuns) {
    if (!aa.alive) continue;

    if (aa.revealTimer > 0) {
      aa.revealTimer -= dt;
      if (aa.revealTimer <= 0) aa.hidden = true;
    }

    aa.fireTimer -= 1;
    if (aa.fireTimer <= 0) {
      aa.fireTimer = 60 + Math.random() * 40;
      const dx = player.x - aa.x;
      const dy = player.y - aa.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < 500 && dist > 30) {
        aa.hidden = false;
        aa.revealTimer = 2;
        const speed = FLAK_SPEED;
        flakShots.push({
          x: aa.x, y: aa.y - 10,
          vx: (dx / dist) * speed + (Math.random() - 0.5) * 20,
          vy: (dy / dist) * speed,
          life: 2
        });
      }
    }
  }
}

function drawAAGuns() {
  for (const aa of aaGuns) {
    if (!aa.alive || aa.hidden) continue;
    const sx = aa.x, sy = aa.y;
    neonGlow(ctx, '#0f0', 6);
    ctx.strokeStyle = '#0a0';
    ctx.lineWidth = 1.5;
    // Base
    ctx.strokeRect(sx - 8, sy - 8, 16, 8);
    // Barrel
    const angle = Math.atan2(player.y - sy, player.x - sx);
    ctx.beginPath();
    ctx.moveTo(sx, sy - 8);
    ctx.lineTo(sx + Math.cos(angle) * 15, sy - 8 + Math.sin(angle) * 15);
    ctx.stroke();
    clearGlow(ctx);
  }
}

function spawnTrains() {
  trains = [];
  // Find flat track sections
  for (let x = 1000; x < WORLD_W - 1000; x += 100) {
    if (Math.abs(x - baseX) < 500) continue;
    // Check for flat section (track)
    const y1 = getTerrainY(x);
    const y2 = getTerrainY(x + 200);
    if (Math.abs(y1 - y2) < 3 && canopyHeight && canopyHeight[Math.floor(x)] === 0) {
      trains.push({
        x, y: y1,
        vx: 30, alive: true, hp: 6,
        segments: 4, segmentWidth: 25,
        trackStart: x - 100, trackEnd: x + 500
      });
      x += 3000; // space trains out
    }
  }
}

function updateTrains(dt) {
  for (const tr of trains) {
    if (!tr.alive) continue;
    tr.x += tr.vx * dt;
    tr.y = getTerrainY(tr.x);

    // Reverse at track ends
    if (tr.x <= tr.trackStart || tr.x >= tr.trackEnd) tr.vx *= -1;
  }
}

function drawTrains() {
  for (const tr of trains) {
    if (!tr.alive) continue;
    const dir = tr.vx > 0 ? 1 : -1;
    neonGlow(ctx, '#ff0', 6);

    for (let s = 0; s < tr.segments; s++) {
      const sx = tr.x - dir * s * (tr.segmentWidth + 3);
      const sy = tr.y;

      if (s === 0) {
        // Engine
        ctx.strokeStyle = '#ff0';
        ctx.lineWidth = 1.5;
        ctx.strokeRect(sx - 12, sy - 12, 24, 12);
        // Smokestack
        ctx.strokeRect(sx + dir * 6, sy - 16, 5, 4);
        // Smoke
        if (Math.random() < 0.1) {
          addParticle(sx + dir * 8, sy - 16, dir * 10 + (Math.random() - 0.5) * 10, -15, 0.5, '#555', 2);
        }
      } else {
        // Cargo car
        ctx.strokeStyle = '#aa0';
        ctx.lineWidth = 1;
        ctx.strokeRect(sx - 10, sy - 10, 20, 10);
      }
      // Wheels
      ctx.fillStyle = '#880';
      ctx.fillRect(sx - 8, sy - 2, 4, 3);
      ctx.fillRect(sx + 4, sy - 2, 4, 3);
    }

    // HP
    if (tr.hp > 1) {
      ctx.fillStyle = '#ff0';
      ctx.font = '7px monospace';
      ctx.textAlign = 'center';
      ctx.fillText('‚óè'.repeat(Math.min(tr.hp, 6)), tr.x, tr.y - 22);
    }
    clearGlow(ctx);
  }
}

function drawBuilding(bld) {
  const col = buildingColors[bld.type] || '#fa0';
  neonGlow(ctx, col, 8);
  ctx.strokeStyle = col;
  ctx.lineWidth = 1.5;
  ctx.strokeRect(bld.x, bld.y, bld.w, bld.h);

  // Inner detail per type
  if (bld.type === 'factory') {
    ctx.strokeRect(bld.x + bld.w - 10, bld.y - 15, 8, 15);
    if (Math.random() < 0.05) {
      addParticle(bld.x + bld.w - 6, bld.y - 15, (Math.random() - 0.5) * 10, -20, 0.5, '#555', 2);
    }
  } else if (bld.type === 'flak') {
    ctx.beginPath();
    ctx.moveTo(bld.x + bld.w / 2, bld.y);
    ctx.lineTo(bld.x + bld.w / 2, bld.y - 12);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(bld.x + bld.w / 2 - 6, bld.y - 10);
    ctx.lineTo(bld.x + bld.w / 2 + 6, bld.y - 10);
    ctx.stroke();
  } else if (bld.type === 'hangar') {
    ctx.beginPath();
    ctx.arc(bld.x + bld.w / 2, bld.y + bld.h, bld.w * 0.35, Math.PI, 0);
    ctx.stroke();
  } else if (bld.type === 'dam') {
    // Vertical buttress lines
    for (let bx = bld.x + 15; bx < bld.x + bld.w - 10; bx += 20) {
      ctx.beginPath();
      ctx.moveTo(bx, bld.y);
      ctx.lineTo(bx, bld.y + bld.h);
      ctx.stroke();
    }
    // Wavy water line on upstream (left) side
    ctx.strokeStyle = '#0af';
    ctx.lineWidth = 1;
    ctx.beginPath();
    for (let wx = bld.x - 40; wx < bld.x; wx += 3) {
      const wy = bld.y + bld.h - 5 + Math.sin(Date.now() * 0.004 + wx * 0.2) * 3;
      if (wx === bld.x - 40) ctx.moveTo(wx, wy);
      else ctx.lineTo(wx, wy);
    }
    ctx.stroke();
    // Label
    ctx.strokeStyle = col;
    ctx.fillStyle = col;
    ctx.font = '7px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('DAM', bld.x + bld.w / 2, bld.y + bld.h / 2 + 3);
  } else if (bld.type === 'radar_station') {
    // Base rectangle already drawn
    // Antenna mast
    const cx = bld.x + bld.w / 2;
    ctx.beginPath();
    ctx.moveTo(cx, bld.y);
    ctx.lineTo(cx, bld.y - 20);
    ctx.stroke();
    // Rotating dish (animated arc)
    const dishAngle = (Date.now() * 0.003) % (Math.PI * 2);
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(cx, bld.y - 20, 8, dishAngle, dishAngle + Math.PI * 0.6);
    ctx.stroke();
    ctx.lineWidth = 1.5;
  } else if (bld.type === 'fuel_depot') {
    // Cylindrical tank shapes (arcs) inside
    for (let t = 0; t < 3; t++) {
      const tx = bld.x + 8 + t * 13;
      ctx.beginPath();
      ctx.arc(tx, bld.y + bld.h, 8, Math.PI, 0);
      ctx.stroke();
    }
    // Diagonal hazard stripes
    ctx.lineWidth = 1;
    ctx.setLineDash([4, 4]);
    ctx.beginPath();
    ctx.moveTo(bld.x, bld.y + bld.h);
    ctx.lineTo(bld.x + bld.w, bld.y);
    ctx.stroke();
    ctx.setLineDash([]);
    // Occasional orange smoke
    if (Math.random() < 0.03) {
      addParticle(bld.x + bld.w / 2, bld.y, (Math.random()-0.5)*8, -15, 0.4, '#f80', 2);
    }
  } else if (bld.type === 'bunker') {
    // Rounded top (arc)
    ctx.beginPath();
    ctx.arc(bld.x + bld.w / 2, bld.y, bld.w / 2, Math.PI, 0);
    ctx.stroke();
    // Gun slit
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(bld.x + 5, bld.y + 5);
    ctx.lineTo(bld.x + bld.w - 5, bld.y + 5);
    ctx.stroke();
  } else if (bld.type === 'heavyBunker') {
    // Double-thick rounded top
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(bld.x + bld.w / 2, bld.y, bld.w / 2, Math.PI, 0);
    ctx.stroke();
    ctx.lineWidth = 1.5;
    // Double gun slit
    ctx.beginPath();
    ctx.moveTo(bld.x + 5, bld.y + 5);
    ctx.lineTo(bld.x + bld.w - 5, bld.y + 5);
    ctx.moveTo(bld.x + 5, bld.y + 10);
    ctx.lineTo(bld.x + bld.w - 5, bld.y + 10);
    ctx.stroke();
    // Flak barrel on top
    ctx.beginPath();
    ctx.moveTo(bld.x + bld.w / 2, bld.y - bld.w / 2 + 5);
    ctx.lineTo(bld.x + bld.w / 2, bld.y - bld.w / 2 - 8);
    ctx.stroke();
  } else if (bld.type === 'observation_tower') {
    // Tall narrow tower
    ctx.strokeRect(bld.x + 4, bld.y + 15, 12, bld.h - 15);
    // Wider observation room at top
    ctx.strokeRect(bld.x, bld.y, bld.w, 15);
    // Antenna
    ctx.beginPath();
    ctx.moveTo(bld.x + bld.w / 2, bld.y);
    ctx.lineTo(bld.x + bld.w / 2, bld.y - 12);
    ctx.stroke();
    // Rotating dish
    const angle = (Date.now() * 0.004) % (Math.PI * 2);
    ctx.beginPath();
    ctx.arc(bld.x + bld.w / 2, bld.y - 12, 6, angle, angle + Math.PI * 0.5);
    ctx.stroke();
  }

  // HP indicator
  if (bld.hp > 1) {
    ctx.fillStyle = col;
    ctx.font = '8px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('‚óè'.repeat(Math.min(bld.hp, 8)), bld.x + bld.w / 2, bld.y - 4);
  }
  clearGlow(ctx);
}

function drawOx(o) {
  neonGlow(ctx, '#0f0', 6);
  ctx.strokeStyle = '#0f0';
  ctx.lineWidth = 1.5;

  // Body
  ctx.strokeRect(o.x + 3, o.y + 1, 14, 6);
  // Legs
  ctx.beginPath();
  ctx.moveTo(o.x + 5, o.y + 7); ctx.lineTo(o.x + 5, o.y + 10);
  ctx.moveTo(o.x + 8, o.y + 7); ctx.lineTo(o.x + 8, o.y + 10);
  ctx.moveTo(o.x + 13, o.y + 7); ctx.lineTo(o.x + 13, o.y + 10);
  ctx.moveTo(o.x + 16, o.y + 7); ctx.lineTo(o.x + 16, o.y + 10);
  ctx.stroke();
  // Head
  const headX = o.dir > 0 ? o.x + 17 : o.x + 3;
  ctx.strokeRect(headX - 2, o.y - 1, 4, 4);
  // Horns
  ctx.beginPath();
  ctx.moveTo(headX - 2, o.y - 1); ctx.lineTo(headX - 4, o.y - 3);
  ctx.moveTo(headX + 2, o.y - 1); ctx.lineTo(headX + 4, o.y - 3);
  ctx.stroke();
  clearGlow(ctx);
}

function drawTitle(W, H) {
  // Animated background stars
  ctx.fillStyle = '#fff';
  for (const s of stars) {
    const sx = (s.x * 0.1 + Date.now() * 0.005) % W;
    const sy = s.y;
    if (sy > H) continue;
    ctx.globalAlpha = s.b + Math.sin(Date.now() * 0.003 + s.x) * 0.1;
    ctx.fillRect(sx, sy, s.s, s.s);
  }
  ctx.globalAlpha = 1;

  // Title
  neonGlow(ctx, '#0ff', 20);
  ctx.fillStyle = '#0ff';
  ctx.font = `bold ${Math.min(60, W * 0.08)}px "Courier New", monospace`;
  ctx.textAlign = 'center';
  ctx.fillText('NEON SOPWITH', W / 2, H * 0.25);
  clearGlow(ctx);

  neonGlow(ctx, '#0af', 10);
  ctx.fillStyle = '#0af';
  ctx.font = `${Math.min(18, W * 0.025)}px "Courier New", monospace`;
  ctx.fillText('A Retro Biplane Shooter', W / 2, H * 0.25 + 35);
  clearGlow(ctx);

  // Animated biplane
  titlePlaneX += 2;
  if (titlePlaneX > W + 200) titlePlaneX = -200;
  const titlePlaneY = H * 0.4 + Math.sin(Date.now() * 0.002) * 15;
  drawBiplane(ctx, titlePlaneX, titlePlaneY, Math.sin(Date.now() * 0.001) * 0.1, false, '#0ff', 2);
  // Engine trail
  for (let i = 0; i < 3; i++) {
    addParticle(titlePlaneX - 40 - i * 10, titlePlaneY + (Math.random() - 0.5) * 5, -30, (Math.random() - 0.5) * 10, 0.3, '#08f', 2);
  }
  // Update & draw title particles
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx * 0.016;
    p.y += p.vy * 0.016;
    p.life -= 0.016;
    if (p.life <= 0) { particles.splice(i, 1); continue; }
    ctx.globalAlpha = p.life / p.maxLife;
    ctx.fillStyle = p.color;
    ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
  }
  ctx.globalAlpha = 1;

  // All-time medals display
  if (allTimeMedals.size > 0) {
    ctx.font = `${Math.min(10, W * 0.015)}px "Courier New", monospace`;
    ctx.fillStyle = '#556';
    ctx.fillText('DECORATIONS', W / 2, H * 0.48);
    let mi = 0;
    const medalArr = [...allTimeMedals];
    const medalW = Math.min(W * 0.7, medalArr.length * 100);
    const startMX = W / 2 - medalW / 2 + 50;
    for (const key of medalArr) {
      const m = MEDALS[key];
      neonGlow(ctx, m.color, 4);
      ctx.fillStyle = m.color;
      ctx.font = `${Math.min(9, W * 0.013)}px "Courier New", monospace`;
      ctx.textAlign = 'center';
      ctx.fillText(`${m.icon} ${m.name}`, startMX + mi * 100, H * 0.48 + 14);
      mi++;
    }
    clearGlow(ctx);
  }

  // Blinking "Press ENTER"
  if (Math.sin(Date.now() * 0.004) > 0) {
    neonGlow(ctx, '#fff', 8);
    ctx.fillStyle = '#fff';
    ctx.font = `${Math.min(20, W * 0.03)}px "Courier New", monospace`;
    ctx.fillText('PRESS ENTER TO START', W / 2, H * 0.55);
    clearGlow(ctx);
  }

  // Controls
  const ctrls = [
    [', or Arrow Up', 'Nose Up + Accelerate'],
    ['/ or Arrow Down', 'Nose Down'],
    ['X', 'Accelerate'],
    ['Space', 'Machine Gun'],
    ['B', 'Drop Bomb'],
    ['H', 'Autopilot Home'],
  ];
  ctx.fillStyle = '#557';
  ctx.font = `${Math.min(12, W * 0.018)}px "Courier New", monospace`;
  const startY = H * 0.65;
  ctx.textAlign = 'center';
  ctx.fillText('‚îÄ‚îÄ‚îÄ CONTROLS ‚îÄ‚îÄ‚îÄ', W / 2, startY - 15);
  ctx.textAlign = 'left';
  for (let i = 0; i < ctrls.length; i++) {
    const cx = W / 2 - 160;
    const cy = startY + i * 22;
    ctx.fillStyle = '#0af';
    ctx.fillText(ctrls[i][0].padEnd(16), cx, cy);
    ctx.fillStyle = '#667';
    ctx.fillText(ctrls[i][1], cx + 170, cy);
  }

  // Footer
  ctx.textAlign = 'center';
  ctx.fillStyle = '#334';
  ctx.font = `${Math.min(11, W * 0.015)}px "Courier New", monospace`;
  ctx.fillText('Inspired by Sopwith (1984) by BMB Compuscience', W / 2, H * 0.95);
}

function drawRadar() {
  const rW = radarCanvas.width;
  const rH = radarCanvas.height;
  rctx.fillStyle = '#08080c';
  rctx.fillRect(0, 0, rW, rH);

  const scale = rW / WORLD_W;

  // Terrain silhouette
  const tc = THEME_CONFIG[getLevelTheme(level)];
  rctx.strokeStyle = tc.hasWater ? '#05a' : (tc.terrainColor === '#f80' ? '#840' : '#0a3');
  rctx.lineWidth = 1;
  rctx.beginPath();
  for (let x = 0; x < WORLD_W; x += 20) {
    const rx = x * scale;
    const ry = rH - (rH * 0.6 - terrain[x] * scale * 0.5);
    if (x === 0) rctx.moveTo(rx, Math.min(rH, ry));
    else rctx.lineTo(rx, Math.min(rH, ry));
  }
  rctx.stroke();

  // Base
  rctx.fillStyle = '#0af';
  rctx.fillRect(baseX * scale - 1, 2, Math.max(3, BASE_WIDTH * scale), 4);

  // Buildings (color-coded by type)
  for (const bld of buildings) {
    if (!bld.alive) continue;
    rctx.fillStyle = buildingColors[bld.type] || '#f44';
    rctx.fillRect(bld.x * scale, rH * 0.4, Math.max(2, bld.w * scale), 3);
  }

  // Enemies (color-coded by type)
  for (const en of enemies) {
    if (!en.alive || en.state === 'hangar') continue;
    const spec = ENEMY_SPECS[en.type];
    rctx.fillStyle = spec.color;
    const sz = en.type === 'zeppelin' ? 5 : 3;
    rctx.fillRect(en.x * scale - 1, en.y * scale * 0.05 + 5, sz, sz);
  }

  // Dragons
  for (const d of dragons) {
    if (!d.alive) continue;
    rctx.fillStyle = '#f40';
    rctx.fillRect(d.x * scale - 2, d.y * scale * 0.05 + 5, 4, 4);
  }

  // Submarines
  for (const sub of submarines) {
    if (!sub.alive) continue;
    rctx.fillStyle = sub.surfaced ? '#48f' : 'rgba(68, 136, 255, 0.3)';
    rctx.fillRect(sub.x * scale - 2, rH * 0.6, 4, 3);
  }

  // Speedboats
  for (const sb of speedboats) {
    if (!sb.alive) continue;
    rctx.fillStyle = '#0f0';
    rctx.fillRect(sb.x * scale - 1, rH * 0.6, 3, 2);
  }

  // Theme-specific radar blips
  for (const ft of fuelTankers) {
    if (!ft.alive) continue;
    rctx.fillStyle = '#0af';
    rctx.fillRect(ft.x * scale - 2, ft.y * scale * 0.05 + 5, 5, 3);
  }
  for (const tank of tanks) {
    if (!tank.alive) continue;
    rctx.fillStyle = '#8a4';
    rctx.fillRect(tank.x * scale - 1, rH * 0.5, 3, 3);
  }
  for (const bb of barrageBalloons) {
    if (!bb.alive) continue;
    rctx.fillStyle = '#cc9';
    rctx.fillRect(bb.x * scale - 1, bb.y * scale * 0.05 + 5, 3, 3);
  }
  for (const aa of aaGuns) {
    if (!aa.alive) continue;
    rctx.fillStyle = aa.hidden ? 'rgba(0,160,0,0.2)' : '#0f0';
    rctx.fillRect(aa.x * scale - 1, rH * 0.5, 3, 3);
  }
  for (const tr of trains) {
    if (!tr.alive) continue;
    rctx.fillStyle = '#ff0';
    rctx.fillRect(tr.x * scale - 2, rH * 0.5, 5, 3);
  }

  // Player
  if (state === ST.PLAYING || state === ST.LEVEL_COMPLETE) {
    rctx.fillStyle = '#0ff';
    rctx.fillRect(player.x * scale - 2, player.y * scale * 0.05 + 5, 5, 4);
  }

  // Viewport indicator
  rctx.strokeStyle = '#225';
  rctx.lineWidth = 1;
  const viewL = camX * scale;
  const viewW = canvas.width * scale;
  rctx.strokeRect(viewL, 0, viewW, rH);
}

function drawRadarEmpty() {
  const rW = radarCanvas.width;
  const rH = radarCanvas.height;
  rctx.fillStyle = '#08080c';
  rctx.fillRect(0, 0, rW, rH);
  rctx.fillStyle = '#1a1a2a';
  rctx.font = '10px "Courier New", monospace';
  rctx.textAlign = 'center';
  rctx.fillText('RADAR', rW / 2, rH / 2 + 3);
}

// ‚îÄ‚îÄ Cockpit instrument gauges (next to radar scope, compact) ‚îÄ‚îÄ
function drawCockpitGauges(W, H) {
  const p = player;
  // Match radar scope positioning
  const radarR = Math.min(W, H) * 0.12;
  const radarCx = 20 + radarR + 8;
  const radarCy = H - 20 - radarR - 8;

  // Tiny gauges arranged in a 2x2 grid to the right of the radar
  const gr = radarR * 0.32; // gauge radius ‚Äî much smaller than radar
  const baseX = radarCx + radarR + gr + 12; // right of radar circle
  const baseY = radarCy - radarR + gr + 2;  // top-aligned with radar
  const gapX = gr * 2.3;
  const gapY = gr * 2.3;

  const gauges = [
    { label: 'SPD', value: p.speed / PLANE_MAX_SPEED, raw: Math.round(p.speed * PIXELS_PER_UNIT), unit: '', color: '#0ff', warnBelow: 0.3 },
    { label: 'ALT', value: Math.max(0, 1 - p.y / (canvas.height * 0.8)), raw: Math.max(0, Math.round((canvas.height * 0.75 - p.y) / 3)), unit: '', color: '#0fa', warnBelow: 0.15 },
    { label: 'FUEL', value: p.fuel / MAX_FUEL, raw: Math.round(p.fuel / MAX_FUEL * 100), unit: '%', color: '#0f0', warnBelow: 0.2 },
    { label: 'HP', value: p.hp / PLAYER_MAX_HP, raw: p.hp, unit: '/' + PLAYER_MAX_HP, color: '#0ff', warnBelow: 0.34 }
  ];

  for (let i = 0; i < gauges.length; i++) {
    const g = gauges[i];
    const col2 = Math.floor(i / 2);  // 0 or 1
    const row = i % 2;
    const cx = baseX + col2 * gapX;
    const cy = baseY + row * gapY;
    const val = Math.max(0, Math.min(1, g.value));
    const isWarning = val <= g.warnBelow;
    const col = isWarning ? '#f44' : g.color;

    // Background
    ctx.beginPath();
    ctx.arc(cx, cy, gr, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(0, 10, 20, 0.6)';
    ctx.fill();
    ctx.strokeStyle = 'rgba(0, 180, 100, 0.15)';
    ctx.lineWidth = 0.5;
    ctx.stroke();

    // Arc (270¬∞ sweep from 135¬∞ to 405¬∞)
    const arcStart = Math.PI * 0.75;
    const arcEnd = Math.PI * 2.25;
    const valAngle = arcStart + (arcEnd - arcStart) * val;

    // Dim track
    ctx.beginPath();
    ctx.arc(cx, cy, gr * 0.7, arcStart, arcEnd);
    ctx.strokeStyle = 'rgba(0, 180, 100, 0.1)';
    ctx.lineWidth = 1.5;
    ctx.stroke();

    // Value arc
    neonGlow(ctx, col, 3);
    ctx.beginPath();
    ctx.arc(cx, cy, gr * 0.7, arcStart, valAngle);
    ctx.strokeStyle = col;
    ctx.lineWidth = 1.5;
    ctx.stroke();

    // Needle
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.lineTo(cx + Math.cos(valAngle) * gr * 0.55, cy + Math.sin(valAngle) * gr * 0.55);
    ctx.strokeStyle = col;
    ctx.lineWidth = 1;
    ctx.stroke();
    clearGlow(ctx);

    // Center dot
    ctx.beginPath();
    ctx.arc(cx, cy, 1, 0, Math.PI * 2);
    ctx.fillStyle = col;
    ctx.fill();

    // Label (tiny, below center)
    ctx.fillStyle = 'rgba(0, 180, 100, 0.4)';
    ctx.font = Math.max(6, Math.round(gr * 0.4)) + 'px "Courier New", monospace';
    ctx.textAlign = 'center';
    ctx.fillText(g.label, cx, cy + gr * 0.4);

    // Numeric value (above center)
    ctx.fillStyle = col;
    ctx.font = 'bold ' + Math.max(7, Math.round(gr * 0.45)) + 'px "Courier New", monospace';
    ctx.fillText(g.raw + g.unit, cx, cy - gr * 0.1);
  }
}

// ‚îÄ‚îÄ Circular radar scope (in-game HUD) ‚îÄ‚îÄ
let radarSweepAngle = 0;

function drawRadarScope(W, H) {
  const R = Math.min(W, H) * 0.12;         // radius scales with screen
  const cx = 20 + R + 8;                     // center X (bottom-left)
  const cy = H - 20 - R - 8;                // center Y
  const RANGE = 1200;                        // world-unit detection range
  const scale = R / RANGE;

  // ‚îÄ‚îÄ Background ‚îÄ‚îÄ
  ctx.save();
  ctx.globalAlpha = 0.7;
  ctx.beginPath();
  ctx.arc(cx, cy, R + 6, 0, Math.PI * 2);
  ctx.fillStyle = '#040810';
  ctx.fill();
  ctx.globalAlpha = 1;

  // Clip to circle
  ctx.save();
  ctx.beginPath();
  ctx.arc(cx, cy, R + 1, 0, Math.PI * 2);
  ctx.clip();

  // ‚îÄ‚îÄ Sweep fade trail (ghosting effect) ‚îÄ‚îÄ
  ctx.fillStyle = 'rgba(4, 8, 16, 0.15)';
  ctx.fillRect(cx - R - 2, cy - R - 2, (R + 2) * 2, (R + 2) * 2);

  // ‚îÄ‚îÄ Sweep line (cosmetic rotation, not tied to heading) ‚îÄ‚îÄ
  radarSweepAngle += 0.03;
  if (radarSweepAngle > Math.PI * 2) radarSweepAngle -= Math.PI * 2;
  const sweepAng = radarSweepAngle;

  // Draw sweep as a filled wedge with gradient
  ctx.globalAlpha = 0.35;
  for (let i = 0; i < 12; i++) {
    const a0 = sweepAng - (i + 1) * 0.05;
    const a1 = sweepAng - i * 0.05;
    const alpha = 0.35 * (1 - i / 12);
    ctx.fillStyle = `rgba(0, 255, 128, ${alpha})`;
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.arc(cx, cy, R, a0, a1);
    ctx.closePath();
    ctx.fill();
  }
  ctx.globalAlpha = 1;

  // Bright sweep line
  neonGlow(ctx, '#0f8', 6);
  ctx.strokeStyle = '#0fa';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.moveTo(cx, cy);
  ctx.lineTo(cx + Math.cos(sweepAng) * R, cy + Math.sin(sweepAng) * R);
  ctx.stroke();
  clearGlow(ctx);

  // ‚îÄ‚îÄ Terrain contour in scope ‚îÄ‚îÄ
  ctx.strokeStyle = 'rgba(0, 200, 80, 0.25)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  let terrainStarted = false;
  const terrainSamples = 60;
  for (let i = 0; i <= terrainSamples; i++) {
    const worldX = player.x - RANGE + (2 * RANGE * i / terrainSamples);
    const wrappedX = ((worldX % WORLD_W) + WORLD_W) % WORLD_W;
    const ty = getTerrainY(wrappedX);
    // Map: dx = worldX - player.x ‚Üí horizontal on scope; dy = ty - player.y ‚Üí vertical on scope
    const dx = worldX - player.x;
    const dy = ty - player.y;
    const sx = cx + dx * scale;
    const sy = cy + dy * scale;
    if (!terrainStarted) { ctx.moveTo(sx, sy); terrainStarted = true; }
    else ctx.lineTo(sx, sy);
  }
  ctx.stroke();

  // ‚îÄ‚îÄ Range rings ‚îÄ‚îÄ
  ctx.strokeStyle = 'rgba(0, 180, 80, 0.2)';
  ctx.lineWidth = 0.5;
  for (let ring = 1; ring <= 3; ring++) {
    ctx.beginPath();
    ctx.arc(cx, cy, R * ring / 3, 0, Math.PI * 2);
    ctx.stroke();
  }

  // ‚îÄ‚îÄ Crosshair lines ‚îÄ‚îÄ
  ctx.strokeStyle = 'rgba(0, 180, 80, 0.15)';
  ctx.beginPath();
  ctx.moveTo(cx - R, cy); ctx.lineTo(cx + R, cy);
  ctx.moveTo(cx, cy - R); ctx.lineTo(cx, cy + R);
  ctx.stroke();

  // ‚îÄ‚îÄ Cardinal labels (N/S/E/W) ‚îÄ‚îÄ
  ctx.fillStyle = 'rgba(0, 180, 80, 0.4)';
  ctx.font = '7px "Courier New", monospace';
  ctx.textAlign = 'center';
  ctx.fillText('N', cx, cy - R + 8);
  ctx.fillText('S', cx, cy + R - 3);
  ctx.textAlign = 'left';
  ctx.fillText('E', cx + R - 8, cy + 3);
  ctx.textAlign = 'right';
  ctx.fillText('W', cx - R + 8, cy + 3);
  ctx.textAlign = 'center';

  // ‚îÄ‚îÄ Helper: world pos ‚Üí scope pos (stationary ‚Äî north=up, world X‚Üíhorizontal) ‚îÄ‚îÄ
  function toScope(wx, wy) {
    let dx = wx - player.x;
    let dy = wy - player.y;
    // Handle world wrapping
    if (dx > WORLD_W / 2) dx -= WORLD_W;
    if (dx < -WORLD_W / 2) dx += WORLD_W;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist > RANGE) return null;
    // Map directly: world X ‚Üí screen horizontal, world Y ‚Üí screen vertical (no rotation)
    return { x: cx + dx * scale, y: cy + dy * scale, dist };
  }

  // ‚îÄ‚îÄ Helper: draw a chevron blip (small V pointing in travel direction) ‚îÄ‚îÄ
  function drawChevron(sx, sy, angle, color, size) {
    neonGlow(ctx, color, 6);
    ctx.strokeStyle = color;
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    // Chevron: two lines from tip pointing in angle direction
    const tipX = sx + Math.cos(angle) * size;
    const tipY = sy + Math.sin(angle) * size;
    const leftX = sx + Math.cos(angle + 2.5) * size;
    const leftY = sy + Math.sin(angle + 2.5) * size;
    const rightX = sx + Math.cos(angle - 2.5) * size;
    const rightY = sy + Math.sin(angle - 2.5) * size;
    ctx.moveTo(leftX, leftY);
    ctx.lineTo(tipX, tipY);
    ctx.lineTo(rightX, rightY);
    ctx.stroke();
    clearGlow(ctx);
  }

  // ‚îÄ‚îÄ Helper: draw a square blip for buildings ‚îÄ‚îÄ
  function drawSquareBlip(sx, sy, color, size) {
    ctx.fillStyle = color;
    ctx.globalAlpha = 0.7;
    ctx.fillRect(sx - size, sy - size, size * 2, size * 2);
    ctx.globalAlpha = 1;
  }

  // ‚îÄ‚îÄ Helper: draw a diamond blip for dragons ‚îÄ‚îÄ
  function drawDiamondBlip(sx, sy, color, size) {
    neonGlow(ctx, color, 6);
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.moveTo(sx, sy - size);
    ctx.lineTo(sx + size, sy);
    ctx.lineTo(sx, sy + size);
    ctx.lineTo(sx - size, sy);
    ctx.closePath();
    ctx.fill();
    clearGlow(ctx);
  }

  // ‚îÄ‚îÄ Home base marker ‚îÄ‚îÄ
  const bp = toScope(baseX + BASE_WIDTH / 2, getTerrainY(baseX + BASE_WIDTH / 2));
  if (bp) {
    neonGlow(ctx, '#0af', 6);
    ctx.fillStyle = '#0af';
    ctx.font = 'bold 8px "Courier New", monospace';
    ctx.textAlign = 'center';
    ctx.fillText('H', bp.x, bp.y + 3);
    clearGlow(ctx);
  }

  // ‚îÄ‚îÄ Enemies (chevrons pointing in travel direction) ‚îÄ‚îÄ
  for (const en of enemies) {
    if (!en.alive || en.state === 'hangar') continue;
    const p = toScope(en.x, en.y);
    if (!p) continue;
    const spec = ENEMY_SPECS[en.type];
    if (en.type === 'zeppelin') {
      // Zeppelins: larger rectangle blip
      ctx.fillStyle = spec.color;
      ctx.globalAlpha = 0.7;
      ctx.fillRect(p.x - 3, p.y - 1.5, 6, 3);
      ctx.globalAlpha = 1;
    } else {
      const sz = en.type === 'bomber' ? 4 : 3;
      drawChevron(p.x, p.y, en.angle, spec.color, sz);
    }
  }

  // ‚îÄ‚îÄ Dragons (diamond blip) ‚îÄ‚îÄ
  for (const d of dragons) {
    if (!d.alive) continue;
    const p = toScope(d.x, d.y);
    if (!p) continue;
    drawDiamondBlip(p.x, p.y, '#f40', 3);
  }

  // ‚îÄ‚îÄ Submarines (for sea levels) ‚îÄ‚îÄ
  if (typeof submarines !== 'undefined') {
    for (const sub of submarines) {
      if (!sub.alive) continue;
      const p = toScope(sub.x, sub.y);
      if (!p) continue;
      ctx.fillStyle = '#48f';
      ctx.globalAlpha = sub.surfaced ? 0.8 : 0.3;
      ctx.fillRect(p.x - 2, p.y - 1, 4, 2);
      ctx.globalAlpha = 1;
    }
  }

  // ‚îÄ‚îÄ Theme-specific entities on scope ‚îÄ‚îÄ
  for (const ft of fuelTankers) {
    if (!ft.alive) continue;
    const p = toScope(ft.x, ft.y);
    if (p) { ctx.fillStyle = '#0af'; ctx.fillRect(p.x - 3, p.y - 1.5, 6, 3); }
  }
  for (const tank of tanks) {
    if (!tank.alive) continue;
    const p = toScope(tank.x, tank.y);
    if (p) drawSquareBlip(p.x, p.y, '#8a4', 2);
  }
  for (const bb of barrageBalloons) {
    if (!bb.alive) continue;
    const p = toScope(bb.x, bb.y);
    if (p) drawDiamondBlip(p.x, p.y, '#cc9', 2);
  }
  for (const tr of trains) {
    if (!tr.alive) continue;
    const p = toScope(tr.x, tr.y);
    if (p) { ctx.fillStyle = '#ff0'; ctx.fillRect(p.x - 3, p.y - 1, 6, 2); }
  }
  for (const aa of aaGuns) {
    if (!aa.alive) continue;
    const p = toScope(aa.x, aa.y);
    if (p) drawSquareBlip(p.x, p.y, aa.hidden ? 'rgba(0,160,0,0.2)' : '#0f0', 1.5);
  }

  // ‚îÄ‚îÄ Buildings (all types ‚Äî small squares, color-coded) ‚îÄ‚îÄ
  for (const bld of buildings) {
    if (!bld.alive) continue;
    const p = toScope(bld.x + bld.w / 2, bld.y);
    if (!p) continue;
    drawSquareBlip(p.x, p.y, buildingColors[bld.type] || '#fa0', 1.5);
  }

  // ‚îÄ‚îÄ Bird flocks (goose/eagle only ‚Äî dangerous ones, tiny dots) ‚îÄ‚îÄ
  for (const bg of birds) {
    if (bg.type === 'sparrow') continue;
    const leader = bg.flock.find(b => b.alive);
    if (!leader) continue;
    const p = toScope(leader.x, leader.y);
    if (!p) continue;
    ctx.fillStyle = bg.type === 'eagle' ? '#a72' : '#dda';
    ctx.globalAlpha = 0.5;
    ctx.beginPath();
    ctx.arc(p.x, p.y, 1.5, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
  }

  // ‚îÄ‚îÄ Flak shots (incoming ‚Äî tiny yellow dots) ‚îÄ‚îÄ
  for (const f of flakShots) {
    const p = toScope(f.x, f.y);
    if (!p) continue;
    ctx.fillStyle = '#ff0';
    ctx.globalAlpha = 0.4;
    ctx.fillRect(p.x - 0.5, p.y - 0.5, 1, 1);
    ctx.globalAlpha = 1;
  }

  // ‚îÄ‚îÄ Enemy bombs (incoming) ‚îÄ‚îÄ
  for (const b of bombs) {
    if (b.friendly !== false) continue;
    const p = toScope(b.x, b.y);
    if (!p) continue;
    ctx.fillStyle = '#f55';
    ctx.globalAlpha = 0.5;
    ctx.fillRect(p.x - 1, p.y - 1, 2, 2);
    ctx.globalAlpha = 1;
  }

  // ‚îÄ‚îÄ Player center icon (small plane shape pointing in travel direction) ‚îÄ‚îÄ
  const planeRad = getPlaneRadians(player);
  neonGlow(ctx, '#0ff', 8);
  ctx.strokeStyle = '#0ff';
  ctx.lineWidth = 1.5;
  // Small plane icon: nose + two wing stubs
  const noseX = cx + Math.cos(planeRad) * 5;
  const noseY = cy + Math.sin(planeRad) * 5;
  const tailX = cx - Math.cos(planeRad) * 4;
  const tailY = cy - Math.sin(planeRad) * 4;
  const wingPerp = planeRad + Math.PI / 2;
  ctx.beginPath();
  ctx.moveTo(tailX, tailY);
  ctx.lineTo(noseX, noseY);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(cx + Math.cos(wingPerp) * 4, cy + Math.sin(wingPerp) * 4);
  ctx.lineTo(cx - Math.cos(wingPerp) * 4, cy - Math.sin(wingPerp) * 4);
  ctx.stroke();
  clearGlow(ctx);

  ctx.restore(); // end clip

  // ‚îÄ‚îÄ Bezel ring ‚îÄ‚îÄ
  neonGlow(ctx, '#0a4', 4);
  ctx.strokeStyle = '#0a4';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(cx, cy, R + 3, 0, Math.PI * 2);
  ctx.stroke();

  // Outer thin ring
  ctx.strokeStyle = '#052';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.arc(cx, cy, R + 6, 0, Math.PI * 2);
  ctx.stroke();
  clearGlow(ctx);

  // ‚îÄ‚îÄ Label ‚îÄ‚îÄ
  ctx.fillStyle = '#0a4';
  ctx.globalAlpha = 0.6;
  ctx.font = '8px "Courier New", monospace';
  ctx.textAlign = 'center';
  ctx.fillText('RDR', cx, cy + R + 14);
  ctx.globalAlpha = 1;

  ctx.restore(); // end save from top
}

// ‚îÄ‚îÄ Game loop ‚îÄ‚îÄ
function gameLoop(timestamp) {
  if (!lastTime) lastTime = timestamp;
  let dt = (timestamp - lastTime) / 1000;
  lastTime = timestamp;
  if (dt > 0.05) dt = 0.05; // cap delta

  handleInput();
  update(dt);
  draw();
  requestAnimationFrame(gameLoop);
}

function handleInput() {
  if (keys['Enter']) {
    keys['Enter'] = false;
    if (state === ST.TITLE || state === ST.GAME_OVER) {
      initAudio();
      level = 1;
      score = 0;
      lives = 5;
      earnedMedals = new Set();
      flightStats = { kills: 0, damageTaken: 0, valour: 0 };
      initLevel();
      state = ST.PLAYING;
      if (touchStartBtn) touchStartBtn.classList.remove('visible');
    }
  }

  // Continue from highest level (C key, only on game over)
  if (keys['KeyC']) {
    keys['KeyC'] = false;
    if (state === ST.GAME_OVER && highestLevel > 1) {
      initAudio();
      level = highestLevel;
      score = 0;
      lives = 5;
      earnedMedals = new Set();
      flightStats = { kills: 0, damageTaken: 0, valour: 0 };
      initLevel();
      state = ST.PLAYING;
      if (touchStartBtn) touchStartBtn.classList.remove('visible');
    }
  }

  // Show/hide touch start button based on game state
  if (isTouchDevice && touchStartBtn) {
    if (state === ST.TITLE || state === ST.GAME_OVER) {
      touchStartBtn.classList.add('visible');
      touchStartBtn.textContent = state === ST.TITLE ? 'TAP TO START' : 'TAP TO RETRY';
    } else {
      touchStartBtn.classList.remove('visible');
    }
  }
}

// ‚îÄ‚îÄ Engine sound update ‚îÄ‚îÄ
function updateEngineSound() {
  if (!engineGain || !audioCtx) return;
  if (state === ST.PLAYING && player && !player.landed) {
    const speed = player.speed * PIXELS_PER_UNIT;
    engineOsc.frequency.value = 60 + speed * 0.3 + player.accel * 10;
    engineGain.gain.value = 0.02 + (player.accel / PLANE_MAX_ACCEL) * 0.03;
  } else {
    engineGain.gain.value = 0;
  }
}
setInterval(updateEngineSound, 50);

// ‚îÄ‚îÄ Start ‚îÄ‚îÄ
particles = [];
fleeingPeople = [];
dragons = [];
generateTerrain();
requestAnimationFrame(gameLoop);

})();
</script>
</body>
</html>
